Foreword
Nock

Hoon
Preface

volume 0, version stub
++  stub  

volume 1, Hoon models
++  abel  
++  axis  
++  also  
++  base  
++  beer  
++  beet  
++  bloq  
++  calf  
++  char  
++  chum  
++  claw  
++  coat  
++  coil  
++  coin  
++  cord  
++  date  
++  dime  
++  dram  
++  each  
++  edge  
++  foot  
++  gear  
++  hair  
++  hapt  
++  like  
++  limb  
++  line  
++  list  
++  mane  
++  mano  
++  manx  
++  marl  
++  mars  
++  mart  
++  marx  
++  metl  
++  null  
++  odor  
++  tarp  
++  time  
++  tree  
++  nail  
++  numb  
++  pair  
++  pass  
++  path  
++  pint  
++  port  
++  post  
++  prop  
++  qual  
++  rege  
++  ring  
++  rule  
++  span  
++  spot  
++  tank  
++  tape  
++  term  
++  tiki  
++  tile  
++  toga  
++  trel  
++  tuna  
++  twig  
++  tine  
++  tusk  
++  tyre  
++  tyke  
++  tram  
++  tone  

++  nock  
++  toon  
++  tune  
++  twin  
++  type  
++  typo  
++  udal  
++  udon  
++  umph  
++  unce  
++  unit  
++  upas  
++  urge  
++  vase  
++  vise  
++  wall  
++  wain  
++  wing  
++  wine  
++  woof  
++  wonk  
++  map  
++  qeu  
++  set  
++  jar  
++  jug  

volume 2, Hoon libraries and compiler

chapter 2a, basic unsigned math

++  add 
  Comment:
        add
  Description:
        Sums two numbers.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        It must yield an atom.
        Check if a is equal to 0.
        If it is, the arm produces b.
        Else, the arm is called again with a replaced by (dec a) and b by +(b).
  Examples:
        ~palryp-hocsyt/try=> (add 2 2)
        4
        ---
        ~palryp-hocsyt/try=> (add 1 1.000.000)
        1.000.001
        ---
        ~palryp-hocsyt/try=> (add 1.333 (mul 2 2))
        1.337
++  cap
  Comment:
        tree head
  Description:
        Yields whether an atom is in the head or tail of a noun.
  Explanation:
        This arm is jetted.
        It must yield either %2 or %3.
        Selects a case below for the actual type of a.
        Yield %2 if a is %2.
        %3 if it is %3.
        Fail if a is either %0 or %1.
        Else, call cap recursively with a replaced by a/2.
        The case statement is closed.
  Examples:
        ~palryp-hocsyt/try=> (cap 4)
        %2
        ---
        ~palryp-hocsyt/try=> (cap 6)
        %3
        ---
        ~palryp-hocsyt/try=> (cap (add 10 9))
        %2
++  dec  
  Comment:
        decrement
  Description:
        Decrements a number - Subtracts one.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        When the following code crashes, print "%decrement-underflow" in the stack trace.
        Produce the next gate asserting a is not 0.
        Let b be 0.
        Creates a dry %gold trap which yields an atom.
        Check if a is equal to the increment of b.
        If so, produce b.
        Else, recursively call dec by replacing the argument b with the increment of b.
  Examples:
        ~palryp-hocsyt/try=> (dec 7)
        6
        ---
        ~palryp-hocsyt/try=> (dec 0)
        ! decrement-underflow
        ! exit
++  div  
  Comment:
        divide
  Description:
        Divides one number by another.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which  accepts two atoms.
        It must yield an atom.
        When the following code crashes, print "div" in the stack trace.
        Produce the next trap asserting that b is not 0.
        Let c be 0.
        Create a dry %gold trap
        Build an if-then-else statement on whether a is less than b.
        If so, produce c.
        Else, recursively call with a replaced by the difference of a and b and c by 
        the increment of c.
  Examples:
        ~palryp-hocsyt/try=> (div 4 2)
        2
        ---
        ~palryp-hocsyt/try=> (div 17 8)
        2
        ---
        ~palryp-hocsyt/try=> (div 20 30)
        0 
++  fac  
  Comment:
        factorial
  Description:
        Produces the factorial of a number n, n!.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        It must yield an atom.
        Build an if-then-else statement on whether a is equal to 0.
        If so, produce 1.
        Else, multiply a by the recursive call of factorial with the decrement of a.
  Examples:
        ~palryp-hocsyt/try=> (fac 3)
        6
        ---
        ~palryp-hocsyt/try=> (fac 0)
        1
        ---
        ~palryp-hocsyt/try=> (fac 11)
        39.916.800
++  gte
  Comment:
        greater than or equal
  Description:
        Produces the loobean a>=b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Yield false if a is less than b, true else.
  Examples:
        ~palryp-hocsyt/try=> (gte 100 10)
        %.y
        ---
        ~palryp-hocsyt/try=> (gte 4 4)
        %.y
        ---
        ~palryp-hocsyt/try=> (gte 3 4)
        %.n
++  gth
  Comment:
        greater than
  Description:
        Produces the loobean a>b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Yield false if a is less than or equal to b, true else.
  Examples:
        ~ronrem-lonsem/try=> (gth 4 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (gth 5 4)
        %.y
        ---
        ~ronrem-lonsem/try=> (gth 5 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (gth 0 0)
        %.n
++  lte  
  Comment:
        less than or equal to
  Description:
        Produces the loobean a<=b.
  Explanation:
        This is a jetted arm.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Use logical OR to yield true if either a=b or (lth a b) is true.
  Examples:
        ~ronrem-lonsem/try=> (lte 4 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lte 5 4)
        %.n
        ---
        ~ronrem-lonsem/try=> (lte 5 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lte 0 0)
        %.y
++  lth  
  Comment:
        less than
  Description:
        Produces the loobean a<b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Use logical AND, thus immediately producing false if a=b.
        Then, create and kick a dry %gold trap which produces true on a=0,
        or false if a!=0 and b=0.
        If none of these cases are met, recursively call lth with both a and b decremented.
  Examples:
        ~ronrem-lonsem/try=> (lth 4 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lth 5 4)
        %.n
        ---
        ~ronrem-lonsem/try=> (lth 5 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (lth 5 0)
        %.n
++  mas  
  Comment:
        tree body
  Description:
       Produces the axis of a within the head or the tail. 
  Explanation:
        This arm is jetted.
        Creates a dry gold gate with a sample which accepts an atom.
        Must produce an atom.
        Selects a case below for the actual type of a.
        Exit if a is 1.
        Produce 1 if a is either 2 or 3.
        Else, sum the modulus of a and 2 with the 2 multiplied by the recursive call of 
        mas with a replaced by a/2.
  Examples:
        1 ~ronrem-lonsem/try=> (mas 3)
        1
        ---
        ~ronrem-lonsem/try=> (mas 4)
        2
        ---
        ~ronrem-lonsem/try=> (mas 5)
        3
        ---
        ~ronrem-lonsem/try=> (mas 6)
        2
        ---
        ~ronrem-lonsem/try=> (mas 7)
        3
        ---
        ~ronrem-lonsem/try=> (mas 8)
        4
        ---
        ~ronrem-lonsem/try=> (mas 0)
        ! exit
        ---
        ~ronrem-lonsem/try=> (mas 1)
        ! exit
++  max  
  Comment:
        maximum
  Description:
        Yields the larger of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Build an if-else-then statement on a>b.
        If so, produce a.
        Else, produce b.
  Examples:
        ~palryp-hocsyt/try=> (max 10 100)
        100
        ---
        ~palryp-hocsyt/try=> (max 10.443 9)
        10.443
        ---
        ~palryp-hocsyt/try=> (max 0 1)
        1
++  min  
  Comment:
        minimum
  Description:
        Yields the smaller of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Build an if-then-else statement on a<b.
        If so, produce a.
        Else, produce b.
  Examples:
        ~palryp-hocsyt/try=> (min 10 100)
        10
        ---
        ~palryp-hocsyt/try=> (min 10.443 9)
        9
        ---
        ~palryp-hocsyt/try=> (min 0 1)
        0
++  mod  
  Comment:
        remainder
  Description:
        Yields the modulus of (a mod b).
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Assert that b is not 0 before producing the below.
        Produce the difference of a and the product of b times a/b.
  Examples:
++  mul  
  Comment:
        multiply
  Description:
        Multiplies two numbers.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Let c be 0.
        Create and kick a dry %gold trap.
        Build an if-then-else statement on a=0.
        If so, produce c.
        Else, recursively call multiply with a replaced by decremented a and c replaced by b+c.
  Examples:
++  peg  
  Comment:
        tree connect
  Description:
        Produces the axis of b within the axis of a.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Select a case below for the actual type of b.
        Yield a on b=1.
        Yield (mul a 2) on b=2.
        Yield the increment of (mul a 2) on b=3.
        Else, sum (b mod 2) with the product of 2 and the recursive call to peg with b replaced by b/2.
  Examples:
        ~ronrem-lonsem/try=> (mul 5 3)
        15
        ---
        ~ronrem-lonsem/try=> (mul 1 0)
        0
++  sub  
  Comment:
        subtract
  Description:
        Accepts two atoms, a and b, and produces a-b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        When the following code crashes, print "%subtract-underflow" in the stack trace.
        Must produce an atom.
        Build an if-then-else statement on b=0.
        If so, produce a.
        Else, produce the recursive call of subtract with a and b replaced by their respective decrements.
  Examples:
        ~ronrem-lonsem/try=> (sub 10 5)
        5
        ---
        ~ronrem-lonsem/try=> (sub 243 44)
        199
        ---
        ~ronrem-lonsem/try=> (sub 5 0)
        5
        ---
        ~ronrem-lonsem/try=> (sub 0 5)
        ! subtract-underflow
        ! exit

chapter 2b, basic containers

Section 2bA, units                    

++  biff 
  Comments:
        apply
  Description:
        Accepts a unit 'a' and a gate 'b' which produces a unit from the type of u.a, slamming the gate 
        with the value of a when a isn't null and producing ~ when it is.
  Explanation:
        Creates a vulanixed wet gate with a sample which accepts a unit and a $+(* (unit)) tiled gate.
        Build an if-then-else statement "a is null."
        If so, produce null.
        Else, produce b slammed with u.a.
  Examples:
        ~palryp-hocsyt/try=> (biff (some 5) |=(a=@ (some (add a 2))))
        [~ u=7]
        ---
        ~palryp-hocsyt/try=> (biff ~ |=(a=@ (some (add a 2))))
        ~
++  bind 
  Comments:
        argue
  Description:
        Accepts a unit 'a' and a gate 'b', producing a unit with value (b u.a) or, when a is null, null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit and a gate.
        Build an if-then-else statement on "a is null."
        If so, produce null.
        Else, produce the a unit with value (b u.a), gate 'b' slammed with u.a.
  Examples:
        ~talsur-todres/try=> (bind ((unit ,@) [~ 97]) ,@t)
        [~ `a`]
        ---
        ~talsur-todres/try=> =a |=(a=@ (add a 1))
        ~talsur-todres/try=> (bind ((unit ,@) [~ 2]) a)
        [~ 3]
++  clap 
  Comments:
        combine
  Description:
        Applies a binary operation to the values of two units, producing the product as a unit.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts two units and a gate.
        Build an if-then-else statment on "a is null."
        If so, produce b.
        Else, build an if-then-else statement on "b is null."
        If so, produce a.
        Else, produce the unit with value (c u.a u.b)
  Examples:
        ~palryp-hocsyt/try=> =u ((unit ,@t) [~ 'a'])
        ~palryp-hocsyt/try=> =v ((unit ,@t) [~ 'b'])
        ~palryp-hocsyt/try=> (clap u v |=([a=@t b=@t] (welp (trip a) (trip b))))
        [~ u="ab"]
        ---
        ~talsur-todres/try=> =a ((unit ,@u) [~ 1])
        ~talsur-todres/try=> =b ((unit ,@u) [~ 2])
        ~talsur-todres/try=> =c |=([a=@ b=@] (add a b))
        ~talsur-todres/try=> (clap a b c)
        [~ 3]
++  drop 
  Comments:
        enlist
  Description:
        Accepts a unit and produces the list [u.a ~] or null when the unit is null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit.
        Builds an if-then-else statement on "a is null."
        If so, produces null.
        Else, produce the list [u.a ~].
  Examples:
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> (drop a)
        [i=97 t=~]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~])
        ~divreg-misdef/try=> (drop a)
        ~
++  fall 
  Comments:
        default
  Description:
         a default value 'b' for the unit 'a' when it is null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit and any noun.
        Produces b if a is null and u.a if it is not.
  Examples:
        ~talsur-todres/try=> (fall ~ `a`)
        `a`
        ---
        ~talsur-todres/try=> (fall [~ u=0] `a`)
        0
++  mate 
  Comments:
        choose
  Description:
        Produces the unit 'a' or 'b' which is not null and crashes with error "mate" if they are equal.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a two units.
        Build an if-then-else statement on "b is null."
        If so, produce a.
        Else, build an if-then-else statement on "a is null."
        If so, produce b.
        Else, build an if-else-then statement on  u.a=u.b.  Crash on "mate" if false, produce a if true.
  Examples:
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~ 97])
        ~divreg-misdef/try=> (mate a b)
        [~ 97]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~])
        ~divreg-misdef/try=> (mate a b)
        [~ 97]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~ 98])
        ~divreg-misdef/try=> (mate a b)
        ! 'mate'
        ! exit
++  need 
  Comments:
        demand
  Description:
        Retrieves the value from a unit, crashing if the unit is null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit.
        Build an if-then-else statement on "a is an atom."
        If so, crash.
        Else, produce u.a from the unit a.
  Examples:
        ~divreg-misdef/try=> =a ((unit ,[@t @t]) [~ [`a` ' b']])
        ~divreg-misdef/try=> (need a)
        [`a` ' b']
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~])
        ~divreg-misdef/try=> (need a)
        ! exit
++  some 
  Comments:
        lift
  Description:
        Casts any noun a to its unit, [~ a].
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts any noun.
        Produces the tuple [~ u=a], the unit of value a.
  Examples:
        ~divreg-misdef/try=> (some [`a` `b`])
        [~ u=[`a` `b`]]
        ---
        ~divreg-misdef/try=> (some &)
        [~ u=%.y]

Section 2bB, lists                    

++  flop 
  Comments:
        reverse
  Description:
        Produces the list 'a' with the elements reversed.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a single list.
        'a' is then replaced with (homo a) and used as the subject for the code below (=>).
        The type of the result must be the same as a, our argument list.
        Let b be a list of the type of the icon of a, as it is bunted.
        Create and kick a dry %gold trap
        Build an if-then-else statement on "a is an atom."
        If so, produce b.
        Else, recursively call flop with a replaced by it's tail and b replaced by [i.a b], where
        i.a is the head of a.
  Examples:
        ~palryp-hocsyt/try=> =lyst (limo [1 2 3 4 ~])
        ~palryp-hocsyt/try=> lyst
        [i=1 t=[i=2 t=[i=3 t=[i=4 t=~]]]]
        ~palryp-hocsyt/try=> (flop lyst)
        ~[4 3 2 1]
        ---
        ~palryp-hocsyt/try=> (flop (limo [1 'a' 2 'b' (some 10) ~]))
        ~[[~ u=10] 98 2 97 1]
++  homo 
  Comments:
        homogenize
  Description:
        Homogenizes a lists' type information.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a single list.
        Makes the type of the result the type of the product of the code below (^+).
        The subject of the arm ($) is then the product of the barcen statement below (=<).
        Creates a %gold core (|%) and the arm '+-  $'.
        XXX BLACK BOX, ABANDON ALL HOPE YE WHO ENTER HERE XXX
        Terminates the core.
        Produces list a.
  Examples:
        ~palryp-hocsyt/try=> lyst
        [i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]
        ~palryp-hocsyt/try=> (homo lyst)
        ~[1 97 2 98 [~ u=10]]
        ---
        ~palryp-hocsyt/try=> =a (limo [1 2 3 ~])
        ~palryp-hocsyt/try=> a
        [i=1 t=[i=2 t=[i=3 t=~]]]
        ~palryp-hocsyt/try=> (homo a)
        ~[1 2 3]
++  limo 
  Comments:
        listify
  Description:
        Produces a list from any null-terminated tuple.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a single list.
        Makes the type of the result the type of the product of the code below (^+).
        The subject of the arm ($) is then the product of the barcen statement below (=<).
        Creates a %gold core (|%) and the arm '+-  $'.
        XXX BLACK BOX, ABANDON ALL HOPE YE WHO ENTER HERE XXX
        Terminates the core.
        Produces list a.
  Examples:
        ~palryp-hocsyt/try=> (limo [1 'a' 2 'b' (some 10) ~])
        [i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]
        ---
        ~palryp-hocsyt/try=> (limo [`a` `b` ~])
        [i=`a` t=[i=`b` t=~]]
        ---
        ~palryp-hocsyt/try=> (limo [2 1 ~])
        [i=2 t=[i=1 t=~]]
++  lent 
  Comments:
        length
  Description:
        Produces the atomic length of any list.
  Explanation:
        This is a jetted arm.
        Creates a dry %gold gate with a sample which accpets a single list.
        Must produce an atom.
        Let b be 0.
        Creates and kicks a dry %gold trap.
        Builds an if-then-else statement on "a is an atom."  If so, produces b.
        Else, recursively calls length with the list set to the tail of a and the accumulator, b, incremented.
  Examples:
        ~palryp-hocsyt/try=> (lent (limo [1 2 3 4 ~]))
        4
        ---
        ~palryp-hocsyt/try=> (lent (limo [1 'a' 2 'b' (some 10) ~]))
        5
++  levy
  Comments:
       all of
  Description:
        Applies the loobean gate 'b' to every element of the list 'a', producing the logical AND of all the results.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate with a sample of any noun
        and produces a loobean.
        Then, a dry %gold trap is created and kicked.  It must produce a loobean.
        Build an if-then-else statement on "a is an atom."
        If so, produce true.
        Else, build an if-then-else statement on (b i.a)
        If so, then recursively call levy with a replaced by the tail of a.
        Else, produce no.
  Examples:
        ~palryp-hocsyt/try=> =b |=(a=@ (gte a 1))
        ~palryp-hocsyt/try=> (levy (limo [0 1 2 1 ~]) b)
        %.n
        ---
        ~palryp-hocsyt/try=> =b |=(a=@ (gte a 0))
        ~palryp-hocsyt/try=> (levy (limo [0 1 2 1 ~]) b)
        %.y        
++  lien 
  Comments:
        some of
  Description:
        Applies the loobean gate 'b' to every element of the list 'a', producing the logical OR of all the results.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate with a sample of any noun
        and produces a loobean.
        Then, a dry %gold trap is created and kicked.  It must produce a loobean.
        Build an if-then-else gate on "a is null."  If so, produce false.
        Else, build an if-then-else gate on (b i.a).  If so, produce true.
        Else, recursively call lien with a replaced by the tail of a (t.a).
  Examples:
        ~palryp-hocsyt/try=> =a |=(a=@ (gte a 1))
        ~palryp-hocsyt/try=> (lien (limo [0 1 2 1 ~]) a)
        %.y
        ---
        ~palryp-hocsyt/try=> =a |=(a=@ (gte a 3))
        ~palryp-hocsyt/try=> (lien (limo [0 1 2 1 ~]) a)
        %.n
++  reel 
  Comments:
        right fold
  Description:
        Accepts a list 'a' and a gate 'b' which accepts two nouns, then folds (recursively calls 'b' across) the 
        list right to left, producing a value of the list element's type.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a trap which accepts two nouns.
        A dry %gold trap is created and kicked.  It must produce the type of the list's elements.
        Build a if-then-else statement on "a is an atom."
        If so, produce q.b.
        Else, recursivley call b with the head of a and the rest of a replaced by the tail of a.
  Examples:     
        ~palryp-hocsyt/try=> =sum =|([p=@ q=@] |.((add p q)))
        ~palryp-hocsyt/try=> (reel (limo [1 2 3 4 5 ~]) sum)
        15
        ---
        ~palryp-hocsyt/try=> =a =|([p=@ q=@] |.((sub p q)))
        ~palryp-hocsyt/try=> (reel (limo [6 3 1 ~]) a)
        4
        ---
        ~palryp-hocsyt/try=> (reel (limo [3 6 1 ~]) a)
        ! subtract-underflow
        ! exit
++  roll 
  Comments:
        left fold
  Description:
        Accepts a list 'a' and a gate 'b' which accepts two nouns, then folds (recursively calls 'b' across) the
        list left to right, producing a value of the list of the element's type.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a trap which accepts two nouns.
        A dry %gold trap is then created and kicked.  It must produce the type of the list's elements.
        Build an if-then-else statement on "a is an atom."
        If so, produce q.b.
        Else, recursively call roll with a replaced by the tail of a and b by the recursive call of b
        with q replaced by (b i.a q.b).
  Examples:
        ~barred-tidset/try=> =a =|([p=@ q=@] |.((sub p q)))
        ~barred-tidset/try=> (roll (limo [1 2 3 ~]) a)
        2
        ---
        ~barred-tidset/try=> (roll (limo [3 6 3 ~]) a)
        0
++  skid 
  Comments:
       separate
  Description:
        Accepts a list and a gate which takes any noun and produces a loobean.  Produces two lists, one who's elements
        produce true and one who's produce false by slamming the gate with them.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a list and a gate which accepts any noun and 
        produces a loobean.
        Creates and kicks a dry %gold trap.  It must produce a tuple of two lists af a's type
        Build an if-then-else statement on "a is null"  If so, produce a tuple of two nulls.
        Else, let c be the recursive call of skid with a replaced by the tail of a.
        Build an if-then-else statement on (b i.a).  If so, produce [[i.a p.c] q.c].
        Else, produce [p.c [i.a q.c]] where p.c and q.c are the separate list results of c.
  Examples:
        ~dovryp-toblug/try=> =a |=(a=@ (gth a 1))
        ~dovryp-toblug/try=> (skid (limo [0 1 2 3 ~]) a)
        [p=[i=2 t=[i=3 t=~]] q=[i=0 t=[i=1 t=~]]]
++  skim 
  Comments:
        only
  Description:
        Accepts a list 'a' and a gate 'b' which takes any noun and produces loobean.  
        Produces the sublist of 'a' whose elements produce true by slamming the gate with them.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate which accepts any noun and 
        produces a loobean.
        Creates and kicks a dry %gold trap.
        Which must return a list of a's type.
        Build an if-then-else statement on "a is an atom."
        If so, prodoce null.
        Else, build an if-then-else statement on (b i.a).  If so, produce [i.a $(a t.a)], where $(a t.a) is the recursive
        call of skim with a replaced by the tail of a.
        Else, produce $(a t.a).
  Examples:
        ~dovryp-toblug/try=> =a |=(a=@ (gth a 1))
        ~dovryp-toblug/try=> (skim (limo [0 1 2 3 ~]) a)
        [i=2 t=[i=3 t=~]]
++  skip 
  Comments:
        except
  Description:
        Accepts a 'a' list and a gate 'b' which takes any noun and produces a loobean.
        Produces the sublist of 'a' whose elments produce false by slamming the gate with them.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate which accepts any noun and 
        produces a loobean.
        Creates and kicks a dry %gold trap.
        Which must return a list of a's type.
        Build an if-then-else statement on "a is an atom."
        If so, produce null.
        Else build na if-then-else statement on (b i.a).  If so, produce the recursive call of skip with a replacd by
        the tail of a.
        Else, produce [i.a $(a t.a)].
  Examples:
        ~dovryp-toblug/try=> =a |=(a=@ (gth a 1))
        ~dovryp-toblug/try=> (skip (limo [0 1 2 3 ~]) a)
        [i=0 t=[i=1 t=~]]
++  scag 
  Comments:
        prefix
  Description:
        Accepts an atom 'n' and list 'b',  producing the first n elements at the front of the list.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts an atom and a list.
        A dry %gold trap is created and kicked.  It must produce a list of the same type as 'b'.
        Build an if-then-else statement on the logical OR statement (a=0 or b is in null).
        If so, produce null.
        Else, produce [i.b $(b t.b, a (dec a))] where 'i.b' is the head of 'b' and $(b t.b, a (dec a))
        is the recursive call of scag with 'b' replaced by the tail of 'b' and 'a' decremented.
  Examples:
        ~palryp-hocsyt/try=> (scag 2 (limo [0 1 2 3 ~]))
        [i=0 t=[i=1 t=~]]
        ---
        ~palryp-hocsyt/try=> (scag 10 (limo [1 2 3 4 ~]))
        [i=1 t=[i=2 t=[i=3 t=[i=4 t=~]]]]
++  slag 
  Comments:
        suffix
  Description:
        Accepts an atom 'n' and a list 'b', producing the last n elemnents at the back of the list.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts an atom and a list.
        A dry %gold trap is created and kicked.  It must produce a list of the same type as 'b'.
        Build an if-then-else statement on a=0.
        If so, produce 'b'.
        Else, build an if-then-else statement on "b is an atom."
        If so, produce null.
        Else, call slag recursively with b replaced by the tail of b, a replaced by the decrement of a.
  Examples:
        ~palryp-hocsyt/try=> (slag 2 (limo [0 1 2 3 ~]))
        [i=2 t=[i=3 t=~]] 
        ---
        ~palryp-hocsyt/try=> (slag 2 (limo [1 2 3 4 ~]))
        [i=3 t=[i=4 t=~]]
++  snag 
  Comments:
        index
  Description:
        Accepts an atom and a list, producing the element at the index of the atom in the list and failing is the list
        is null.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts an atom and a list.
        A dry %gold trap is created and kicked.
        Build an if-then-else statement on "b is null."
        If so, fail with "snag-fail" in the stack trace.
        Else, build an if-then-else statement on a=0.
        If so, produce the head of 'b'.
        Else, recursively call snag with 'b' replaced by the tail of 'b' and 'a' decremented.
  Examples:
        ~palryp-hocsyt/try=> (snag 2 (limo [3 2 1 0 ~]))
        1
        ---
        ~palryp-hocsyt/try=> (snag 4 (limo [1 2 3 4 5 6 7 8 ~]))
        5
++  sort 
  Comments:
        quicksort
  Description:
        Accepts a list and a gate with a sample which accepts two nouns and produces a loobean.  'sort' then produces a 
        list of the elements of 'a' sorted according to 'b'.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate which accepts two nouns and
        produces a loobean.
        Homogenizes the list and makes it the subject of the following code, casting the following to the
        homogenized list type.
        Creates and kicks dry %gold trap.  It must produce a list of a's type.
        Builds an if-then-else statement on "a is null."  If so, produce null.
        Slam the weld gate with the q and r below.
        The q and r are then defined to be the recursive call of the trap with the skim of the tail by our sort gate.
        For q, it skims by (b c i.a).  For r, by !(b c i.a).
        r is first cast to the type of the tail of 'a' and produced as a tuple behind the head of 'a'.
  Examples:
        ~dovryp-toblug/try=> =a =|([p=@ q=@] |.((gth p q)))
        ~dovryp-toblug/try=> (sort (limo [0 1 2 3 ~]) a)
        ~[3 2 1 0]
++  swag 
  Comments:
        infix
  Description:
        A range in a list - Produces the values in list 'c' starting at index 'a' and spanning 'b' elements
        more than that.
  Explanation:
        Creates a vulcanized wet with a sample which gate which accepts a tuple of atoms and a list 'c'.
        The last 'a' elements in 'c' are selected by slag.  Then the first 'b' elements of 
        those last elements are selected and produced by scag.
  Examples:
        ~palryp-hocsyt/try=> (swag [0 5] (limo [1 2 3 4 5 6 7 8 9 10 ~]))
        [i=1 t=[i=2 t=[i=3 t=[i=4 t=[i=5 t=~]]]]]
        ---
        ~palryp-hocsyt/try=> (swag [3 5] (limo [1 2 3 4 5 6 7 8 9 10 ~]))
        [i=4 t=[i=5 t=[i=6 t=[i=7 t=[i=8 t=~]]]]]
        ---
        ~palryp-hocsyt/try=> (swag [1 2] (limo [1 2 3 ~]))
        [i=2 t=[i=3 t=~]] 
++  turn 
  Comments:
        transform
  Description:
        Accepts a list and a gate.  Produces the list with the gate applied to each element of the original list.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts a list and a gate.
        Creates and kicks a dry %gold trap.
        Build an if-then-else statement on "a is an atom."
        If so, produce null.
        Else, produce the tuple with head (b i.a) and tail that is turn applied recursively to the tail of 'a'.
  Examples:
        ~dovryp-toblug/try=> (turn (limo [104 111 111 110 ~]) ,@t)
        <|h o o n|>
++  weld 
  Comments:
        concatenate
  Description:
        Concatenates two lists.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts two lists.
        Homogenizes both lists and makes them the subject of the following code.
        A dry %gold trap is created and kicked.  It must return the type of list 'b'.
        Build an if-then-else statement on "a is null."  If so, produce 'b'.
        Else, produce the tuple [i.a $(a t.a)].  'i.a' is the head of 'a', $(a t.a) the recursive call of weld
        with 'a' replaced by the tail of a.
  Examples:
        ~palryp-hocsyt/try=> (weld (limo [1 2 3 ~]) (limo [4 5 6 ~]))
        ~[1 2 3 4 5 6]
        ~palryp-hocsyt/try=> (weld "foo" "bar")
        ~[~~f ~~o ~~o ~~b ~~a ~~r]
++  welp 
  Comments:
        perfect weld
  Description:
        Concatenates two lists without losing their type information to homogenization.
        Produces a tape when passed two tapes.
  Explanation:
        XXX DON'T WORRY ABOUT HOW THIS WORKS, IT IS A PERPETUAL MIYSTERY TO US ALL. XXX
  Examples:
        ~palryp-hocsyt/try=> (welp "foo" "bar")
        "foobar"
++  wild 
  Comments:
        concatenate
  Description:
        Concatenates two lists without casting the product back to a list.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts two lists.
        Homogenizes both lists and makes them the subject of the following code.
        A dry %gold gate is created and kicked.
        Build an if-then-else statement on "a is null."  If so, produce 'b'.
        Else, produce the tuple with head (b i.a) and tail that is turn applied recursively to the tail of 'a'.
  Examples:
        ~palryp-hocsyt/try=> =norm (limo [1 2 3 4 5 ~])
        ~palryp-hocsyt/try=> =norm2 (limo [6 7 8 ~])
        ~palryp-hocsyt/try=> (wild norm norm2)
        ~[1 2 3 4 5 6 7 8]
        ---
        ~palryp-hocsyt/try=> (wild "foo" "bar")
        ~[~~f ~~o ~~o ~~b ~~a ~~r]
        ---
        ~palryp-hocsyt/try=> (homo (weld "foo" "bar"))
        ~[~~f ~~o ~~o ~~b ~~a ~~r]
        ~palryp-hocsyt/try=> (homo (wild "foo" "bar"))
        ! -find-limb.t
        ! find-fork
        ! exit
++  zing 
  Comments:
        promote
  Description:
        Turns a list of lists into a single list by promoting the elements of each sublist into the higher.
  Explanation:
        Creates a vulcanized wet gate with a sample that accepts a list of lists.
        Casts the result to the type the homogenized list head, asserting that 'a' is at least a cell.
        A dry %gold trap is created and kicked.
        Build an if-then-else statement on "a is null."  If so, produce null.
        Else, weld together the head of a with the recrusive call of zing on the tail of a.
  Examples:
        ~palryp-hocsyt/try=> (zing (limo [(limo ['a' 'b' 'c' ~]) (limo ['e' 'f' 'g' ~]) (limo ['h' 'i' 'j' ~]) ~]))
        ~['a' 'b' 'c' 'e' 'f' 'g' 'h' 'i' 'j']
        ~palryp-hocsyt/try=> (zing (limo [(limo [1 'a' 2 'b' ~]) (limo [3 'c' 4 'd' ~]) ~]))
        ~[1 97 2 98 3 99 4 100]

chapter 2c, simple noun surgery

section 2cA, bit surgery              **capitalization of "section" inconsistent in source**

++  bex  
  Comments:
        binary exponent
  Description:
        Produces 2 to the nth power for some atom 'n'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts a single atom.
        Casts the result to an atom.
        Build an if-then-else statement on a=0.
        If so, produce 1.
        Else, multiply two by the recursive call of bex on the decrement of a.
  Examples:
        ~palryp-hocsyt/try=> (bex 4)
        16
        ~palryp-hocsyt/try=> (bex (add 19 1))
        1.048.576
        ~palryp-hocsyt/try=> (bex 0)
        1
++  xeb  
  Comments:
  Description:
  Explanation:
  Examples:
++  can  
  Comments:
  Description:
  Explanation:
  Examples:
++  cat  
  Comments:
  Description:
  Explanation:
  Examples:
++  cut  
  Comments:
  Description:
  Explanation:
  Examples:
++  end  
  Comments:
  Description:
  Explanation:
  Examples:
++  fil  
  Comments:
  Description:
  Explanation:
  Examples:
++  lsh  
  Comments:
  Description:
  Explanation:
  Examples:
++  met  
  Comments:
  Description:
  Explanation:
  Examples:
++  rap  
  Comments:
  Description:
  Explanation:
  Examples:
++  rep  
  Comments:
  Description:
  Explanation:
  Examples:
++  rip  
  Comments:
  Description:
  Explanation:
  Examples:
++  rsh  
  Comments:
  Description:
  Explanation:
  Examples:
++  swap 
  Comments:
  Description:
  Explanation:
  Examples:

section 2cB, bit logic                

++  con  
++  dis  
++  mix  
++  not  

section 2cC, noun orders              

++  aor  
++  dor  
++  gor  
++  hor  
++  vor

section 2cD, insecure hashing         

++  fnv
++  mug

section 2cE, phonetic base            

++  po
  ++  ind 
  ++  ins 
  ++  tod 
  ++  tos 

section 2cF, signed and modular ints  

++  si    
  ++  abs 
  ++  dif 
  ++  dul 
  ++  fra 
  ++  new 
  ++  old 
  ++  pro 
  ++  rem 
  ++  sum 
  ++  sun 
  ++  syn 
++  fe    
  ++  dif 
  ++  inv 
  ++  net 
  ++  out 
  ++  rol 
  ++  ror 
  ++  sum 
  ++  sit 

section 2cG, floating point           

++  rlyd  
++  rlyh  
++  rlyq  
++  rlys  
++  ryld  
++  rylh  
++  rylq  
++  ryls  

section 2cH, urbit time               

++  year  
++  yore  
++  yell  
++  yule  
++  yall  
++  yawn  
++  yelp  
++  yo    
      ++  day 
      ++  era 
      ++  hor 
      ++  jes 
      ++  mit 
      ++  moh 
      ++  moy 
      ++  qad 
      ++  yer 

section 2cI, almost macros            
++  hard
++  soft

chapter 2d, containers

section 2dA, sets     
                
++  apt       
++  in        
  +-  all
  +-  any
  +-  del
  +-  dig
  +-  gas
  +-  has
  +-  put
  +-  rep
  +-  tap
  +-  wyt

section 2dB, maps                     

++  ept       
++  ja        
  +-  get
  +-  add
++  ju        
  +-  get
  +-  has
  +-  put
++  by        
  +-  all
  +-  any
  +-  del
  +-  dig
  +-  gas
  +-  get
  +-  has
  +-  mar
  +-  put
  +-  rep
  +-  rib
  +-  run
  +-  tap
  +-  uni
  +-  wyt

section 2dC, queues                   

++  to        
  +-  bal
  +-  dep
  +-  gas
  +-  get
  +-  nap
  +-  put
  +-  tap
  +-  top

section 2dD, casual containers        

++  mo        
++  sa        
++  qu        

chapter 2e, miscellaneous libs

section 2eA, packing          
        
++  cue       
++  jam       
++  mat       
++  rub       

section 2eB, parsing (tracing)        

++  last  
++  lust  

section 2eC, parsing (custom rules)   

++  cold  
++  cook  
++  easy  
++  fail  
++  full  
++  funk  
++  here  
++  jest  
++  just  
++  knee  
++  mask  
++  next  
++  sear  
++  shim  
++  stag  
++  stet
++  stew
++  stir
++  stun  

section 2eD, parsing (combinators)    

++  bend  
++  comp
++  glue  
++  pfix  
++  plug  
++  pose  
++  sfix  

section 2eE, parsing (composers)      

++  bass
++  boss
++  ifix
++  more
++  most
++  plus  
++  slug
++  star

section 2eF, parsing (ascii)          

++  ace 
++  bar 
++  bas 
++  buc 
++  cab 
++  cen 
++  col 
++  com 
++  doq 
++  dot 
++  fas 
++  gal 
++  gar 
++  hax 
++  kel 
++  ker 
++  ket 
++  lus 
++  hep 
++  pel 
++  pam 
++  per 
++  pat 
++  sel 
++  sem 
++  ser 
++  sig 
++  soq 
++  tar 
++  tec 
++  tis 
++  wut 
++  zap 

section 2eG, parsing (whitespace)     

++  dog 
++  doh 
++  dun 
++  duz 
++  gah 
++  gap 
++  gaq 
++  gay 
++  vul 

section 2eH, parsing (idioms)         

++  alf 
++  aln 
++  alp 
++  bet 
++  bin 
++  but 
++  cit 
++  dem 
++  dit 
++  gul 
++  gon 
++  hex 
++  hig 
++  hit 
++  low 
++  mes 
++  nix 
++  nud 
++  poy 
++  qit 
++  qut 
++  sym
++  ven 
++  vit 

section 2eI, parsing (external)       

++  rash
++  rush
++  rust
++  scan

section 2eJ, formatting (basic text)  

++  cass
++  cuss
++  crip
++  mesc
++  runt
++  sand
++  sane
++  trim
++  trip
++  teff
++  turf
++  tuba
++  tufa
++  tuft
++  wack
++  wick
++  woad
++  wood

section 2eK, formatting (layout)      

++  re
  ++  ram
  ++  win
    ++  din 
    ++  fit 
    ++  rig
    ++  wig

section 2eL, formatting (path)        

++  ab
  ++  bix  
  ++  hif  
  ++  huf  
  ++  hyf  
  ++  pev  
  ++  pew  
  ++  piv  
  ++  piw  
  ++  qeb  
  ++  qex  
  ++  qib  
  ++  qix  
  ++  seb  
  ++  sed  
  ++  sev  
  ++  sew  
  ++  sex  
  ++  sib  
  ++  siq  
  ++  sid  
  ++  siv  
  ++  siw  
  ++  six  
  ++  sov  
  ++  sow  
  ++  sox  
  ++  ted  
  ++  tip  
  ++  tiq  
  ++  tid  
  ++  til  
  ++  urs  
  ++  urt  
  ++  voy  
  ++  vym  
  ++  vyn  
++  ag
  ++  ape  
  ++  bay  
  ++  bip  
  ++  dem  
  ++  dim  
  ++  dum  
  ++  fed  
  ++  hex  
  ++  lip  
  ++  qut  
  ++  sym  
  ++  tyq  
  ++  viz  
  ++  vum  
  ++  wiz  
++  co
      ++  rear
      ++  rent
      ++  rend
      ++  a-co
      ++  d-co
      ++  r-co
      ++  s-co
      ++  v-co
      ++  w-co
      ++  x-co
      ++  y-co
      ++  z-co
  ++  em-co
  ++  ox-co
  ++  ro-co
++  ne
  ++  d  
  ++  x  
  ++  v  
  ++  w  
++  mu
  ++  zag
  ++  zig
  ++  zug
++  so
  ++  bisk
  ++  crub
  ++  nuck
  ++  nusk
  ++  perd
  ++  royl
  ++  tash
  ++  twid
  ++  zust
++  scot 
++  scow 
++  slav  
++  slaw
++  slay
++  smyt

section 2eM, regular-expressions      

++  pars
++  nor
++  les  
++  lep  
++  alm  
++  alb  
++  mis  
++  anns 
++  mall
++  bets
++  ranc
++  flap 
++  rang
++  chun
++  seac
++  sead
++  sade
++  seap
++  cape
++  lower
++  upper
++  digit
++  print
++  graph
++  blank
++  space
++  cntrl
++  alpha
++  alnum
++  punct
++  wordc
++  white
++  xdigi
++  chad
++  escd
++  escp
++  unid
++  proc 
++  cont
++  abor
++  matc
++  chet
++  blak 
++  deep
++  rexp 
++  repg 

section 2eN, pseudo-cryptography      

++  un   
  ++  wre
  ++  wre
  ++  xaf
  ++  xar
  ++  zaf
  ++  zar
  ++  zyf
  ++  zyr

section 2eO, virtualization           

++  mack
++  mink
++  mock
++  mook
++  mang
++  mong
++  mung
++  mule 
++  mute 

section 2eP, diff          **noted as "(move me)" in source**

++  berk 
++  diff 
++  loss 
  ++  abet
  ++  hink
  ++  lonk
  ++  lune
  ++  merg
  ++  main
++  locz  
++  lore  
++  role  
++  lump  
++  lure  
++  limp  
++  hump  
++  husk  
++  lurk  
++  lusk  
  ++  abet
  ++  done
  ++  main
++  nude   
  ++  axes 
  ++  tred 

section 2eW, lite number theory           

++  egcd   
++  pram   
++  ramp   
++  fo     
  ++  dif
  ++  exp
  ++  fra
  ++  inv
  ++  pro
  ++  sit
  ++  sum
++  ga     
      ++  dif 
      ++  dub 
      ++  pro 
      ++  toe 
      ++  sit 
  ++  fra     
  ++  inv     
  ++  pow     
  ++  pro     

section 2eX, jetted crypto                

++  aesc      
  ++  en      
  ++  de      
++  ahem      
        ++  cipa 
          ++  co 
          ++  ix 
          ++  ro 
          ++  su 
    ++  pen      
      ++  co  
      ++  ix  
      ++  ro  
      ++  su  
    ++  pin   
      ++  co  
      ++  ix  
      ++  ro  
      ++  su  
    ++  mcol
    ++  pode  
    ++  sube  
  ++  be      
          ++  ankh
          ++  sark
          ++  srow
          ++  subs
  ++  ex      
  ++  ix      
++  curt      
        ++  cla
        ++  sqr
        ++  inv
        ++  cad
        ++  cub
++  ed         
    ++  norm  
    ++  xrec  
    ++  ward  
    ++  scam  
    ++  etch  
    ++  curv  
    ++  deco  
    ++  bb
  ++  puck    
  ++  suck    
  ++  sign    
  ++  veri    

section 2eY, SHA-256 

++  shad  
++  shaf  
++  shak  
++  sham  
++  shas  
++  shax  
++  shaw  
++  og    
  ++  rad 
  ++  raw 
++  shaz  
++  shal  
++  shan  

section 2eZ, OLD rendering

++  show  
  ++  shep
  ++  shop
++  at
  ++  r
  ++  rf 
  ++  rn 
  ++  rt 
  ++  rta
  ++  rtam
  ++  rub 
  ++  rud 
  ++  rum
  ++  rup
  ++  ruv
  ++  rux 

chapter 2f, Hoon proper

section 2fA, miscellaneous funs       

++  bull
++  cain  
++  cell
++  core
++  cube
++  face
++  bean  
++  flay
++  flee
++  foil
++  fork
++  cove
++  comb
++  cond
++  cons
++  fitz
++  flan
++  flip
++  flor
++  hike
++  hoax
++  hoof
++  jock
++  look
++  make
++  noah  
++  onan  
++  rain
++  ream
++  reck
++  seed
++  seem  
++  seer  
++  sell
++  pave
++  loot
++  slam
++  slim
++  slit
++  slym
++  slap
++  slop
++  skol
++  spat  
++  spuc
++  spec
++  spud  
++  slot
++  slum
++  stab
++  wash

section 2fB, macro expansion          

++  ah
  ++  blue
  ++  gray
  ++  puce
++  al
  ++  blah
  ++  home
  ++  bunt
  ++  clam
  ++  cloq
  ++  whip
++  ap
  ++  etch
  ++  feck
  ++  hock
  ++  open
  ++  rake
  ++  rusk

section 2fC, compilation proper       

++  ut
  ++  burn
  ++  busk
  ++  conk
  ++  crop
    ++  dext
    ++  sint
  ++  cool
  ++  dank
  ++  dart
  ++  deal
  ++  dial
  ++  dish
  ++  doge
  ++  dole
  ++  duck
  ++  dune
  ++  dunk
  ++  fino
  ++  fink
  ++  finq
  ++  fire
  ++  firm
  ++  fish
  ++  fuse
  ++  gain
  ++  hang
  ++  harp
  ++  lose
  ++  chip
  ++  heal
  ++  mint
    ++  nice
    ++  grow
  ++  moot
  ++  mull
    ++  both
    ++  nice
    ++  grow
    ++  bake
  ++  meet  
  ++  nest
    ++  cong
    ++  cram
    ++  dext
    ++  sint
  ++  park
  ++  peek
  ++  play
  ++  reco
  ++  repo
  ++  rest
  ++  seek
  ++  seep
  ++  sift
  ++  snub
  ++  tack
  ++  tock
  ++  wrap

section 2fD, grammar                  

++  vang
++  vast
  ++  gash  
  ++  gasp  
  ++  glam  
  ++  hasp  
  ++  mota  
  ++  plex
  ++  pray
  ++  prey
  ++  phax
  ++  posh
  ++  poof
  ++  poon
  ++  poor
  ++  porc
  ++  rump
  ++  rood
  ++  rupl
  ++  sail 
    ++  ape
    ++  amp
    ++  bam
    ++  bat
    ++  bet
    ++  fry
    ++  hag
    ++  hig
    ++  hog
    ++  hoy
    ++  hul
    ++  jaw
    ++  lif
    ++  luf
    ++  nal
    ++  nol
    ++  nol
    ++  nup
    ++  pab
    ++  ped
    ++  pep
    ++  puv
    ++  rab
    ++  sag
  ++  scat
  ++  soil
  ++  sump 
  ++  noil
    ++  toad
    ++  rung
    ++  gunk
    ++  muck
    ++  butt
    ++  loaf
    ++  lobe
    ++  exqa
    ++  exqb
    ++  exqc
    ++  exqd
    ++  exqe
  ++  norm
    ++  boog
    ++  wisp
    ++  toad
    ++  rune
    ++  glop
    ++  gunk
    ++  butt
    ++  ulva
    ++  hank
    ++  loaf
    ++  lobe
    ++  mash
    ++  muck
    ++  teak
    ++  race
    ++  rack
    ++  rick
    ++  expa
    ++  expb
    ++  expc
    ++  expd
    ++  expe
    ++  expf
    ++  expg
    ++  exph
    ++  expi
    ++  expj
    ++  expk
    ++  expm
    ++  expn
    ++  expo
    ++  expp
    ++  expq
    ++  expr
    ++  exps
    ++  expt
    ++  expu
    ++  expv
    ++  expw
    ++  expx
    ++  expy
    ++  expz
    ++  hina
    ++  hinb
    ++  hinc
    ++  hind
    ++  hine
    ++  hinf
    ++  hing
    ++  bonk
    ++  bont
    ++  bony
    ++  bonz
  ++  lung
  ++  long
  ++  lobo
  ++  loon
  ++  lute
  ++  rope
  ++  tall
  ++  wide
  ++  hill
  ++  howl
  ++  toil
  ++  wart
++  vest
++  vice

volume 3, Arvo models and skeleton

++  arch  
++  bead  
++  care  
++  case  
++  desk  
++  cage  
++  chop  
++  curd  
++  disk  
++  duct  
++  gene  
++  glob  
++  herd  
++  hilt  
++  hypo  
++  khan  
++  lens    
      ++  v 
      ++  w 
      ++  x 
      ++  y 
      ++  z 
++  logo 
++  lode 
++  mark 
++  mill 
++  milt 
++  monk 
++  mold 
++  muse 
++  mosh 
++  move 
++  ovum 
++  pane 
++  pone 
++  ship 
++  sled 
++  slut 
++  vile 
++  wire 
++  slod 
++  slub 

section 3bE, Arvo core                

++  vent 
  ++  ruck   
  ++  wink   
    ++  doze
    ++  sike
    ++  souk
    ++  sunk
    ++  song
    ++  spuc
    ++  sump
    ++  said
    ++  scry
    ++  soar
    ++  swim
++  vint    
++  viol    
++  is      
  ++  beck
  ++  dink  
  ++  dint  
  ++  doos  
  ++  hurl  
  ++  race  
  ++  fire  
  ++  jack  
  ++  kick  

Postface

    ++  come
    ++  keep
    ++  load
    ++  peek
    ++  poke
    ++  wish
++  come    
++  keep    
++  load    
++  peek    
++  poke    
++  vega    
++  veer    
++  wish    
