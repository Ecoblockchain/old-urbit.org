Foreword
Nock

Hoon
Preface

volume 0, version stub
++  stub  

volume 1, Hoon models
++  abel  
++  axis  
++  also  
++  base  
++  beer  
++  beet  
++  bloq  
++  calf  
++  char  
++  chum  
++  claw  
++  coat  
++  coil  
++  coin  
++  cord  
++  date  
++  dime  
++  dram  
++  each  
++  edge  
++  foot  
++  gear  
++  hair  
++  hapt  
++  like  
++  limb  
++  line  
++  list  
++  mane  
++  mano  
++  manx  
++  marl  
++  mars  
++  mart  
++  marx  
++  metl  
++  null  
++  odor  
++  tarp  
++  time  
++  tree  
++  nail  
++  numb  
++  pair  
++  pass  
++  path  
++  pint  
++  port  
++  post  
++  prop  
++  qual  
++  rege  
++  ring  
++  rule  
++  span  
++  spot  
++  tank  
++  tape  
++  term  
++  tiki  
++  tile  
++  toga  
++  trel  
++  tuna  
++  twig  
++  tine  
++  tusk  
++  tyre  
++  tyke  
++  tram  
++  tone  

++  nock  
++  toon  
++  tune  
++  twin  
++  type  
++  typo  
++  udal  
++  udon  
++  umph  
++  unce  
++  unit  
++  upas  
++  urge  
++  vase  
++  vise  
++  wall  
++  wain  
++  wing  
++  wine  
++  woof  
++  wonk  
++  map  
++  qeu  
++  set  
++  jar  
++  jug  

volume 2, Hoon libraries and compiler

chapter 2a, basic unsigned math

++  add 
  Comment:
        add
  Description:
        Sums two numbers.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        It must yield an atom.
        Check if a is equal to 0.
        If it is, the arm produces b.
        Else, the arm is called again with a replaced by (dec a) and b by +(b).
  Examples:
        ~palryp-hocsyt/try=> (add 2 2)
        4
        ---
        ~palryp-hocsyt/try=> (add 1 1.000.000)
        1.000.001
        ---
        ~palryp-hocsyt/try=> (add 1.333 (mul 2 2))
        1.337
++  cap
  Comment:
        tree head
  Description:
        Yields whether an atom is in the head or tail of a noun.
  Explanation:
        This arm is jetted.
        It must yield either %2 or %3.
        Selects a case below for the actual type of a.
        Yield %2 if a is %2.
        %3 if it is %3.
        Fail if a is either %0 or %1.
        Else, call cap recursively with a replaced by a/2.
        The case statement is closed.
  Examples:
        ~palryp-hocsyt/try=> (cap 4)
        %2
        ---
        ~palryp-hocsyt/try=> (cap 6)
        %3
        ---
        ~palryp-hocsyt/try=> (cap (add 10 9))
        %2
++  dec  
  Comment:
        decrement
  Description:
        Decrements a number - Subtracts one.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        When the following code crashes, print "%decrement-underflow" in the stack trace.
        Produce the next gate asserting a is not 0.
        Let b be 0.
        Creates a dry %gold trap which yields an atom.
        Check if a is equal to the increment of b.
        If so, produce b.
        Else, recursively call dec by replacing the argument b with the increment of b.
  Examples:
        ~palryp-hocsyt/try=> (dec 7)
        6
        ---
        ~palryp-hocsyt/try=> (dec 0)
        ! decrement-underflow
        ! exit
++  div  
  Comment:
        divide
  Description:
        Divides one number by another.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which  accepts two atoms.
        It must yield an atom.
        When the following code crashes, print "div" in the stack trace.
        Produce the next trap asserting that b is not 0.
        Let c be 0.
        Create a dry %gold trap
        Build an if-then-else statement on whether a is less than b.
        If so, produce c.
        Else, recursively call with a replaced by the difference of a and b and c by 
        the increment of c.
  Examples:
        ~palryp-hocsyt/try=> (div 4 2)
        2
        ---
        ~palryp-hocsyt/try=> (div 17 8)
        2
        ---
        ~palryp-hocsyt/try=> (div 20 30)
        0 
++  fac  
  Comment:
        factorial
  Description:
        Produces the factorial of a number n, n!.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        It must yield an atom.
        Build an if-then-else statement on whether a is equal to 0.
        If so, produce 1.
        Else, multiply a by the recursive call of factorial with the decrement of a.
  Examples:
        ~palryp-hocsyt/try=> (fac 3)
        6
        ---
        ~palryp-hocsyt/try=> (fac 0)
        1
        ---
        ~palryp-hocsyt/try=> (fac 11)
        39.916.800
++  gte
  Comment:
        greater than or equal
  Description:
        Produces the loobean a>=b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Yield false if a is less than b, true else.
  Examples:
        ~palryp-hocsyt/try=> (gte 100 10)
        %.y
        ---
        ~palryp-hocsyt/try=> (gte 4 4)
        %.y
        ---
        ~palryp-hocsyt/try=> (gte 3 4)
        %.n
++  gth
  Comment:
        greater than
  Description:
        Produces the loobean a>b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Yield false if a is less than or equal to b, true else.
  Examples:
        ~ronrem-lonsem/try=> (gth 4 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (gth 5 4)
        %.y
        ---
        ~ronrem-lonsem/try=> (gth 5 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (gth 0 0)
        %.n
++  lte  
  Comment:
        less than or equal to
  Description:
        Produces the loobean a<=b.
  Explanation:
        This is a jetted arm.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Use logical OR to yield true if either a=b or (lth a b) is true.
  Examples:
        ~ronrem-lonsem/try=> (lte 4 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lte 5 4)
        %.n
        ---
        ~ronrem-lonsem/try=> (lte 5 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lte 0 0)
        %.y
++  lth  
  Comment:
        less than
  Description:
        Produces the loobean a<b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Use logical AND, thus immediately producing false if a=b.
        Then, create and kick a dry %gold trap which produces true on a=0,
        or false if a!=0 and b=0.
        If none of these cases are met, recursively call lth with both a and b decremented.
  Examples:
        ~ronrem-lonsem/try=> (lth 4 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lth 5 4)
        %.n
        ---
        ~ronrem-lonsem/try=> (lth 5 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (lth 5 0)
        %.n
++  mas  
  Comment:
        tree body
  Description:
       Produces the axis of a within the head or the tail. 
  Explanation:
        This arm is jetted.
        Creates a dry gold gate with a sample which accepts an atom.
        Must produce an atom.
        Selects a case below for the actual type of a.
        Exit if a is 1.
        Produce 1 if a is either 2 or 3.
        Else, sum the modulus of a and 2 with the 2 multiplied by the recursive call of 
        mas with a replaced by a/2.
  Examples:
        1 ~ronrem-lonsem/try=> (mas 3)
        1
        ---
        ~ronrem-lonsem/try=> (mas 4)
        2
        ---
        ~ronrem-lonsem/try=> (mas 5)
        3
        ---
        ~ronrem-lonsem/try=> (mas 6)
        2
        ---
        ~ronrem-lonsem/try=> (mas 7)
        3
        ---
        ~ronrem-lonsem/try=> (mas 8)
        4
        ---
        ~ronrem-lonsem/try=> (mas 0)
        ! exit
        ---
        ~ronrem-lonsem/try=> (mas 1)
        ! exit
++  max  
  Comment:
        maximum
  Description:
        Yields the larger of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Build an if-else-then statement on a>b.
        If so, produce a.
        Else, produce b.
  Examples:
        ~palryp-hocsyt/try=> (max 10 100)
        100
        ---
        ~palryp-hocsyt/try=> (max 10.443 9)
        10.443
        ---
        ~palryp-hocsyt/try=> (max 0 1)
        1
++  min  
  Comment:
        minimum
  Description:
        Yields the smaller of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Build an if-then-else statement on a<b.
        If so, produce a.
        Else, produce b.
  Examples:
        ~palryp-hocsyt/try=> (min 10 100)
        10
        ---
        ~palryp-hocsyt/try=> (min 10.443 9)
        9
        ---
        ~palryp-hocsyt/try=> (min 0 1)
        0
++  mod  
  Comment:
        remainder
  Description:
        Yields the modulus of (a mod b).
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Assert that b is not 0 before producing the below.
        Produce the difference of a and the product of b times a/b.
  Examples:
++  mul  
  Comment:
        multiply
  Description:
        Multiplies two numbers.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Let c be 0.
        Create and kick a dry %gold trap.
        Build an if-then-else statement on a=0.
        If so, produce c.
        Else, recursively call multiply with a replaced by decremented a and c replaced by b+c.
  Examples:
++  peg  
  Comment:
        tree connect
  Description:
        Produces the axis of b within the axis of a.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Select a case below for the actual type of b.
        Yield a on b=1.
        Yield (mul a 2) on b=2.
        Yield the increment of (mul a 2) on b=3.
        Else, sum (b mod 2) with the product of 2 and the recursive call to peg with b replaced by b/2.
  Examples:
        ~ronrem-lonsem/try=> (mul 5 3)
        15
        ---
        ~ronrem-lonsem/try=> (mul 1 0)
        0
++  sub  
  Comment:
        subtract
  Description:
        Accepts two atoms, a and b, and produces a-b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        When the following code crashes, print "%subtract-underflow" in the stack trace.
        Must produce an atom.
        Build an if-then-else statement on b=0.
        If so, produce a.
        Else, produce the recursive call of subtract with a and b replaced by their respective decrements.
  Examples:
        ~ronrem-lonsem/try=> (sub 10 5)
        5
        ---
        ~ronrem-lonsem/try=> (sub 243 44)
        199
        ---
        ~ronrem-lonsem/try=> (sub 5 0)
        5
        ---
        ~ronrem-lonsem/try=> (sub 0 5)
        ! subtract-underflow
        ! exit

chapter 2b, basic containers

Section 2bA, units                    

++  biff 
  Comments:
        apply
  Description:
        Accepts a unit 'a' and a gate 'b' which produces a unit from the type of u.a, slamming the gate 
        with the value of a when a isn't null and producing ~ when it is.
  Explanation:
        Creates a vulanixed wet gate with a sample which accepts a unit and a $+(* (unit)) tiled gate.
        Build an if-then-else statement "a is null."
        If so, produce null.
        Else, produce b slammed with u.a.
  Examples:
        ~palryp-hocsyt/try=> (biff (some 5) |=(a=@ (some (add a 2))))
        [~ u=7]
        ---
        ~palryp-hocsyt/try=> (biff ~ |=(a=@ (some (add a 2))))
        ~
++  bind 
  Comments:
        argue
  Description:
        Accepts a unit 'a' and a gate 'b', producing a unit with value (b u.a) or, when a is null, null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit and a gate.
        Build an if-then-else statement on "a is null."
        If so, produce null.
        Else, produce the a unit with value (b u.a), gate 'b' slammed with u.a.
  Examples:
        ~talsur-todres/try=> (bind ((unit ,@) [~ 97]) ,@t)
        [~ `a`]
        ---
        ~talsur-todres/try=> =a |=(a=@ (add a 1))
        ~talsur-todres/try=> (bind ((unit ,@) [~ 2]) a)
        [~ 3]
++  clap 
  Comments:
        combine
  Description:
        Applies a binary operation to the values of two units, producing the product as a unit.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts two units and a gate.
        Build an if-then-else statment on "a is null."
        If so, produce b.
        Else, build an if-then-else statement on "b is null."
        If so, produce a.
        Else, produce the unit with value (c u.a u.b)
  Examples:
        ~palryp-hocsyt/try=> =u ((unit ,@t) [~ 'a'])
        ~palryp-hocsyt/try=> =v ((unit ,@t) [~ 'b'])
        ~palryp-hocsyt/try=> (clap u v |=([a=@t b=@t] (welp (trip a) (trip b))))
        [~ u="ab"]
        ---
        ~talsur-todres/try=> =a ((unit ,@u) [~ 1])
        ~talsur-todres/try=> =b ((unit ,@u) [~ 2])
        ~talsur-todres/try=> =c |=([a=@ b=@] (add a b))
        ~talsur-todres/try=> (clap a b c)
        [~ 3]
++  drop 
  Comments:
        enlist
  Description:
        Accepts a unit and produces the list [u.a ~] or null when the unit is null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit.
        Builds an if-then-else statement on "a is null."
        If so, produces null.
        Else, produce the list [u.a ~].
  Examples:
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> (drop a)
        [i=97 t=~]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~])
        ~divreg-misdef/try=> (drop a)
        ~
++  fall 
  Comments:
        default
  Description:
         a default value 'b' for the unit 'a' when it is null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit and any noun.
        Produces b if a is null and u.a if it is not.
  Examples:
        ~talsur-todres/try=> (fall ~ `a`)
        `a`
        ---
        ~talsur-todres/try=> (fall [~ u=0] `a`)
        0
++  mate 
  Comments:
        choose
  Description:
        Produces the unit 'a' or 'b' which is not null and crashes with error "mate" if they are equal.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a two units.
        Build an if-then-else statement on "b is null."
        If so, produce a.
        Else, build an if-then-else statement on "a is null."
        If so, produce b.
        Else, build an if-else-then statement on  u.a=u.b.  Crash on "mate" if false, produce a if true.
  Examples:
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~ 97])
        ~divreg-misdef/try=> (mate a b)
        [~ 97]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~])
        ~divreg-misdef/try=> (mate a b)
        [~ 97]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~ 98])
        ~divreg-misdef/try=> (mate a b)
        ! 'mate'
        ! exit
++  need 
  Comments:
        demand
  Description:
        Retrieves the value from a unit, crashing if the unit is null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit.
        Build an if-then-else statement on "Is a an atom?"
        If so, crash.
        Else, produce u.a from the unit a.
  Examples:
        ~divreg-misdef/try=> =a ((unit ,[@t @t]) [~ [`a` ' b']])
        ~divreg-misdef/try=> (need a)
        [`a` ' b']
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~])
        ~divreg-misdef/try=> (need a)
        ! exit
++  some 
  Comments:
        lift
  Description:
        Casts any noun a to its unit, [~ a].
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts any noun.
        Produces the tuple [~ u=a], the unit of value a.
  Examples:
        ~divreg-misdef/try=> (some [`a` `b`])
        [~ u=[`a` `b`]]
        ---
        ~divreg-misdef/try=> (some &)
        [~ u=%.y]

Section 2bB, lists                    

++  flop 
  Comments:
        reverse
  Description:
        Produces the list 'a' with the elements reversed.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a single list.
        'a' is then replaced with (homo a) and used as the subject for the code below (=>).
        The type of the result must be the same as a, our argument list.
        Let b be a list of the type of the icon of a, as it is bunted.
        Create and kick a dry %gold trap
        Build an if-then-else statement on "Is a an atom?"
        If so, produce b.
        Else, recursively call flop with a replaced by it's tail and b replaced by [i.a b], where
        i.a is the head of a.
  Examples:
        ~palryp-hocsyt/try=> =lyst (limo [1 2 3 4 ~])
        ~palryp-hocsyt/try=> lyst
        [i=1 t=[i=2 t=[i=3 t=[i=4 t=~]]]]
        ~palryp-hocsyt/try=> (flop lyst)
        ~[4 3 2 1]
        ---
        ~palryp-hocsyt/try=> (flop (limo [1 'a' 2 'b' (some 10) ~]))
        ~[[~ u=10] 98 2 97 1]
++  homo 
  Comments:
        homogenize
  Description:
        Homogenizes a lists' type information.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a single list.
        Makes the type of the result the type of the product of the code below (^+).
        The subject of the arm ($) is then the product of the barcen statement below (=<).
        Creates a %gold core (|%) and the arm '+-  $'.
        XXX BLACK BOX, ABANDON ALL HOPE YE WHO ENTER HERE XXX
        Terminates the core.
        Produces list a.
  Examples:
        ~palryp-hocsyt/try=> lyst
        [i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]
        ~palryp-hocsyt/try=> (homo lyst)
        ~[1 97 2 98 [~ u=10]]
        ---
        ~palryp-hocsyt/try=> =a (limo [1 2 3 ~])
        ~palryp-hocsyt/try=> a
        [i=1 t=[i=2 t=[i=3 t=~]]]
        ~palryp-hocsyt/try=> (homo a)
        ~[1 2 3]
++  limo 
  Comments:
        listify
  Description:
        Produces a list from any null-terminated tuple.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a single list.
        Makes the type of the result the type of the product of the code below (^+).
        The subject of the arm ($) is then the product of the barcen statement below (=<).
        Creates a %gold core (|%) and the arm '+-  $'.
        XXX BLACK BOX, ABANDON ALL HOPE YE WHO ENTER HERE XXX
        Terminates the core.
        Produces list a.
  Examples:
        ~palryp-hocsyt/try=> (limo [1 'a' 2 'b' (some 10) ~])
        [i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]
        ---
        ~palryp-hocsyt/try=> (limo [`a` `b` ~])
        [i=`a` t=[i=`b` t=~]]
        ---
        ~palryp-hocsyt/try=> (limo [2 1 ~])
        [i=2 t=[i=1 t=~]]
++  lent 
  Comments:
        length
  Description:
        Produces the atomic length of any list.
  Explanation:
        This is a jetted arm.
        Creates a dry %gold gate with a sample which accpets a single list.
        Must produce an atom.
        Let b be 0.
        Creates and kicks a dry %gold trap.
        Builds an if-then-else statement on "Is a an atom?"  If so, produces b.
        Else, recursively calls length with the list set to the tail of a and the accumulator, b, incremented.
  Examples:
        ~palryp-hocsyt/try=> (lent (limo [1 2 3 4 ~]))
        4
        ---
        ~palryp-hocsyt/try=> (lent (limo [1 'a' 2 'b' (some 10) ~]))
        5
++  levy
  Comments:
       all of
  Description:
        Applies the loobean gate 'b' to every element of the list 'a', producing the logical AND of all the results.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate with a sample of any noun
        and produces a loobean.
        Then, a dry %gold trap is created and kicked.  It must produce a loobean.
        Build an if-then-else statement on "a is an atom."
        If so, produce true.
        Else, build an if-then-else statement on (b i.a)
        If so, then recursively call levy with a replaced by the tail of a.
        Else, produce no.
  Examples:
        ~palryp-hocsyt/try=> =b |=(a=@ (gte a 1))
        ~palryp-hocsyt/try=> (levy (limo [0 1 2 1 ~]) b)
        %.n
        ---
        ~palryp-hocsyt/try=> =b |=(a=@ (gte a 0))
        ~palryp-hocsyt/try=> (levy (limo [0 1 2 1 ~]) b)
        %.y        
++  lien 
  Comments:
        some of
  Description:
        Applies the loobean gate 'b' to every element of the list 'a', producing the logical OR of all the results.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate with a sample of any nouno
        and produces a loobean.
        Then, a dry %gold trap is created and kicked.  It must produce a loobean.
        Build an if-then-else gate on "a is null."  If so, produce false.
        Else, build an if-then-else gate on (b i.a).  If so, produce true.
        Else, recursively call lien with a replaced by the tail of a (t.a).
  Examples:
        ~palryp-hocsyt/try=> =a |=(a=@ (gte a 1))
        ~palryp-hocsyt/try=> (lien (limo [0 1 2 1 ~]) a)
        %.y
        ---
        ~palryp-hocsyt/try=> =a |=(a=@ (gte a 3))
        ~palryp-hocsyt/try=> (lien (limo [0 1 2 1 ~]) a)
        %.n
++  reel 
  Comments:
        right fold
  Description:
        Accepts a list 'a' and a gate 'b' which accepts two nouns, then folds (recursively calls 'b' across) the 
        list right to left, producing a value of the list element's type.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a trap which accepts two nouns.
        A dry %gold trap is created and kicked.  It must produce the type of the list's elements.
        Build a if-then-else statement on "Is a a noun?"
        If so, produce q.b.
        Else, recursivley call b with the head of a and the rest of a replaced by the tail of a.
  Examples:     
        ~palryp-hocsyt/try=> =sum =|([p=@ q=@] |.((add p q)))
        ~palryp-hocsyt/try=> (reel (limo [1 2 3 4 5 ~]) sum)
        15
        ---
        ~palryp-hocsyt/try=> =a =|([p=@ q=@] |.((sub p q)))
        ~palryp-hocsyt/try=> (reel (limo [6 3 1 ~]) a)
        4
        ---
        ~palryp-hocsyt/try=> (reel (limo [3 6 1 ~]) a)
        ! subtract-underflow
        ! exit
++  roll 
  Comments:
        left fold
  Description:
        Accepts a list 'a' and a gate 'b' which accepts two nouns, then folds (recursively calls 'b' across) the
        list left to right, producing a value of the list of the element's type.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a trap which accepts two nouns.
        A dry %gold trap is then created and kicked.  It must produce the type of the list's elements.
        Build an if-then-else statement on "Is a an atom?"
        If so, produce q.b.
        Else, recursively call roll with a replaced by the tail of a and b by the recursive call of b
        with q replaced by (b i.a q.b).
  Examples:
        ~barred-tidset/try=> =a =|([p=@ q=@] |.((sub p q)))
        ~barred-tidset/try=> (roll (limo [1 2 3 ~]) a)
        2
        ~barred-tidset/try=> (roll (limo [3 6 3 ~]) a)
        0
++  skid 
  Comments:
       separate
  Description:
        Accepts a list and a gate which takes any noun and produces a loobean.  Produces two lists, one who's elements
        produce true and one who's produce false.
  Explanation:
        
  Examples:
++  skim 
  Comments:
        only
  Description:
  Explanation:
  Examples:
++  skip 
  Comments:
        except
  Description:
  Explanation:
  Examples:
++  scag 
  Comments:
        prefix
  Description:
  Explanation:
  Examples:
++  slag 
  Comments:
        suffix
  Description:
  Explanation:
  Examples:
++  snag 
  Comments:
        index
  Description:
  Explanation:
  Examples:
++  sort 
  Comments:
        quicksort
  Description:
  Explanation:
  Examples:
++  swag 
  Comments:
        infix
  Description:
  Explanation:
  Examples:
++  turn 
  Comments:
        transform
  Description:
  Explanation:
  Examples:
++  weld 
  Comments:
        concatenate
  Description:
  Explanation:
  Examples:
++  welp 
  Comments:
        perfect weld
  Description:
  Explanation:
  Examples:
++  wild 
  Comments:
        concatenate
  Description:
  Explanation:
  Examples:
++  zing 
  Comments:
        promote
  Description:
  Explanation:
  Examples:

chapter 2c, simple noun surgery

section 2cA, bit surgery              **capitalization of "section" inconsistent in source**

++  bex  
++  xeb  
++  can  
++  cat  
++  cut  
++  end  
++  fil  
++  lsh  
++  met  
++  rap  
++  rep  
++  rip  
++  rsh  
++  swap 

section 2cB, bit logic                

++  con  
++  dis  
++  mix  
++  not  

section 2cC, noun orders              

++  aor  
++  dor  
++  gor  
++  hor  
++  vor

section 2cD, insecure hashing         

++  fnv
++  mug

section 2cE, phonetic base            

++  po
  ++  ind 
  ++  ins 
  ++  tod 
  ++  tos 

section 2cF, signed and modular ints  

++  si    
  ++  abs 
  ++  dif 
  ++  dul 
  ++  fra 
  ++  new 
  ++  old 
  ++  pro 
  ++  rem 
  ++  sum 
  ++  sun 
  ++  syn 
++  fe    
  ++  dif 
  ++  inv 
  ++  net 
  ++  out 
  ++  rol 
  ++  ror 
  ++  sum 
  ++  sit 

section 2cG, floating point           

++  rlyd  
++  rlyh  
++  rlyq  
++  rlys  
++  ryld  
++  rylh  
++  rylq  
++  ryls  

section 2cH, urbit time               

++  year  
++  yore  
++  yell  
++  yule  
++  yall  
++  yawn  
++  yelp  
++  yo    
      ++  day 
      ++  era 
      ++  hor 
      ++  jes 
      ++  mit 
      ++  moh 
      ++  moy 
      ++  qad 
      ++  yer 

section 2cI, almost macros            
++  hard
++  soft

chapter 2d, containers

section 2dA, sets     
                
++  apt       
++  in        
  +-  all
  +-  any
  +-  del
  +-  dig
  +-  gas
  +-  has
  +-  put
  +-  rep
  +-  tap
  +-  wyt

section 2dB, maps                     

++  ept       
++  ja        
  +-  get
  +-  add
++  ju        
  +-  get
  +-  has
  +-  put
++  by        
  +-  all
  +-  any
  +-  del
  +-  dig
  +-  gas
  +-  get
  +-  has
  +-  mar
  +-  put
  +-  rep
  +-  rib
  +-  run
  +-  tap
  +-  uni
  +-  wyt

section 2dC, queues                   

++  to        
  +-  bal
  +-  dep
  +-  gas
  +-  get
  +-  nap
  +-  put
  +-  tap
  +-  top

section 2dD, casual containers        

++  mo        
++  sa        
++  qu        

chapter 2e, miscellaneous libs

section 2eA, packing          
        
++  cue       
++  jam       
++  mat       
++  rub       

section 2eB, parsing (tracing)        

++  last  
++  lust  

section 2eC, parsing (custom rules)   

++  cold  
++  cook  
++  easy  
++  fail  
++  full  
++  funk  
++  here  
++  jest  
++  just  
++  knee  
++  mask  
++  next  
++  sear  
++  shim  
++  stag  
++  stet
++  stew
++  stir
++  stun  

section 2eD, parsing (combinators)    

++  bend  
++  comp
++  glue  
++  pfix  
++  plug  
++  pose  
++  sfix  

section 2eE, parsing (composers)      

++  bass
++  boss
++  ifix
++  more
++  most
++  plus  
++  slug
++  star

section 2eF, parsing (ascii)          

++  ace 
++  bar 
++  bas 
++  buc 
++  cab 
++  cen 
++  col 
++  com 
++  doq 
++  dot 
++  fas 
++  gal 
++  gar 
++  hax 
++  kel 
++  ker 
++  ket 
++  lus 
++  hep 
++  pel 
++  pam 
++  per 
++  pat 
++  sel 
++  sem 
++  ser 
++  sig 
++  soq 
++  tar 
++  tec 
++  tis 
++  wut 
++  zap 

section 2eG, parsing (whitespace)     

++  dog 
++  doh 
++  dun 
++  duz 
++  gah 
++  gap 
++  gaq 
++  gay 
++  vul 

section 2eH, parsing (idioms)         

++  alf 
++  aln 
++  alp 
++  bet 
++  bin 
++  but 
++  cit 
++  dem 
++  dit 
++  gul 
++  gon 
++  hex 
++  hig 
++  hit 
++  low 
++  mes 
++  nix 
++  nud 
++  poy 
++  qit 
++  qut 
++  sym
++  ven 
++  vit 

section 2eI, parsing (external)       

++  rash
++  rush
++  rust
++  scan

section 2eJ, formatting (basic text)  

++  cass
++  cuss
++  crip
++  mesc
++  runt
++  sand
++  sane
++  trim
++  trip
++  teff
++  turf
++  tuba
++  tufa
++  tuft
++  wack
++  wick
++  woad
++  wood

section 2eK, formatting (layout)      

++  re
  ++  ram
  ++  win
    ++  din 
    ++  fit 
    ++  rig
    ++  wig

section 2eL, formatting (path)        

++  ab
  ++  bix  
  ++  hif  
  ++  huf  
  ++  hyf  
  ++  pev  
  ++  pew  
  ++  piv  
  ++  piw  
  ++  qeb  
  ++  qex  
  ++  qib  
  ++  qix  
  ++  seb  
  ++  sed  
  ++  sev  
  ++  sew  
  ++  sex  
  ++  sib  
  ++  siq  
  ++  sid  
  ++  siv  
  ++  siw  
  ++  six  
  ++  sov  
  ++  sow  
  ++  sox  
  ++  ted  
  ++  tip  
  ++  tiq  
  ++  tid  
  ++  til  
  ++  urs  
  ++  urt  
  ++  voy  
  ++  vym  
  ++  vyn  
++  ag
  ++  ape  
  ++  bay  
  ++  bip  
  ++  dem  
  ++  dim  
  ++  dum  
  ++  fed  
  ++  hex  
  ++  lip  
  ++  qut  
  ++  sym  
  ++  tyq  
  ++  viz  
  ++  vum  
  ++  wiz  
++  co
      ++  rear
      ++  rent
      ++  rend
      ++  a-co
      ++  d-co
      ++  r-co
      ++  s-co
      ++  v-co
      ++  w-co
      ++  x-co
      ++  y-co
      ++  z-co
  ++  em-co
  ++  ox-co
  ++  ro-co
++  ne
  ++  d  
  ++  x  
  ++  v  
  ++  w  
++  mu
  ++  zag
  ++  zig
  ++  zug
++  so
  ++  bisk
  ++  crub
  ++  nuck
  ++  nusk
  ++  perd
  ++  royl
  ++  tash
  ++  twid
  ++  zust
++  scot 
++  scow 
++  slav  
++  slaw
++  slay
++  smyt

section 2eM, regular-expressions      

++  pars
++  nor
++  les  
++  lep  
++  alm  
++  alb  
++  mis  
++  anns 
++  mall
++  bets
++  ranc
++  flap 
++  rang
++  chun
++  seac
++  sead
++  sade
++  seap
++  cape
++  lower
++  upper
++  digit
++  print
++  graph
++  blank
++  space
++  cntrl
++  alpha
++  alnum
++  punct
++  wordc
++  white
++  xdigi
++  chad
++  escd
++  escp
++  unid
++  proc 
++  cont
++  abor
++  matc
++  chet
++  blak 
++  deep
++  rexp 
++  repg 

section 2eN, pseudo-cryptography      

++  un   
  ++  wre
  ++  wre
  ++  xaf
  ++  xar
  ++  zaf
  ++  zar
  ++  zyf
  ++  zyr

section 2eO, virtualization           

++  mack
++  mink
++  mock
++  mook
++  mang
++  mong
++  mung
++  mule 
++  mute 

section 2eP, diff          **noted as "(move me)" in source**

++  berk 
++  diff 
++  loss 
  ++  abet
  ++  hink
  ++  lonk
  ++  lune
  ++  merg
  ++  main
++  locz  
++  lore  
++  role  
++  lump  
++  lure  
++  limp  
++  hump  
++  husk  
++  lurk  
++  lusk  
  ++  abet
  ++  done
  ++  main
++  nude   
  ++  axes 
  ++  tred 

section 2eW, lite number theory           

++  egcd   
++  pram   
++  ramp   
++  fo     
  ++  dif
  ++  exp
  ++  fra
  ++  inv
  ++  pro
  ++  sit
  ++  sum
++  ga     
      ++  dif 
      ++  dub 
      ++  pro 
      ++  toe 
      ++  sit 
  ++  fra     
  ++  inv     
  ++  pow     
  ++  pro     

section 2eX, jetted crypto                

++  aesc      
  ++  en      
  ++  de      
++  ahem      
        ++  cipa 
          ++  co 
          ++  ix 
          ++  ro 
          ++  su 
    ++  pen      
      ++  co  
      ++  ix  
      ++  ro  
      ++  su  
    ++  pin   
      ++  co  
      ++  ix  
      ++  ro  
      ++  su  
    ++  mcol
    ++  pode  
    ++  sube  
  ++  be      
          ++  ankh
          ++  sark
          ++  srow
          ++  subs
  ++  ex      
  ++  ix      
++  curt      
        ++  cla
        ++  sqr
        ++  inv
        ++  cad
        ++  cub
++  ed         
    ++  norm  
    ++  xrec  
    ++  ward  
    ++  scam  
    ++  etch  
    ++  curv  
    ++  deco  
    ++  bb
  ++  puck    
  ++  suck    
  ++  sign    
  ++  veri    

section 2eY, SHA-256 

++  shad  
++  shaf  
++  shak  
++  sham  
++  shas  
++  shax  
++  shaw  
++  og    
  ++  rad 
  ++  raw 
++  shaz  
++  shal  
++  shan  

section 2eZ, OLD rendering

++  show  
  ++  shep
  ++  shop
++  at
  ++  r
  ++  rf 
  ++  rn 
  ++  rt 
  ++  rta
  ++  rtam
  ++  rub 
  ++  rud 
  ++  rum
  ++  rup
  ++  ruv
  ++  rux 

chapter 2f, Hoon proper

section 2fA, miscellaneous funs       

++  bull
++  cain  
++  cell
++  core
++  cube
++  face
++  bean  
++  flay
++  flee
++  foil
++  fork
++  cove
++  comb
++  cond
++  cons
++  fitz
++  flan
++  flip
++  flor
++  hike
++  hoax
++  hoof
++  jock
++  look
++  make
++  noah  
++  onan  
++  rain
++  ream
++  reck
++  seed
++  seem  
++  seer  
++  sell
++  pave
++  loot
++  slam
++  slim
++  slit
++  slym
++  slap
++  slop
++  skol
++  spat  
++  spuc
++  spec
++  spud  
++  slot
++  slum
++  stab
++  wash

section 2fB, macro expansion          

++  ah
  ++  blue
  ++  gray
  ++  puce
++  al
  ++  blah
  ++  home
  ++  bunt
  ++  clam
  ++  cloq
  ++  whip
++  ap
  ++  etch
  ++  feck
  ++  hock
  ++  open
  ++  rake
  ++  rusk

section 2fC, compilation proper       

++  ut
  ++  burn
  ++  busk
  ++  conk
  ++  crop
    ++  dext
    ++  sint
  ++  cool
  ++  dank
  ++  dart
  ++  deal
  ++  dial
  ++  dish
  ++  doge
  ++  dole
  ++  duck
  ++  dune
  ++  dunk
  ++  fino
  ++  fink
  ++  finq
  ++  fire
  ++  firm
  ++  fish
  ++  fuse
  ++  gain
  ++  hang
  ++  harp
  ++  lose
  ++  chip
  ++  heal
  ++  mint
    ++  nice
    ++  grow
  ++  moot
  ++  mull
    ++  both
    ++  nice
    ++  grow
    ++  bake
  ++  meet  
  ++  nest
    ++  cong
    ++  cram
    ++  dext
    ++  sint
  ++  park
  ++  peek
  ++  play
  ++  reco
  ++  repo
  ++  rest
  ++  seek
  ++  seep
  ++  sift
  ++  snub
  ++  tack
  ++  tock
  ++  wrap

section 2fD, grammar                  

++  vang
++  vast
  ++  gash  
  ++  gasp  
  ++  glam  
  ++  hasp  
  ++  mota  
  ++  plex
  ++  pray
  ++  prey
  ++  phax
  ++  posh
  ++  poof
  ++  poon
  ++  poor
  ++  porc
  ++  rump
  ++  rood
  ++  rupl
  ++  sail 
    ++  ape
    ++  amp
    ++  bam
    ++  bat
    ++  bet
    ++  fry
    ++  hag
    ++  hig
    ++  hog
    ++  hoy
    ++  hul
    ++  jaw
    ++  lif
    ++  luf
    ++  nal
    ++  nol
    ++  nol
    ++  nup
    ++  pab
    ++  ped
    ++  pep
    ++  puv
    ++  rab
    ++  sag
  ++  scat
  ++  soil
  ++  sump 
  ++  noil
    ++  toad
    ++  rung
    ++  gunk
    ++  muck
    ++  butt
    ++  loaf
    ++  lobe
    ++  exqa
    ++  exqb
    ++  exqc
    ++  exqd
    ++  exqe
  ++  norm
    ++  boog
    ++  wisp
    ++  toad
    ++  rune
    ++  glop
    ++  gunk
    ++  butt
    ++  ulva
    ++  hank
    ++  loaf
    ++  lobe
    ++  mash
    ++  muck
    ++  teak
    ++  race
    ++  rack
    ++  rick
    ++  expa
    ++  expb
    ++  expc
    ++  expd
    ++  expe
    ++  expf
    ++  expg
    ++  exph
    ++  expi
    ++  expj
    ++  expk
    ++  expm
    ++  expn
    ++  expo
    ++  expp
    ++  expq
    ++  expr
    ++  exps
    ++  expt
    ++  expu
    ++  expv
    ++  expw
    ++  expx
    ++  expy
    ++  expz
    ++  hina
    ++  hinb
    ++  hinc
    ++  hind
    ++  hine
    ++  hinf
    ++  hing
    ++  bonk
    ++  bont
    ++  bony
    ++  bonz
  ++  lung
  ++  long
  ++  lobo
  ++  loon
  ++  lute
  ++  rope
  ++  tall
  ++  wide
  ++  hill
  ++  howl
  ++  toil
  ++  wart
++  vest
++  vice

volume 3, Arvo models and skeleton

++  arch  
++  bead  
++  care  
++  case  
++  desk  
++  cage  
++  chop  
++  curd  
++  disk  
++  duct  
++  gene  
++  glob  
++  herd  
++  hilt  
++  hypo  
++  khan  
++  lens    
      ++  v 
      ++  w 
      ++  x 
      ++  y 
      ++  z 
++  logo 
++  lode 
++  mark 
++  mill 
++  milt 
++  monk 
++  mold 
++  muse 
++  mosh 
++  move 
++  ovum 
++  pane 
++  pone 
++  ship 
++  sled 
++  slut 
++  vile 
++  wire 
++  slod 
++  slub 

section 3bE, Arvo core                

++  vent 
  ++  ruck   
  ++  wink   
    ++  doze
    ++  sike
    ++  souk
    ++  sunk
    ++  song
    ++  spuc
    ++  sump
    ++  said
    ++  scry
    ++  soar
    ++  swim
++  vint    
++  viol    
++  is      
  ++  beck
  ++  dink  
  ++  dint  
  ++  doos  
  ++  hurl  
  ++  race  
  ++  fire  
  ++  jack  
  ++  kick  

Postface

    ++  come
    ++  keep
    ++  load
    ++  peek
    ++  poke
    ++  wish
++  come    
++  keep    
++  load    
++  peek    
++  poke    
++  vega    
++  veer    
++  wish    
