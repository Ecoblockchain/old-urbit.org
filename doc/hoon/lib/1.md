---
layout: subpage
title: 1 Models
arms: [++axis, ++bloq, ++numb, ++pass, ++ring, ++oder, ++char, ++cord, ++span, ++term, ++tape, ++date, ++tarp, ++time, ++pint, ++dime, ++coin, ++hapt, ++hair, ++nail, ++path, ++wall, ++rule, ++spot, ++abel, ++also, ++base, ++beer, ++calf, ++chum, ++claw, ++coat, ++coil, ++dram, ++each, ++edge, ++foot, ++gear, ++like, ++limb, ++line, ++list, ++metl, ++tree, ++port, ++post, ++prop, ++reef, ++shoe, ++tank, ++tiki, ++tile, ++toga, ++twig, ++tine, ++tusk, ++tyre, ++tuke, ++tram, ++tone, ++nock, ++toon, ++tune, ++twin, ++type, ++typo, ++udal, ++udon, ++ulna, ++umph, ++unce, ++unit, ++upas, ++urge, ++vase, ++vise, ++wing, ++wine, ++woof, ++wonk, ++map, ++qeu, ++set]
axis: doc-hoon
categories: lib
sort: 1
---

#Atom models

##++axis

####Tree address

###Examples

###Summary
	++  axis  ,@                                            ::  tree address


##++bloq

####Bit size
A bare atom most often used in bit manipulation functions for setting the size of block of bits to operate on. `++bloq` should always be read as a  binary power. For example, a `++bloq` of `0` means single bits, whereas a `++bloq` of `3` means bytes. 

###Examples

###Summary
	++  bloq  ,@                                            ::  blockclass


##++numb

####Just a number
For commenting programmer intent.

###Examples

###Summary
	++  numb  ,@                                            ::  just a number


##++pass

####Public key
Used by crypto in `zuse`.

###Examples

###Summary
	++  pass  ,@                                            ::  public key


##++ring

####Private key
Used by crypto in `zuse`.

###Examples

###Summary
	++  ring  ,@                                            ::  private key


##++odor

####Atom format
`,@ta`, which itself contains the odor `@ta`, means that an odor produces an atom of ascii text, such as 'ta', which is 24.948.

###Examples

###Summary
	++  odor  ,@ta                                          ::  atom format


#String-like models

##++char

####UTF-8 byte
A UTF-8 text atom a single byte in length; a single character.

###Examples

###Summary
	++  char  ,@tD                                          ::  UTF-8 byte


##++cord

####Text atom
An atom of text, or a stream of UTF-8 bits mapped to an atom. 'foo' is a cord.

###Examples
	~tomsyt-balsen/try=> `@`'foo'
	7.303.014
	~tomsyt-balsen/try=> `@ub`'foo'
	0b110.1111.0110.1111.0110.0110

###Summary
	++  cord  ,@t                                           ::  text atom (UTF-8)


##++span

####Text atom
An ASCII text atom. The prefix is `~.`. There are no escape sequences except `~~`, which means `~`, and `~-`, which means `_`. `-` and `.` encode themselves. No other characters besides numbers and lowercase letters are permitted.
~.foo is a span

###Examples

###Summary
	++  span  ,@ta                                          ::  text atom (ASCII)


##++term

####ASCII subset
A subset of ASCII text. The only characters permitted are lowercase ASCII,  `-` except as the first or last character, and 0-9 except as the first character. 

###Examples

###Summary
	++  term  ,@tas                                         ::  Hoon's ASCII subset


##++tape

####List of characters
A list of chars. This is roughly equivalent to what in many other languages is called a "string". Hoon, however, has two different models that fill the same role that a "string" does in other languages. The other model is a `++cord`. "foo" is a tape.

###Examples
	~tomsyt-balsen/try=> `(list ,@)`"foo"
	~[102 111 111]
	~tomsyt-balsen/try=> `@tD`102
	~~f

###Summary
	++  tape  (list char)                                   ::  list of characters
 
#Time models

##++date

####Parsed date
A list of a year cell (a loobean head for AD or BC and a year atom), a month atom, and a ++ tarp (a parsed time).

###Examples

###Summary
	++  date  ,[[a=? y=@ud] m=@ud t=tarp]                   ::  parsed date


##++tarp

####Parsed time
A list of atoms representing, in order, day, hour, minute, second and subsecond. The subsecond is itself a list of atoms.

###Examples

###Summary
	++  tarp  ,[d=@ud h=@ud m=@ud s=@ud f=(list ,@ux)]      ::  parsed time


##++time

####Galactic time
An atom that maps to a time. `~2014.2.17..14.47.50..0f86` is a time.

###Examples
	~tomsyt-balsen/try=> `@`~2014.2.17..14.47.50..0f86
	170.141.184.500.841.997.869.354.824.985.386.942.464
	~tomsyt-balsen/try=> `@da`170.141.184.500.841.997.869.354.824.985.386.942.464
	~2014.2.17..14.47.50..0f86

###Summary
	++  time  ,@da                                          ::  galactic time


#Parsing models

##++pint

####Line/column range
A cell of two atom pairs. Used for line and column range in a file.

###Examples

###Summary
	++  pint  ,[p=[p=@ q=@] q=[p=@ q=@]]                    ::  line/column range


##++dime

####Text atom/raw atom
A pair of a text atom and a raw atom.

###Examples

###Summary
	++  dime  ,[p=@ta q=@]                                  ::


##++coin

####
A dime (a span atom pair) labeled `%$`, a noun labeled `%blob`, and a list of  `++coin` (which could be null) labelled many.

###Examples

###Summary
		++  coin  $%  [%$ p=dime]                               ::
		              [%blob p=*]                               ::
		              [%many p=(list coin)]                     ::
		          ==                                            ::


#Parsing `@ta`

##++hapt

####Path
A list of spans: like a path.

###Examples

###Summary
	++  hapt  (list ,@ta)                                   ::


##++hair

####Line/column pair
A pair of unsigned decimal atoms, like a line column pair.

###Examples

###Summary
	++  hair  ,[p=@ud q=@ud]                                ::


##++nail

####Atom/tape pair
A pair of a pair of atoms and a tape. Used as an arg for parsing rules.

###Examples

###Summary
	++  nail  ,[p=hair q=tape]                              ::


##++path

####Path
A list of spans used to describe a location in a filesystem.

###Examples
	/~tomsyt-balsen/try is a path
	~tomsyt-balsen/try=> `(list ,@)`/~tomsyt-balsen/try
	~[2.239.102.822.615.623.022.927.944.589.735.038 7.959.156]
	~tomsyt-balsen/try=> `(list ,term)`/~tomsyt-balsen/try
	~[%~tomsyt-balsen %try]

###Summary
	++  path  (list span)                                   ::


##++wall

####List of lines
A list of ++tapes (list of chars) text lines in a file

###Examples

###Summary
	++  wall  (list tape)                                   ::  text lines


##++rule

####
A gate that takes a nail and produces and edge.

###Examples

###Summary
	++  rule  |=(tub=nail `edge`[p.tub ~ ~ tub])            ::


##++spot

####
A cell of a path and a pint. Used for a specific spot in a file.

###Examples

###Summary
	++  spot  ,[p=path q=pint]                              ::  range in file


#Uncategorized models

##++abel

####
One of four biblical names in hoon. Abel is used for staging/type upgrades. 

###Examples

###Summary
	++  abel  typo                                          ::  original sin: type


##++also

####
A triple of a `++term` (a text atom), a `++wing` (a list of limbs, or part of a subject) and a `++type`. 

###Examples

###Summary
	++  also  ,[p=term q=wing r=type]                       ::  alias


##++base

####

###Examples

###Summary
	++  base  ?([%atom p=odor] %noun %cell %bean %null)     ::  axils, @ * ^ ? ~
`?` is `$?` which is a `%fern`. `++base` is either an odored atom, a noun, a cell, a loobean or null.


##++beer

####String construction

###Examples

###Summary
	++  beer  $|(@ [~ p=twig])                              ::  string construction
`$|` is a `%reed`, `++beer` is an atom and the cell of null and a twig. string construction.


##++calf

####
A map of wines to numbers. 

###Examples

###Summary
	++  calf  ,[p=(map ,@ud wine) q=wine]                   ::


##++chum

####

###Examples

###Summary
	++  chum  $?  lef=term                                  ::  jet name
	              [std=term kel=@]                          ::  kelvin version
	              [ven=term pro=term kel=@]                 ::  vendor and product
	              [ven=term pro=term ver=@ kel=@]           ::  all of the above
	          ==                                            ::
`$?` is a fern. `++chum` is either a term called `lef`; a term called `std` and an  atom `kel`; a term `ven`, a term `pro`, and an atom `kel`; or a term `ven`, a term `pro`, an atom `ver` and an atom `kel`.


##++claw

####

###Examples

###Summary
	++  claw  $%  [%ash p=twig]                             ::  dry, geometric
	              [%elm p=twig]                             ::  wet, generic
	              [%oak ~]                                  ::  XX not used
	              [%yew p=(map term claw)]                  ::  XX not used
	          ==                                            ::
`$%` is a kelp. 


##++coat

####
The pair of a path (a list of spans) and a vase (a type noun pair).

###Examples

###Summary
	++  coat  ,[p=path q=vase]                              ::


##++coil

####

###Examples

###Summary
	++  coil  $:  p=?(%gold %iron %lead %zinc)              ::  %metl, variance
	              q=type                                    :: 
	              r=[p=?(~ ^) q=(map term foot)]            ::
	          ==                                            ::
`$:` is the tile autocons, `?` is a `%fern`. the head of a `++coil` is a `metl`, q is a `++type`.


##++dram

####

###Examples

###Summary
	++  dram  $%  [| p=(map ,@tas dram)]                    ::
	            [& p=@ud q=@]                             ::
	        ==                                            ::
`$%` is a kelp. A map of drams to terms or a pair of a `@ud` and a raw atom.


##++each

####
Effectively a macro

###Examples

###Summary
	++  each  |*([a=$+(* *) b=$+(* *)] $%([& p=a] [| p=b])) ::


##++edge

####
A pair of a `++hair` (pair of decimals) and a `++unit` of a noun and a nail pair. 

###Examples

###Summary
	++  edge  ,[p=hair q=(unit ,[p=* q=nail])]              ::


##++foot

####

###Examples

###Summary
	++  foot  $%  [%ash p=twig]                             ::  dry, geometric
	              [%elm p=twig]                             ::  wet, generic
	              [%oak ~]                                  ::  XX not used
	              [%yew p=(map term foot)]                  ::  XX not used
	          ==                                            ::
`$%` is a kelp. wet elm, dry ash, null, labeled? oak and yew for inheritance (ignored).


##++gear

####Unused
Gears are not currently used.

###Examples

###Summary
	++  gear  |*  a=_,*                                     ::  list generator
	          $_                                            ::
	          =|  b=*                                       ::
	          |?                                            ::
	          ?@  b                                         ::
	            ~                                           ::
	          [i=(a -.b) t=^?(..$(b +.b))]                  ::


##++like

####

###Examples

###Summary
	++  like  |*  a=_,*                                     ::  generic edge
	          |=  b=_`*`[(hair) ~]                          ::
	          :-  p=(hair -.b)                              ::
	          ^=  q                                         ::
	          ?@  +.b  ~                                    ::
	          :-  ~                                         ::
	          u=[p=(a +>-.b) q=[p=(hair -.b) q=(tape +.b)]] ::


##++limb

####

###Examples

###Summary
	++  limb  $|(term $%([%& p=axis] [%| p=@ud q=term]))    ::
`$|` is a `%reed`. `++limb` is a term and an axis or a term and a unsigned decimal. This is how values are addressed in wings.


##++line

####
Used by a kelp, its head is a %leaf, which reduces to a %cube label for the tile in the tail.

###Examples

###Summary
	++  line  ,[p=[%leaf p=odor q=@] q=tile]                ::  kelp case labels


##++list

####
A nested structure that terminates with ~.

###Examples
	~dovryp-toblug/try=> ((list ,@u) [1 2 3 ~])
	~[1 2 3]

###Summary
	++  list  |*  a=_,*                                     ::  null-terminated list
	          $|(~ [i=a t=(list a)])                        ::


##++metl

####Core variance
Any one of four labels describing core variance.

###Examples

###Summary
	++  metl  ?(%gold %iron %zinc %lead)                    ::  core variance


##++tree

####Binary tree
A simple binary tree. node is n, l is left, r is right. ~ terminates. Maps, Sets and Queues are all trees. See also: [treap](http://en.wikipedia.org/wiki/Treap).
	  n
	l     r

###Examples

###Summary
	++  tree  |*  a=_,*                                     ::  binary tree
	          $|(~ [n=a l=(tree a) r=(tree a)])             ::


##++port


####

###Examples

###Summary
	++  port  $:  p=axis                                    ::
	              $=  q                                     ::
	              $%  [%& p=type]                           ::
	                  [%| p=axis q=(list ,[p=type q=foot])] ::
	              ==                                        ::
	          ==                                            ::
[axis [%bark q [%kelp [%.y type] [%.n axis (list ,[type foot])]]]]


##++post

####

###Examples

###Summary
	++  post  $:  p=axis                                    ::
	              $=  q                                     ::
	              $%  [0 p=type]                            ::
	                  [1 p=axis q=(list ,[p=type q=foot])]  ::
	                  [2 p=twin q=type]                     ::
	              ==                                        ::
	          ==                                            ::


##++prop

####

###Examples

###Summary
	++  prop  $:  p=axis                                    ::
	              $=  q                                     ::
	              [p=?(~ axis) q=(list ,[p=type q=foot])]   ::
	          ==                                            ::


##++reef

####
Pair of a loobean and a decimal with another decimal.

###Examples

###Summary
	++  reef  ,[p=[p=? q=@ud] q=@ud]                        ::


##++shoe

####
Four cases: a tank, a term, a noun or a spot.

###Examples

###Summary
	++  shoe  $%  [%hunk p=tank]                            ::
	              [%lose p=term]                            ::
	              [%mean p=*]                               ::
	              [%spot p=spot]                            ::
	          ==                                            ::


##++tank

####

###Examples

###Summary
	++  tank  $%  [%leaf p=tape]                            ::  printing formats
	              [%palm p=[p=tape q=tape r=tape s=tape] q=(list tank)]
	              [%rose p=[p=tape q=tape r=tape] q=(list tank)]
	          ==                                            ::
`$%` is a kelp. `++tank` has three cases, a `%leaf`, a `%palm` and a `%rose`. `++tank` is for printing: `%palm` is backstep, `%rose` is straight down.


##++tiki

####

###Examples

###Summary
	++  tiki                                                ::  test case
	          $%  [& p=(unit term) q=wing]                  ::  simple wing
	              [| p=(unit term) q=twig]                  ::  named wing
	          ==                                            ::
`$%` is a kelp. `++tiki` has two cases, a unit term and a wing if yes, or a unit term and a twig if no. Used for name resolution.


##++tile

####
A convenient mechanism for making well-typed nouns.

###Examples

###Summary
	++  tile  $&  [p=tile q=tile]                           ::  ordered pair
	          $%  [%axil p=base]                            ::  base type
	              [%bark p=term q=tile]                     ::  name
	              [%bush p=tile q=tile]                     ::  pair/tag
	              [%fern p=[i=tile t=(list tile)]]          ::  plain selection
	              [%herb p=twig]                            ::  gate
	              [%kelp p=[i=line t=(list line)]]          ::  tag selection
	              [%leaf p=term q=@]                        ::  constant atom
	              [%reed p=tile q=tile]                     ::  atom/cell
	              [%weed p=twig]                            ::  example
	          ==                                            ::
`%axil` is an icon for an odored atom, a noun, a cell, a bean or null.  
`%bark` wraps a term around a tile.  
`%bush` is tile with an cellular head p or an atomic head q.  
`%fern` is a non-empty list of cases, must be orthogonal  
`%herb` is a `++twig`, used as a tile.  
`%kelp` is a tagged union, a list of cases and labels.  
`%leaf` is an atomic constant.  
`%reed` is atoms of `p=tile` and cells of `q=tile`  
`%weed` is a tile by default value, same as bunting a twig.  


##++toga

####
A term and one of three cases: null, a term and a ++toga, or a ++toga pair. Wraps a whole tree with faces.

###Examples

###Summary
	++  toga                                                ::  face control
	          $|  p=term                                    ::  two togas
	          $%  [0 ~]                                     ::  no toga
	              [1 p=term q=toga]                         ::  deep toga
	              [2 p=toga q=toga]                         ::  cell toga
	          ==                                            ::


##++twig

####AST
A `++twig` is an abstract syntax tree  

###Examples

###Summary
	++  twig  $&  [p=twig q=twig]                           ::
	          $%                                            ::
	            [%$ p=axis]                                 ::  blip, empty name
	          ::                                            ::::::  tile reductions:
	            [%bccb p=tile]                              ::  bunted tile
	            [%bccm p=tile]                              ::  validator gate
	            [%bcpt p=wing q=tile]                       ::  whips p into q
	            [%bctr p=tile]                              ::  static bunt w/ ^~
	            [%bczp p=base]                              ::  bunt an axil
	          ::                                            ::::::  cores
	            [%brcb p=tile q=(map term foot)]            ::  %gold tray, sample p
	            [%brcn p=(map term foot)]                   ::  %gold core
	            [%brdt p=twig]                              ::  dry %gold trap
	            [%brfs p=tile q=(map term foot)]            ::  vulcan. %gold tray
	            [%brkt p=twig q=(map term foot)]            ::  %gold book
	            [%brhp p=twig]                              ::  kick dry %gold trap
	            [%brls p=tile q=twig]                       ::  dry %iron gate
	            [%brpt p=tile q=tile r=twig]                ::  XX not used XX
	            [%brtr p=tile q=twig]                       ::  vulcan. wet gate
	            [%brts p=tile q=twig]                       ::  dry %gold gate
	            [%brwt p=twig]                              ::  dry %lead trap
	          ::                                            ::::::  tuples
	            [%clcb p=twig q=twig]                       ::  [q p]
	            [%clcn p=tusk]                              ::  [[p ~] ~]
	            [%clfs p=twig]                              ::  [%$ [%$ p ~] ~]
	            [%clkt p=twig q=twig r=twig s=twig]         ::  [p q r s]
	            [%clhp p=twig q=twig]                       ::  [p q]
	            [%clls p=twig q=twig r=twig]                ::  [p q r]
	            [%clsg p=tusk]                              ::  [p ~]
	            [%cltr p=tusk]                              ::  p as a tuple
	            [%clzz p=tusk]                              ::  macro for :~, :*
	          ::                                            ::::::  invocations
	            [%cncb p=wing q=tram]                       ::  %=, then cast to p
	            [%cncl p=twig q=twig]                       ::  pull $.p w/ sample q
	            [%cndt p=twig q=twig]                       ::  %-(q p)
	            [%cnhp p=twig q=tusk]                       ::  slam p w/ sample q
	            [%cntr p=wing q=twig r=tram]                ::  ??
	            [%cnkt p=twig q=twig r=twig s=twig]         ::  slam p w/ %*(q r s)
	            [%cnls p=twig q=twig r=twig]                ::  ??
	            [%cnsg p=wing q=twig r=twig]                ::  pull p from q with r
	            [%cnts p=wing q=tram]                       ::  eval. p w/ q changes
	            [%cnzy p=term]                              ::  pulls limb p
	            [%cnzz p=wing]                              ::  pulls p
	          ::                                            ::::::  nock
	            [%dtkt p=twig]                              ::  Nock 11 data skyhook
	            [%dtls p=twig]                              ::  Nock 4 increment
	            [%dtzy p=term q=@]                          ::  atom constant
	            [%dtzz p=term q=*]                          ::  cubed noun constant
	            [%dttr p=twig q=twig]                       ::  nock p w/ formula q
	            [%dtts p=twig q=twig]                       ::  Nock 5 equality test 
	            [%dtwt p=twig]                              ::  Nock 3 cell test
	          ::                                            ::::::  prettyprinter
	            [%hxgl p=tusk]                              ::  slam noah w/ !>:*(p)
	            [%hxgr p=tusk]                              ::  slam cain w/ !>:*(p)
	          ::                                            ::::::  type conversion
	            [%ktbr p=twig]                              ::  %gold core to %iron
	            [%ktdt p=twig q=twig]                       ::  cast q to type (p q)
	            [%ktls p=twig q=twig]                       ::  cast q to p, verify
	            [%kthp p=tile q=twig]                       ::  cast q to icon of p
	            [%ktpm p=twig]                              ::  %gold core to %zinc
	            [%ktsg p=twig]                              ::  p as static constant 
	            [%ktts p=toga q=twig]                       ::  wrap q in toga p
	            [%ktwt p=twig]                              ::  %gold core to %lead
	          ::                                            ::::::  hints   
	            [%sgbr p=twig q=twig]                       ::  print p if q fails 
	            [%sgcb p=twig q=twig]                       ::  put p in q's trace  
	            [%sgcn p=chum q=twig r=tyre s=twig]         ::  id a core for jets
	            [%sgfs p=chum q=twig]                       ::  jetted arm in a ~%
	            [%sggl p=$|(term [p=term q=twig]) q=twig]   ::  hint p to product q
	            [%sggr p=$|(term [p=term q=twig]) q=twig]   ::  hint p to q
	            [%sgbc p=term q=twig]                       ::  label q, profiling
	            [%sgls p=@ q=twig]                          ::  cache/memoize
	            [%sgpm p=@ud q=twig r=twig]                 ::  print q w/ priority
	            [%sgts p=twig q=twig]                       ::  avoid duplication
	            [%sgwt p=@ud q=twig r=twig s=twig]          ::  hint iff q is yes
	            [%sgzp p=twig q=twig]                       ::  type in stacktrace
	          ::                                            ::::::  miscellaneous
	            [%smcl p=twig q=tusk]                       ::  binary to n-ary
	            [%smdt p=twig q=tusk]                       ::  ?? 
	            [%smdq p=(list beer)]                       ::  assemble string
	            [%smsg p=twig q=tusk]                       ::  gonads
	            [%smsm p=twig q=twig]                       ::  make sure q is a p
	          ::                                            ::::::  compositions
	            [%tsbr p=tile q=twig]                       ::  push bunt: =+(_p q)
	            [%tscl p=tram q=twig]                       ::  apply p to .. to q 
	            [%tscn p=twig q=twig]                       ::  XX not used 
	            [%tsdt p=wing q=twig r=twig]                ::  r with p set to q 
	            [%tsfs p=twig q=twig]                       ::  XX not used 
	            [%tsgl p=twig q=twig]                       ::  =>(q p)
	            [%tshp p=twig q=twig]                       ::  flip push: =+(q p)
	            [%tsgr p=twig q=twig]                       ::  use p as subj of q
	            [%tskt p=twig q=twig r=twig s=twig]         ::  state machine wing
	            [%tsls p=twig q=twig]                       ::  push p on subj of q
	            [%tspm p=tile q=twig]                       ::  XX not used
	            [%tspt p=tile q=twig]                       ::  XX not used
	            [%tstr p=term q=wing r=twig]                ::  make a %bull/alias
	            [%tssg p=tusk]                              ::  compose twig list
	          ::                                            ::::::  conditionals 
	            [%wtbr p=tusk]                              ::  logical OR
	            [%wthp p=wing q=tine]                       ::  select case in q
	            [%wthz p=tiki q=tine]                       ::  tiki %wthp
	            [%wtcl p=twig q=twig r=twig]                ::  if p, then q, else r
	            [%wtdt p=twig q=twig r=twig]                ::  unless, ?:(p r q)
	            [%wtkt p=wing q=twig r=twig]                ::  if p is not bunt
	            [%wtkz p=tiki q=twig r=twig]                ::  tiki %wtkt
	            [%wtgl p=twig q=twig]                       ::  assert |, ?:(p !! q)
	            [%wtgr p=twig q=twig]                       ::  assert &, ?:(p q !!)
	            [%wtls p=wing q=twig r=tine]                ::  %wtls with default
	            [%wtlz p=tiki q=twig r=tine]                ::  tiki %wtls
	            [%wtpm p=tusk]                              ::  logical AND
	            [%wtpt p=wing q=twig r=twig]                ::  if p is an atom 
	            [%wtpz p=tiki q=twig r=twig]                ::  tiki %wtpt
	            [%wtsg p=wing q=twig r=twig]                ::  null-test if =(p ~)
	            [%wtsz p=tiki q=twig r=twig]                ::  tiki %wtsg
	            [%wtts p=tile q=wing]                       ::  if q is in tile p
	            [%wtzp p=twig]                              ::  logical NOT
	          ::                                            ::::::  special
	            [%zpcb p=spot q=twig]                       ::  debug info in trace
	            [%zpcm p=twig q=twig]                       ::  ??
	            [%zpcn ~]                                   ::  ??
	            [%zpfs p=twig]                              ::  report subj as err.
	            [%zpgr p=twig]                              ::  vase w/ value p 
	            [%zpsm p=twig q=twig]                       ::  [type noun] pair
	            [%zpts p=twig]                              ::  Nock formula of p
	            [%zpwt p=$|(p=@ [p=@ q=@]) q=twig]          ::  restrict hoon vers.
	            [%zpzp ~]                                   ::  always crash
	          ==  

`%bccb` produces a bunted tile  
`%bccm` produces a validator gate (%clam) for the tile  
`%bcpt` is a natural rune that %whips wing p into tile q  
`%bctr` produces the %bunt for tile p   
`%bczp` bunts an %axil (see ++tile) p  
`%brcb` produces a %gold tray with tile sample p  
`%brcn` is a natural rune that produces a %gold core  
`%brdt` produces a dry %gold trap  
`%brfs` produces a vulcanized %gold tray  
`%brkt` produces a %gold book  
`%brhp` produces a dry %gold trap, kicks it  
`%brls` produces a dry %iron gate  
`%brpt` is not used  
`%brtr` produces a vulcanized wet gate  
`%brts` produces a dry %gold gate  
`%brwt` produces a dry %lead trap  
`%clcb` produces cell [q p]  
`%clcn` produces cell [[p ~] ~] from a tusk  
`%clfs` produces cell [%$ [%$ p ~] ~]  
`%clkt` produces cell [p q r s]  
`%clhp` produces cell [p q]  
`%clls` produces cell [p q r]  
`%clsg` produces a null-terminated tuple  
`%cltr` produces a tuple  
`%clzz`   
`??`    
`%cncb` evaluates p with changes in q, casts back to p  
`%cncl` pulls %$ from tray p with sample q  
`%cndt` reversed %cnhp  
`??`  shouldn't p be a tusk?  
`%cnhp` slams gate p with q  
`%cntr`   
`??`  doc doesn't match. looks like it applies all the [wing twig] pairs ::  in r to q  
`%cnkt` slams gate p with %cntr q r s  
`%cnls` uses %cnhp p q r  
`??`  doc doesn't match, and %cnhp takes only two args  
`%cnsg` pulls p from tray q with sample r  
`??`  why isnt q's type a tray?  
`%cnts` evaluates p with changes in the tram q  
`%cnzy` pulls limb p from the subject  
`%dtkt` is a natural rune that grabs data from the sky  
`??`  very unclear  
`%dtls` is a natural rune that increments an atom  
`%dtzy` is a natural rune that produces a non-cubed atomic constant of ::  odor p and value q  
`%dtzz` is a natural rune that produces a cubed noun constant of odor p ::  and value q if q is an atom. if q is a cell produces q.  
`%dttr` is a natural rune that calculates nock of subject p, formula q  
`%dtts` is a natural rune that tests if two twigs are equal  
`%dtwt` is a natural rune that tests whether atom or cells  
`%hxgl` slams the gate ++noah with !>:*(p)  
`%hxgr` slams the gate ++cain with !>:*(p)  
`%ktbr` is a natural rune that converts %gold to %iron  
`%ktdt` casts q to type (p q)  
`%ktls` is a natural rule that casts q to p, verifying that p contains q  
`%kthp` casts q to the icon of p  
`%ktpm` converts %gold to %zinc  
`%ktsg` tries to execute p statically at compile time, if it fails p ::  ::  remains dynamic  
`%ktts` is a natural rune that wraps q in toga p  
`%ktwt` converts a %cold core p to %lead  
`%sgbr` prints p if q crashes  
`%sgcb` inserts p (a trap producing a tank) in the trace of q  
`%sgcn` ids a core p (in parent r) for optimization with a @tas s  
`??`  what is q for?   
`%sgfs` flags a core for jet propulsion. p is an arbitrary @tas for a ::  jet and q is a core inside of a book.  
`%sggl` applies hint p to product of q  
`%sggr` is a natural rune that applies hint p to q  
`%sgbc` labels q as p for profiling  
`%sgls` hints to the interpreter to cache/memoize the product of p  
`%sgpm` prints hint q before computing r with log priority p  
`%sgts` hints to interpreter that q may produce a noun equal to p to ::  ::  avoid duplication  
`%sgwt` prints hint [%sgpm p r s] iff q is yes  
`%sgzp` is a natural hoon that prints the type of p if q fails to compute  
`%smcl` applies a binary gate p to an n-ary tuple q  
`%smdt`   
`??`  undocumened, with a complicated expansion  
`%smdq` assembles a ++beer (string) p  
`%smsg`   
`??`  something related to gonads  
`%smsm` makes sure q is a p, and is the same as ++hard  
`%tsbr` pushes the bunt of p on to the subject and sends it to q  
`%tscl` modifies the subject with p and sends it to q  
`%tscn` is not used  
`%tsdt` produces r with p in the subject set to q  
`%tsfs` is not used  
`%tsgl` uses the product of p as the subject for q  
`%tshp` pushes q on the subject and sends it to p  
`%tsgr` is a natural rune that uses the product of p as the subject of q  
`%tskt` is for state machines.   
`??`  its unclear from the doc which argument is which  
`%tsls` pushes p on the subject and sends it to q  
`%tspm` is not used  
`%tspt` is not used  
`%tstr` creates a ++bull or alias type  
`%tssg` creates a list of twigs  
`%wtbr` logical or of two loobeans  
`%wthp` selects a case in q for the actual type of p  
`??`  not sure exactly what 'actual type' really means  
`%wthz` inverse of %wthp  
`%wtcl` p produces a loobean. if %.y then q if %.n then r  
`%wtdt` p produces a loobean. if %.n then q if %.y then r  
`%wtkt` if p is not equal to the bunt of its tile then q, else r  
`%wtkz` inverse of %wtkt  
`%wtgl` asserts that p is no and evaluates q  
`%wtgr` asserts taht p is yes and evaluates q  
`%wtls` %wthp with a default case  
`%wtlz`   
`??`  not sure i understand tikis. docs are the same for all of these.  
`%wtpm` computes the and of the loobeans in p  
`%wtpt` if p is an atom produce q else produce r  
`%wtpz` inverse of %wtpt  
`%wtsg` if p is ~ produce q else produce r  
`%wtsz` inverse of wtsg  
`%wtts` produces true if the leg in wing q is in the tile p  
`%wtzp` logical not of p  


##++tine

####
A list of tile twig pairs

###Examples

###Summary
	++  tine  (list ,[p=tile q=twig])                       ::


##++tusk

####
A list of twigs

###Examples

###Summary
	++  tusk  (list twig)                                   ::


##++tyre

####
A list of term twig pairs

###Examples

###Summary
	++  tyre  (list ,[p=term q=twig])                       ::


##++tyke

####
A list of unit twig pairs

###Examples

###Summary
	++  tyke  (list (unit twig))                            ::


##++tram

####
A list of wing twig pairs

###Examples

###Summary
	++  tram  (list ,[p=wing q=twig])                       ::


##++tone

####
Three cases: a noun, a list, and a list of span noun pairs.

###Examples

###Summary
	++  tone  $%  [%0 p=*]                                  ::
	              [%1 p=(list)]                             ::
	              [%2 p=(list ,[@ta *])]                    ::
	          ==                                            ::


##++nock

####Virtual nock

###Examples

###Summary
	++  nock  $&  [p=nock q=nock]                           ::  autocons 
	          $%  [%0 p=@]                                  ::  axis select
	              [%1 p=*]                                  ::  constant
	              [%2 p=nock q=nock]                        ::  compose
	              [%3 p=nock]                               ::  cell test
	              [%4 p=nock]                               ::  increment
	              [%5 p=nock q=nock]                        ::  equality test
	              [%6 p=nock q=nock r=nock]                 ::  if, then, else
	              [%7 p=nock q=nock]                        ::  serial compose
	              [%8 p=nock q=nock]                        ::  push onto subject
	              [%9 p=@ q=nock]                           ::  select arm and fire
	              [%10 p=?(@ [p=@ q=nock]) q=nock]          ::  hint
	              [%11 p=nock]                              ::  grab data from sky
	          ==                                            ::


##++toon

####
A noun, a list, or a list of tanks

###Examples

###Summary
	++  toon  $%  [%0 p=*]                                  ::
	              [%1 p=(list)]                             ::
	              [%2 p=(list tank)]                        ::
	          ==                                            ::


##++tune

####
A vase, a list or a list of span noun pairs

###Examples

###Summary
	++  tune  $%  [%0 p=vase]                               ::
	              [%1 p=(list)]                             ::
	              [%2 p=(list ,[@ta *])]                    ::
	          ==                                            ::


##++twin

####
A term, a wing, an axis and a type

###Examples

###Summary
	++  twin  ,[p=term q=wing r=axis s=type]                ::  %bull


##++type

####

###Examples

###Summary
	++  type  $|  ?(%noun %void)                            ::  set all or set none
	          $%  [%atom p=term]                            ::  number and format
	              [%bull p=twin q=type]                     ::  wing synonym
	              [%cell p=type q=type]                     ::  ordered pair
	              [%core p=type q=coil]                     ::  
	              [%cube p=* q=type]                        ::  constants
	              [%face p=term q=type]                     ::  named type
	              [%fork p=type q=type]                     ::  union/branch
	              [%hold p=(list ,[p=type q=twig])]         ::  infinite generator
	          ==                                            ::

A type is either a noun or void that resolves to:
`%atom` is an atom
`%bull` is a twin (a wing an axis and a type) and a type
`%cell` is a type and a type
`%core` is a type and a coil
`%cube` is a noun and a type
`%face` is a term (,@tas) and a type
`%fork` is a type and a type
`??`  what's the difference between a cell and a fork?
`%hold` is a list of type twig cells


##++typo

####Alias

###Examples

###Summary
	++  typo  type                                          ::  old type


#Diff models


##++udal

####
An unsigned decimal and a list the pair of a `@ud` and a `++unit` atom pair.

###Examples

###Summary
	++  udal                                                ::  atomic change (%b)
	          $:  p=@ud                                     ::  blockwidth
	              q=(list ,[p=@ud q=(unit ,[p=@ q=@])])     ::  indels
	          ==                                            ::


##++udon

####
Insertions and deletes

###Examples

###Summary
	++  udon                                                ::  abstract delta
	          $:  p=umph                                    ::  preprocessor
	              $=  q                                     ::  patch
	              $%  [%a p=ulna]                           ::  trivial replace
	                  [%b p=udal]                           ::  atomic indel
	                  [%c p=(urge)]                         ::  list indel
	                  [%d p=upas q=upas]                    ::  tree edit
	              ==                                        ::
	          ==                                            ::


##++ulna

####
A pair of nouns

###Examples

###Summary
	++  ulna  ,[p=* q=*]                                    ::  from to


##++umph

####

###Examples

###Summary
	++  umph                                                ::  change filter
	          $|  $?  %a                                    ::  no filter
	                  %b                                    ::  jamfile
	                  %c                                    ::  LF text
	              ==                                        ::
	          $%  [%d p=@ud]                                ::  blocklist
	          ==                                            ::


##++unce

####

###Examples

###Summary
	++  unce  |*  a=_,*                                     ::  change part
	          $%([%& p=@ud] [%| p=(list a) q=(list a)])     ::


##++unit

####
Takes a noun and is either a null or the cell [~ noun]

###Examples

###Summary
	++  unit  |*  a=_,*                                     ::  maybe
	          $|(~ [~ u=a])                                 ::


##++upas

####

###Examples

###Summary
	++  upas                                                ::  tree change (%d)
	          $&  [p=upas q=upas]                           ::  cell
	          $%  [%0 p=axis]                               ::  copy old
	              [%1 p=*]                                  ::  insert new
	              [%2 p=axis q=udon]                        ::  mutate!
	          ==                                            ::


##++urge

####

###Examples

###Summary
	++  urge  |*(a=_,* (list (unce a)))                     ::  list change


##++vase

####Type-value pair
A type and noun

###Examples

###Summary
	++  vase  ,[p=type q=*]                                 ::  type-value pair


##++vise

####
A `++vase`, except used for staging

###Examples

###Summary
	++  vise  ,[p=typo q=*]                                 ::  old vase


##++wing

####Part of subject
A list of limbs. This is how we get stuff inside our subject.

###Examples

###Summary
	++  wing  (list limb)                                   ::  part of subject


##++wine

####
A list of cubes, the first of which are types, the remainder of which look to be used for building trees of wines. 

###Examples

###Summary
	++  wine  $|  ?(%noun %path %tank %void %wall %wool %yarn)
	          $%  [%atom p=term]                            ::
	              [%core p=(list ,@ta) q=wine]              ::
	              [%face p=term q=wine]                     ::
	              [%list p=term q=wine]                     ::
	              [%pear p=term q=@]                        ::
	              [%pick p=(list wine)]                     ::
	              [%plot p=(list wine)]                     ::
	              [%stop p=@ud]                             ::
	              [%tree p=term q=wine]                     ::
	              [%unit p=term q=wine]                     ::
	          ==                                            ::


##++woof

####

###Examples

###Summary
	++  woof  (list $|(@ud [p=@ud q=@ud]))                  ::  udon transform


##++wonk

####
Takes an edge. Crashes if the q.edge (the unit) inside is an atom, produces p.u.q.edge if not.

###Examples

###Summary
	++  wonk  |*(veq=edge ?@(q.veq !! p.u.q.veq))           ::


##++map

####Map
A map is a tree of `[p=* q=*]` cells where `n` is the node, and `l` and `r` are branches. Intended for use in the map engine [++by](#++by). See also (++ept)[#++ept].

###Examples

###Summary
	++  map  |*  [a=_,* b=_,*]                              ::  associative array
	         $|(~ [n=[p=a q=b] l=(map a b) r=(map a b)])    ::


##++qeu

####Queue
A qeu is a tree, but is inteded for use in the queue engine, `++to`.

###Examples

###Summary
	++  qeu  |*  a=_,*                                      ::  queue type
	         $|(~ [n=a l=(qeu a) r=(qeu a)])                ::


##++set

####Set
A set is a tree, but is intended for use in the set engine, `++in`.

###Examples

###Summary
	++  set  |*  a=_,*                                      ::  set type
	         $|(~ [n=a l=(set a) r=(set a)])                ::