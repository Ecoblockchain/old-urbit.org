Foreword
Nock

Hoon
Preface

volume 0, version stub
++  stub  

volume 1, Hoon models
++  abel  
++  axis  
++  also  
++  base  
++  beer  
++  beet  
++  bloq  
++  calf  
++  char  
++  chum  
++  claw  
++  coat  
++  coil  
++  coin  
++  cord  
++  date  
++  dime  
++  dram  
++  each  
++  edge  
++  foot  
++  gear  
++  hair  
++  hapt  
++  like  
++  limb  
++  line  
++  list  
++  mane  
++  mano  
++  manx  
++  marl  
++  mars  
++  mart  
++  marx  
++  metl  
++  null  
++  odor  
++  tarp  
++  time  
++  tree  
++  nail  
++  numb  
++  pair  
++  pass  
++  path  
++  pint  
++  port  
++  post  
++  prop  
++  qual  
++  rege  
++  ring  
++  rule  
++  span  
++  spot  
++  tank  
++  tape  
++  term  
++  tiki  
++  tile  
++  toga  
++  trel  
++  tuna  
++  twig  
++  tine  
++  tusk  
++  tyre  
++  tyke  
++  tram  
++  tone  

++  nock  
++  toon  
++  tune  
++  twin  
++  type  
++  typo  
++  udal  
++  udon  
++  umph  
++  unce  
++  unit  
++  upas  
++  urge  
++  vase  
++  vise  
++  wall  
++  wain  
++  wing  
++  wine  
++  woof  
++  wonk  
++  map  
++  qeu  
++  set  
++  jar  
++  jug  

volume 2, Hoon libraries and compiler

chapter 2a, basic unsigned math

++  add 
  Comments:
        add
  Description:
        Sums two numbers.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        It must yield an atom.
        Check if a is equal to 0.
        Builds an if-then-else statement on a=0.  If so, produce 'b'.
        Else, the arm is called again with a replaced by (dec a) and b by +(b).
  Examples:
        ~palryp-hocsyt/try=> (add 2 2)
        4
        ---
        ~palryp-hocsyt/try=> (add 1 1.000.000)
        1.000.001
        ---
        ~palryp-hocsyt/try=> (add 1.333 (mul 2 2))
        1.337
++  cap
  Comments:
        tree head
  Description:
        Yields whether an atom is in the head or tail of a noun.
  Explanation:
        This arm is jetted.
        It must yield either %2 or %3.
        Selects a case below for the actual type of a.
        Yield %2 if a is %2.
        %3 if it is %3.
        Fail if a is either %0 or %1.
        Else, call cap recursively with a replaced by a/2.
        The case statement is closed.
  Examples:
        ~palryp-hocsyt/try=> (cap 4)
        %2
        ---
        ~palryp-hocsyt/try=> (cap 6)
        %3
        ---
        ~palryp-hocsyt/try=> (cap (add 10 9))
        %2
++  dec  
  Comments:
        decrement
  Description:
        Decrements a number - Subtracts one.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        When the following code crashes, print "%decrement-underflow" in the stack trace.
        Produce the next gate asserting a is not 0.
        Let b be 0.
        Creates a dry %gold trap which yields an atom.
        Builds an if-then-else statement on "a is equal to the increment of b."
        If so, produce b.
        Else, recursively call dec by replacing the argument b with the increment of b.
  Examples:
        ~palryp-hocsyt/try=> (dec 7)
        6
        ---
        ~palryp-hocsyt/try=> (dec 0)
        ! decrement-underflow
        ! exit
++  div  
  Comments:
        divide
  Description:
        Divides one number by another.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which  accepts two atoms.
        It must yield an atom.
        When the following code crashes, print "div" in the stack trace.
        Produce the next trap asserting that b is not 0.
        Let 'c' be 0.
        Create a dry %gold trap
        Builds an if-then-else statement on whether a is less than b.
        If so, produce c.
        Else, recursively call with a replaced by the difference of a and b and c by 
        the increment of c.
  Examples:
        ~palryp-hocsyt/try=> (div 4 2)
        2
        ---
        ~palryp-hocsyt/try=> (div 17 8)
        2
        ---
        ~palryp-hocsyt/try=> (div 20 30)
        0 
++  fac  
  Comments:
        factorial
  Description:
        Produces the factorial of a number n, n!.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        It must yield an atom.
        Builds an if-then-else statement on whether a is equal to 0.
        If so, produce 1.
        Else, multiply a by the recursive call of factorial with the decrement of a.
  Examples:
        ~palryp-hocsyt/try=> (fac 3)
        6
        ---
        ~palryp-hocsyt/try=> (fac 0)
        1
        ---
        ~palryp-hocsyt/try=> (fac 11)
        39.916.800
++  gte
  Comments:
        greater than or equal
  Description:
        Produces the loobean a>=b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Yield false if a is less than b, true else.
  Examples:
        ~palryp-hocsyt/try=> (gte 100 10)
        %.y
        ---
        ~palryp-hocsyt/try=> (gte 4 4)
        %.y
        ---
        ~palryp-hocsyt/try=> (gte 3 4)
        %.n
++  gth
  Comments:
        greater than
  Description:
        Produces the loobean a>b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Yield false if a is less than or equal to b, true else.
  Examples:
        ~ronrem-lonsem/try=> (gth 4 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (gth 5 4)
        %.y
        ---
        ~ronrem-lonsem/try=> (gth 5 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (gth 0 0)
        %.n
++  lte  
  Comments:
        less than or equal to
  Description:
        Produces the loobean a<=b.
  Explanation:
        This is a jetted arm.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Use logical OR to yield true if either a=b or (lth a b) is true.
  Examples:
        ~ronrem-lonsem/try=> (lte 4 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lte 5 4)
        %.n
        ---
        ~ronrem-lonsem/try=> (lte 5 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lte 0 0)
        %.y
++  lth  
  Comments:
        less than
  Description:
        Produces the loobean a<b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Use logical AND, thus immediately producing false if a=b.
        Then, create and kick a dry %gold trap which produces true on a=0,
        or false if a!=0 and b=0.
        If none of these cases are met, recursively call lth with both a and b decremented.
  Examples:
        ~ronrem-lonsem/try=> (lth 4 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lth 5 4)
        %.n
        ---
        ~ronrem-lonsem/try=> (lth 5 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (lth 5 0)
        %.n
++  mas  
  Comments:
        tree body
  Description:
       Produces the axis of a within the head or the tail. 
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts an atom.
        Must produce an atom.
        Selects a case below for the actual type of a.
        Exit if a is 1.
        Produce 1 if a is either 2 or 3.
        Else, sum the modulus of a and 2 with the 2 multiplied by the recursive call of 
        mas with a replaced by a/2.
  Examples:
        1 ~ronrem-lonsem/try=> (mas 3)
        1
        ---
        ~ronrem-lonsem/try=> (mas 4)
        2
        ---
        ~ronrem-lonsem/try=> (mas 5)
        3
        ---
        ~ronrem-lonsem/try=> (mas 6)
        2
        ---
        ~ronrem-lonsem/try=> (mas 7)
        3
        ---
        ~ronrem-lonsem/try=> (mas 8)
        4
        ---
        ~ronrem-lonsem/try=> (mas 0)
        ! exit
        ---
        ~ronrem-lonsem/try=> (mas 1)
        ! exit
++  max  
  Comments:
        maximum
  Description:
        Yields the larger of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Builds an if-else-then statement on a>b.
        If so, produce a.
        Else, produce b.
  Examples:
        ~palryp-hocsyt/try=> (max 10 100)
        100
        ---
        ~palryp-hocsyt/try=> (max 10.443 9)
        10.443
        ---
        ~palryp-hocsyt/try=> (max 0 1)
        1
++  min  
  Comments:
        minimum
  Description:
        Yields the smaller of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Builds an if-then-else statement on a<b.
        If so, produce a.
        Else, produce b.
  Examples:
        ~palryp-hocsyt/try=> (min 10 100)
        10
        ---
        ~palryp-hocsyt/try=> (min 10.443 9)
        9
        ---
        ~palryp-hocsyt/try=> (min 0 1)
        0
++  mod  
  Comments:
        remainder
  Description:
        Yields the modulus of (a mod b).
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Assert that b is not 0 before producing the below.
        Produce the difference of a and the product of b times a/b.
  Examples:
++  mul  
  Comments:
        multiply
  Description:
        Multiplies two numbers.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Let 'c' be 0.
        Create and kick a dry %gold trap.
        Builds an if-then-else statement on a=0.
        If so, produce c.
        Else, recursively call multiply with a replaced by decremented a and c replaced by b+c.
  Examples:
++  peg  
  Comments:
        tree connect
  Description:
        Produces the axis of b within the axis of a.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Select a case below for the actual type of b.
        Yield a on b=1.
        Yield (mul a 2) on b=2.
        Yield the increment of (mul a 2) on b=3.
        Else, sum (b mod 2) with the product of 2 and the recursive call to peg with b replaced by b/2.
  Examples:
        ~ronrem-lonsem/try=> (mul 5 3)
        15
        ---
        ~ronrem-lonsem/try=> (mul 1 0)
        0
++  sub  
  Comments:
        subtract
  Description:
        Accepts two atoms, a and b, and produces a-b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        When the following code crashes, print "%subtract-underflow" in the stack trace.
        Must produce an atom.
        Builds an if-then-else statement on b=0.
        If so, produce a.
        Else, produce the recursive call of subtract with a and b replaced by their respective decrements.
  Examples:
        ~ronrem-lonsem/try=> (sub 10 5)
        5
        ---
        ~ronrem-lonsem/try=> (sub 243 44)
        199
        ---
        ~ronrem-lonsem/try=> (sub 5 0)
        5
        ---
        ~ronrem-lonsem/try=> (sub 0 5)
        ! subtract-underflow
        ! exit

chapter 2b, basic containers

Section 2bA, units                    

++  biff 
  Comments:
        apply
  Description:
        Accepts a unit 'a' and a gate 'b' which produces a unit from the type of u.a, slamming the gate 
        with the value of a when a isn't null and producing ~ when it is.
  Explanation:
        Creates a vulanixed wet gate with a sample which accepts a unit and a $+(* (unit)) tiled gate.
        Builds an if-then-else statement on "a is null."
        If so, produce null.
        Else, produce b slammed with u.a.
  Examples:
        ~palryp-hocsyt/try=> (biff (some 5) |=(a=@ (some (add a 2))))
        [~ u=7]
        ---
        ~palryp-hocsyt/try=> (biff ~ |=(a=@ (some (add a 2))))
        ~
++  bind 
  Comments:
        argue
  Description:
        Accepts a unit 'a' and a gate 'b', producing a unit with value (b u.a) or, when a is null, null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit and a gate.
        Builds an if-then-else statement on "a is null."
        If so, produce null.
        Else, produce the a unit with value (b u.a), gate 'b' slammed with u.a.
  Examples:
        ~talsur-todres/try=> (bind ((unit ,@) [~ 97]) ,@t)
        [~ `a`]
        ---
        ~talsur-todres/try=> =a |=(a=@ (add a 1))
        ~talsur-todres/try=> (bind ((unit ,@) [~ 2]) a)
        [~ 3]
++  clap 
  Comments:
        combine
  Description:
        Applies a binary operation to the values of two units, producing the product as a unit.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts two units and a gate.
        Builds an if-then-else statment on "a is null."
        If so, produce b.
        Else, build an if-then-else statement on "b is null."
        If so, produce a.
        Else, produce the unit with value (c u.a u.b)
  Examples:
        ~palryp-hocsyt/try=> =u ((unit ,@t) [~ 'a'])
        ~palryp-hocsyt/try=> =v ((unit ,@t) [~ 'b'])
        ~palryp-hocsyt/try=> (clap u v |=([a=@t b=@t] (welp (trip a) (trip b))))
        [~ u="ab"]
        ---
        ~talsur-todres/try=> =a ((unit ,@u) [~ 1])
        ~talsur-todres/try=> =b ((unit ,@u) [~ 2])
        ~talsur-todres/try=> =c |=([a=@ b=@] (add a b))
        ~talsur-todres/try=> (clap a b c)
        [~ 3]
++  drop 
  Comments:
        enlist
  Description:
        Accepts a unit and produces the list [u.a ~] or null when the unit is null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit.
        Builds an if-then-else statement on "a is null."
        If so, produces null.
        Else, produce the list [u.a ~].
  Examples:
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> (drop a)
        [i=97 t=~]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~])
        ~divreg-misdef/try=> (drop a)
        ~
++  fall 
  Comments:
        default
  Description:
         a default value 'b' for the unit 'a' when it is null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit and any noun.
        Produces b if a is null and u.a if it is not.
  Examples:
        ~talsur-todres/try=> (fall ~ `a`)
        `a`
        ---
        ~talsur-todres/try=> (fall [~ u=0] `a`)
        0
++  mate 
  Comments:
        choose
  Description:
        Produces the unit 'a' or 'b' which is not null and crashes with error "mate" if they are equal.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a two units.
        Builds an if-then-else statement on "b is null."
        If so, produce a.
        Else, build an if-then-else statement on "a is null."
        If so, produce b.
        Else, build an if-else-then statement on  u.a=u.b.  Crash on "mate" if false, produce a if true.
  Examples:
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~ 97])
        ~divreg-misdef/try=> (mate a b)
        [~ 97]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~])
        ~divreg-misdef/try=> (mate a b)
        [~ 97]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~ 98])
        ~divreg-misdef/try=> (mate a b)
        ! 'mate'
        ! exit
++  need 
  Comments:
        demand
  Description:
        Retrieves the value from a unit, crashing if the unit is null.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a unit.
        Builds an if-then-else statement on "a is an atom."
        If so, crash.
        Else, produce u.a from the unit a.
  Examples:
        ~divreg-misdef/try=> =a ((unit ,[@t @t]) [~ [`a` ' b']])
        ~divreg-misdef/try=> (need a)
        [`a` ' b']
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~])
        ~divreg-misdef/try=> (need a)
        ! exit
++  some 
  Comments:
        lift
  Description:
        Casts any noun a to its unit, [~ a].
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts any noun.
        Produces the tuple [~ u=a], the unit of value a.
  Examples:
        ~divreg-misdef/try=> (some [`a` `b`])
        [~ u=[`a` `b`]]
        ---
        ~divreg-misdef/try=> (some &)
        [~ u=%.y]

Section 2bB, lists                    

++  flop 
  Comments:
        reverse
  Description:
        Produces the list 'a' with the elements reversed.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a single list.
        'a' is then replaced with (homo a) and used as the subject for the code below (=>).
        The type of the result must be the same as a, our argument list.
        Let b be a list of the type of the icon of a, as it is bunted.
        Create and kick a dry %gold trap
        Builds an if-then-else statement on "a is an atom."
        If so, produce b.
        Else, recursively call flop with a replaced by it's tail and b replaced by [i.a b], where
        i.a is the head of a.
  Examples:
        ~palryp-hocsyt/try=> =lyst (limo [1 2 3 4 ~])
        ~palryp-hocsyt/try=> lyst
        [i=1 t=[i=2 t=[i=3 t=[i=4 t=~]]]]
        ~palryp-hocsyt/try=> (flop lyst)
        ~[4 3 2 1]
        ---
        ~palryp-hocsyt/try=> (flop (limo [1 'a' 2 'b' (some 10) ~]))
        ~[[~ u=10] 98 2 97 1]
++  homo 
  Comments:
        homogenize
  Description:
        Homogenizes a lists' type information.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a single list.
        Makes the type of the result the type of the product of the code below (^+).
        The subject of the arm ($) is then the product of the barcen statement below (=<).
        Creates a %gold core (|%) and the arm '+-  $'.
        XXX BLACK BOX, ABANDON ALL HOPE YE WHO ENTER HERE XXX
        Terminates the core.
        Produces list a.
  Examples:
        ~palryp-hocsyt/try=> lyst
        [i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]
        ~palryp-hocsyt/try=> (homo lyst)
        ~[1 97 2 98 [~ u=10]]
        ---
        ~palryp-hocsyt/try=> =a (limo [1 2 3 ~])
        ~palryp-hocsyt/try=> a
        [i=1 t=[i=2 t=[i=3 t=~]]]
        ~palryp-hocsyt/try=> (homo a)
        ~[1 2 3]
++  limo 
  Comments:
        listify
  Description:
        Produces a list from any null-terminated tuple.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a single list.
        Makes the type of the result the type of the product of the code below (^+).
        The subject of the arm ($) is then the product of the barcen statement below (=<).
        Creates a %gold core (|%) and the arm '+-  $'.
        XXX BLACK BOX, ABANDON ALL HOPE YE WHO ENTER HERE XXX
        Terminates the core.
        Produces list a.
  Examples:
        ~palryp-hocsyt/try=> (limo [1 'a' 2 'b' (some 10) ~])
        [i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]
        ---
        ~palryp-hocsyt/try=> (limo [`a` `b` ~])
        [i=`a` t=[i=`b` t=~]]
        ---
        ~palryp-hocsyt/try=> (limo [2 1 ~])
        [i=2 t=[i=1 t=~]]
++  lent 
  Comments:
        length
  Description:
        Produces the atomic length of any list.
  Explanation:
        This is a jetted arm.
        Creates a dry %gold gate with a sample which accpets a single list.
        Must produce an atom.
        Let b be 0.
        Creates and kicks a dry %gold trap.
        Builds an if-then-else statement on "a is an atom."  If so, produces b.
        Else, recursively calls length with the list set to the tail of a and the accumulator, b, incremented.
  Examples:
        ~palryp-hocsyt/try=> (lent (limo [1 2 3 4 ~]))
        4
        ---
        ~palryp-hocsyt/try=> (lent (limo [1 'a' 2 'b' (some 10) ~]))
        5
++  levy
  Comments:
       all of
  Description:
        Applies the loobean gate 'b' to every element of the list 'a', producing the logical AND of all the results.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate with a sample of any noun
        and produces a loobean.
        Then, a dry %gold trap is created and kicked.  It must produce a loobean.
        Builds an if-then-else statement on "a is an atom."
        If so, produce true.
        Else, build an if-then-else statement on (b i.a)
        If so, then recursively call levy with a replaced by the tail of a.
        Else, produce no.
  Examples:
        ~palryp-hocsyt/try=> =b |=(a=@ (gte a 1))
        ~palryp-hocsyt/try=> (levy (limo [0 1 2 1 ~]) b)
        %.n
        ---
        ~palryp-hocsyt/try=> =b |=(a=@ (gte a 0))
        ~palryp-hocsyt/try=> (levy (limo [0 1 2 1 ~]) b)
        %.y        
++  lien 
  Comments:
        some of
  Description:
        Applies the loobean gate 'b' to every element of the list 'a', producing the logical OR of all the results.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate with a sample of any noun
        and produces a loobean.
        Then, a dry %gold trap is created and kicked.  It must produce a loobean.
        Builds an if-then-else gate on "a is null."  If so, produce false.
        Else, build an if-then-else gate on (b i.a).  If so, produce true.
        Else, recursively call lien with a replaced by the tail of a (t.a).
  Examples:
        ~palryp-hocsyt/try=> =a |=(a=@ (gte a 1))
        ~palryp-hocsyt/try=> (lien (limo [0 1 2 1 ~]) a)
        %.y
        ---
        ~palryp-hocsyt/try=> =a |=(a=@ (gte a 3))
        ~palryp-hocsyt/try=> (lien (limo [0 1 2 1 ~]) a)
        %.n
++  reel 
  Comments:
        right fold
  Description:
        Accepts a list 'a' and a gate 'b' which accepts two nouns, then folds (recursively calls 'b' across) the 
        list right to left, producing a value of the list element's type.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a trap which accepts two nouns.
        A dry %gold trap is created and kicked.  It must produce the type of the list's elements.
        Builds a if-then-else statement on "a is an atom."
        If so, produce q.b.
        Else, recursivley call b with the head of a and the rest of a replaced by the tail of a.
  Examples:     
        ~palryp-hocsyt/try=> =sum =|([p=@ q=@] |.((add p q)))
        ~palryp-hocsyt/try=> (reel (limo [1 2 3 4 5 ~]) sum)
        15
        ---
        ~palryp-hocsyt/try=> =a =|([p=@ q=@] |.((sub p q)))
        ~palryp-hocsyt/try=> (reel (limo [6 3 1 ~]) a)
        4
        ---
        ~palryp-hocsyt/try=> (reel (limo [3 6 1 ~]) a)
        ! subtract-underflow
        ! exit
++  roll 
  Comments:
        left fold
  Description:
        Accepts a list 'a' and a gate 'b' which accepts two nouns, then folds (recursively calls 'b' across) the
        list left to right, producing a value of the list of the element's type.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a trap which accepts two nouns.
        A dry %gold trap is then created and kicked.  It must produce the type of the list's elements.
        Builds an if-then-else statement on "a is an atom."
        If so, produce q.b.
        Else, recursively call roll with a replaced by the tail of a and b by the recursive call of b
        with q replaced by (b i.a q.b).
  Examples:
        ~barred-tidset/try=> =a =|([p=@ q=@] |.((sub p q)))
        ~barred-tidset/try=> (roll (limo [1 2 3 ~]) a)
        2
        ---
        ~barred-tidset/try=> (roll (limo [3 6 3 ~]) a)
        0
++  skid 
  Comments:
       separate
  Description:
        Accepts a list and a gate which takes any noun and produces a loobean.  Produces two lists, one who's elements
        produce true and one who's produce false by slamming the gate with them.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts a list and a gate which accepts any noun and 
        produces a loobean.
        Creates and kicks a dry %gold trap.  It must produce a tuple of two lists af a's type
        Builds an if-then-else statement on "a is null"  If so, produce a tuple of two nulls.
        Else, let 'c' be the recursive call of skid with a replaced by the tail of a.
        Builds an if-then-else statement on (b i.a).  If so, produce [[i.a p.c] q.c].
        Else, produce [p.c [i.a q.c]] where p.c and q.c are the separate list results of c.
  Examples:
        ~dovryp-toblug/try=> =a |=(a=@ (gth a 1))
        ~dovryp-toblug/try=> (skid (limo [0 1 2 3 ~]) a)
        [p=[i=2 t=[i=3 t=~]] q=[i=0 t=[i=1 t=~]]]
++  skim 
  Comments:
        only
  Description:
        Accepts a list 'a' and a gate 'b' which takes any noun and produces loobean.  
        Produces the sublist of 'a' whose elements produce true by slamming the gate with them.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate which accepts any noun and 
        produces a loobean.
        Creates and kicks a dry %gold trap.
        Which must produce a list of a's type.
        Builds an if-then-else statement on "a is an atom."
        If so, prodoce null.
        Else, build an if-then-else statement on (b i.a).  If so, produce [i.a $(a t.a)], where $(a t.a) is the recursive
        call of skim with a replaced by the tail of a.
        Else, produce $(a t.a).
  Examples:
        ~dovryp-toblug/try=> =a |=(a=@ (gth a 1))
        ~dovryp-toblug/try=> (skim (limo [0 1 2 3 ~]) a)
        [i=2 t=[i=3 t=~]]
++  skip 
  Comments:
        except
  Description:
        Accepts a 'a' list and a gate 'b' which takes any noun and produces a loobean.
        Produces the sublist of 'a' whose elments produce false by slamming the gate with them.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate which accepts any noun and 
        produces a loobean.
        Creates and kicks a dry %gold trap.
        Which must produce a list of a's type.
        Builds an if-then-else statement on "a is an atom."
        If so, produce null.
        Else build na if-then-else statement on (b i.a).  If so, produce the recursive call of skip with a replacd by
        the tail of a.
        Else, produce [i.a $(a t.a)].
  Examples:
        ~dovryp-toblug/try=> =a |=(a=@ (gth a 1))
        ~dovryp-toblug/try=> (skip (limo [0 1 2 3 ~]) a)
        [i=0 t=[i=1 t=~]]
++  scag 
  Comments:
        prefix
  Description:
        Accepts an atom 'n' and list 'b',  producing the first n elements at the front of the list.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts an atom and a list.
        A dry %gold trap is created and kicked.  It must produce a list of the same type as 'b'.
        Builds an if-then-else statement on the logical OR statement (a=0 or b is in null).
        If so, produce null.
        Else, produce [i.b $(b t.b, a (dec a))] where 'i.b' is the head of 'b' and $(b t.b, a (dec a))
        is the recursive call of scag with 'b' replaced by the tail of 'b' and 'a' decremented.
  Examples:
        ~palryp-hocsyt/try=> (scag 2 (limo [0 1 2 3 ~]))
        [i=0 t=[i=1 t=~]]
        ---
        ~palryp-hocsyt/try=> (scag 10 (limo [1 2 3 4 ~]))
        [i=1 t=[i=2 t=[i=3 t=[i=4 t=~]]]]
++  slag 
  Comments:
        suffix
  Description:
        Accepts an atom 'n' and a list 'b', producing the last n elemnents at the back of the list.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts an atom and a list.
        A dry %gold trap is created and kicked.  It must produce a list of the same type as 'b'.
        Builds an if-then-else statement on a=0.
        If so, produce 'b'.
        Else, build an if-then-else statement on "b is an atom."
        If so, produce null.
        Else, call slag recursively with b replaced by the tail of b, a replaced by the decrement of a.
  Examples:
        ~palryp-hocsyt/try=> (slag 2 (limo [0 1 2 3 ~]))
        [i=2 t=[i=3 t=~]] 
        ---
        ~palryp-hocsyt/try=> (slag 2 (limo [1 2 3 4 ~]))
        [i=3 t=[i=4 t=~]]
++  snag 
  Comments:
        index
  Description:
        Accepts an atom and a list, producing the element at the index of the atom in the list and failing is the list
        is null.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts an atom and a list.
        A dry %gold trap is created and kicked.
        Builds an if-then-else statement on "b is null."
        If so, fail with "snag-fail" in the stack trace.
        Else, build an if-then-else statement on a=0.
        If so, produce the head of 'b'.
        Else, recursively call snag with 'b' replaced by the tail of 'b' and 'a' decremented.
  Examples:
        ~palryp-hocsyt/try=> (snag 2 (limo [3 2 1 0 ~]))
        1
        ---
        ~palryp-hocsyt/try=> (snag 4 (limo [1 2 3 4 5 6 7 8 ~]))
        5
++  sort 
  Comments:
        quicksort
  Description:
        Accepts a list and a gate with a sample which accepts two nouns and produces a loobean.  'sort' then produces a 
        list of the elements of 'a' sorted according to 'b'.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate with a sample which accepts a list and a gate which accepts two nouns and
        produces a loobean.
        Homogenizes the list and makes it the subject of the following code, casting the following to the
        homogenized list type.
        Creates and kicks dry %gold trap.  It must produce a list of a's type.
        Builds an if-then-else statement on "a is null."  If so, produce null.
        Slam the weld gate with the q and r below.
        The q and r are then defined to be the recursive call of the trap with the skim of the tail by our sort gate.
        For q, it skims by (b c i.a).  For r, by !(b c i.a).
        r is first cast to the type of the tail of 'a' and produced as a tuple behind the head of 'a'.
  Examples:
        ~dovryp-toblug/try=> =a =|([p=@ q=@] |.((gth p q)))
        ~dovryp-toblug/try=> (sort (limo [0 1 2 3 ~]) a)
        ~[3 2 1 0]
++  swag 
  Comments:
        infix
  Description:
        A range in a list - Produces the values in list 'c' starting at index 'a' and spanning 'b' elements
        more than that.
  Explanation:
        Creates a vulcanized wet with a sample which gate which accepts a tuple of atoms and a list 'c'.
        The last 'a' elements in 'c' are selected by slag.  Then the first 'b' elements of 
        those last elements are selected and produced by scag.
  Examples:
        ~palryp-hocsyt/try=> (swag [0 5] (limo [1 2 3 4 5 6 7 8 9 10 ~]))
        [i=1 t=[i=2 t=[i=3 t=[i=4 t=[i=5 t=~]]]]]
        ---
        ~palryp-hocsyt/try=> (swag [3 5] (limo [1 2 3 4 5 6 7 8 9 10 ~]))
        [i=4 t=[i=5 t=[i=6 t=[i=7 t=[i=8 t=~]]]]]
        ---
        ~palryp-hocsyt/try=> (swag [1 2] (limo [1 2 3 ~]))
        [i=2 t=[i=3 t=~]] 
++  turn 
  Comments:
        transform
  Description:
        Accepts a list and a gate.  Produces the list with the gate applied to each element of the original list.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts a list and a gate.
        Creates and kicks a dry %gold trap.
        Builds an if-then-else statement on "a is an atom."
        If so, produce null.
        Else, produce the tuple with head (b i.a) and tail that is turn applied recursively to the tail of 'a'.
  Examples:
        ~dovryp-toblug/try=> (turn (limo [104 111 111 110 ~]) ,@t)
        <|h o o n|>
++  weld 
  Comments:
        concatenate
  Description:
        Concatenates two lists.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts two lists.
        Homogenizes both lists and makes them the subject of the following code.
        A dry %gold trap is created and kicked.  It must produce the type of list 'b'.
        Builds an if-then-else statement on "a is null."  If so, produce 'b'.
        Else, produce the tuple [i.a $(a t.a)].  'i.a' is the head of 'a', $(a t.a) the recursive call of weld
        with 'a' replaced by the tail of a.
  Examples:
        ~palryp-hocsyt/try=> (weld (limo [1 2 3 ~]) (limo [4 5 6 ~]))
        ~[1 2 3 4 5 6]
        ~palryp-hocsyt/try=> (weld "foo" "bar")
        ~[~~f ~~o ~~o ~~b ~~a ~~r]
++  welp 
  Comments:
        perfect weld
  Description:
        Concatenates two lists without losing their type information to homogenization.
        Produces a tape when passed two tapes.
  Explanation:
        XXX DON'T WORRY ABOUT HOW THIS WORKS, IT IS A PERPETUAL MIYSTERY TO US ALL. XXX
  Examples:
        ~palryp-hocsyt/try=> (welp "foo" "bar")
        "foobar"
++  wild 
  Comments:
        concatenate
  Description:
        Concatenates two lists without casting the product back to a list.
  Explanation:
        Creates a vulcanized wet gate with a sample which accepts two lists.
        Homogenizes both lists and makes them the subject of the following code.
        A dry %gold gate is created and kicked.
        Builds an if-then-else statement on "a is null."  If so, produce 'b'.
        Else, produce the tuple with head (b i.a) and tail that is turn applied recursively to the tail of 'a'.
  Examples:
        ~palryp-hocsyt/try=> =norm (limo [1 2 3 4 5 ~])
        ~palryp-hocsyt/try=> =norm2 (limo [6 7 8 ~])
        ~palryp-hocsyt/try=> (wild norm norm2)
        ~[1 2 3 4 5 6 7 8]
        ---
        ~palryp-hocsyt/try=> (wild "foo" "bar")
        ~[~~f ~~o ~~o ~~b ~~a ~~r]
        ---
        ~palryp-hocsyt/try=> (homo (weld "foo" "bar"))
        ~[~~f ~~o ~~o ~~b ~~a ~~r]
        ~palryp-hocsyt/try=> (homo (wild "foo" "bar"))
        ! -find-limb.t
        ! find-fork
        ! exit
++  zing 
  Comments:
        promote
  Description:
        Turns a list of lists into a single list by promoting the elements of each sublist into the higher.
  Explanation:
        Creates a vulcanized wet gate with a sample that accepts a list of lists.
        Casts the result to the type the homogenized list head, asserting that 'a' is at least a cell.
        A dry %gold trap is created and kicked.
        Builds an if-then-else statement on "a is null."  If so, produce null.
        Else, weld together the head of a with the recrusive call of zing on the tail of a.
  Examples:
        ~palryp-hocsyt/try=> (zing (limo [(limo ['a' 'b' 'c' ~]) (limo ['e' 'f' 'g' ~]) (limo ['h' 'i' 'j' ~]) ~]))
        ~['a' 'b' 'c' 'e' 'f' 'g' 'h' 'i' 'j']
        ~palryp-hocsyt/try=> (zing (limo [(limo [1 'a' 2 'b' ~]) (limo [3 'c' 4 'd' ~]) ~]))
        ~[1 97 2 98 3 99 4 100]

chapter 2c, simple noun surgery

section 2cA, bit surgery              **capitalization of "section" inconsistent in source**

++  bex  
  Comments:
        binary exponent
  Description:
        Produces 2 to the nth power for some atom 'n'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts a single atom.
        Casts the result to an atom.
        Builds an if-then-else statement on a=0.
        If so, produce 1.
        Else, multiply two by the recursive call of bex on the decrement of a.
  Examples:
        ~palryp-hocsyt/try=> (bex 4)
        16
        ~palryp-hocsyt/try=> (bex (add 19 1))
        1.048.576
        ~palryp-hocsyt/try=> (bex 0)
        1
++  xeb  
  Comments:
        binary logarithm
  Description:
        Takes the base-2 logarithm of an atom.
  Explanation:
        Creates a dry %gold gate with a sample which accepts an atom.
        Casts the result to an atom.
        Evaluates the logarithm by counting the number of bits the number in question occupies.
  Examples:
        ~palryp-hocsyt/try=> (xeb 31)
        5
        --
        ~palryp-hocsyt/try=> (xeb 32)
        6
        --
        ~palryp-hocsyt/try=> (xeb 49)
        6
        --
        ~palryp-hocsyt/try=> (xeb 0)
        0
        --
        ~palryp-hocsyt/try=> (xeb 1)
        1
        --
        ~palryp-hocsyt/try=> (xeb 2)
        2
++  can  
  Comments:
        assemble
  Description:
        Assembles a 
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a bloq size (an atom) and
        a list of atomic tuples.
        Casts the result to an atom.
        Builds an if-then-else statement on "b is null."
        If so, produce 0.
        Else, 
  Examples:
        ~ronrem-lonsem/try=> `@ub`(can 3 ~[[1 1]])
        0b1 
        ---
        ~ronrem-lonsem/try=> `@ub`(can 0 ~[[1 255]])
        0b1
        ---
        ~ronrem-lonsem/try=> `@ub`(can 1 ~[[1 2]])
        0b10
        ---
        ~ronrem-lonsem/try=> `@ub`(can 1 ~[[1 3]])
        0b11
        ---
        ~ronrem-lonsem/try=> `@ub`(can 1 ~[[1 4]])
        0b0
        ---
        ~ronrem-lonsem/try=> `@ub`(can 1 ~[[2 4]])
        0b100
++  cat  
  Comments:
        concatenate
  Description:
        Concatenates two atoms, obeying the given block size.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a bloq size (an atom) and
        two atoms.
        Measures the number of blocks of size 'a' are in 'b'.
        Left shifts 'c' that many times the bock size of 'a'.
        Sums the result of the left shift with 'b'.
  Examples:
        ~ronrem-lonsem/try=> `@ub`(cat 1 1 0)
        0b1
        ~ronrem-lonsem/try=> `@ub`(cat 2 1 0)
        0b1
        ~ronrem-lonsem/try=> `@ub`(cat 4 1 0)
        0b1
        ~ronrem-lonsem/try=> `@ub`(cat 0 1 1)
        0b11
        ~ronrem-lonsem/try=> `@ub`(cat 0 2 1)
        0b110
        ~ronrem-lonsem/try=> `@ub`(cat 2 1 1)
        0b1.0001
        ~ronrem-lonsem/try=> `@ub`256
        0b1.0000.0000
        ~ronrem-lonsem/try=> `@ub`255
        0b1111.1111
        ~ronrem-lonsem/try=> `@ub`(cat 3 256 255)
        0b1111.1111.0000.0001.0000.0000
        ~ronrem-lonsem/try=> `@ub`(cat 2 256 255)
        0b1111.1111.0001.0000.0000
        ~ronrem-lonsem/try=> (cat 3 256 255)
        16.711.936        
++  cut  
  Comments:
        slice
  Description:
        Accepts a block size 'a', a cell of two atoms 'b' and 'c' and another atom 'd'.
        Produces the tail of 'd' that is 'c' blocks long after right-shifting 'd' 'b'-blocks.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom),
        a cell of two atoms, and another atom which will be "cut."
        Right-shifts 'd' by 'b' blocks.  Then produces the tail of this of 'c' blocks.
  Examples:
        ~ronrem-lonsem/try=> (cut 0 [1 1] 2)
        1
        ~ronrem-lonsem/try=> (cut 0 [2 1] 4)
        1
        ~ronrem-lonsem/try=> (cut 3 [1 1] 256)
        1
        ~ronrem-lonsem/try=> (cut 2 [1 1] 255)
        15
        ~ronrem-lonsem/try=> (cut 1 [1 1] 255)
        3
        ~ronrem-lonsem/try=> (cut 1 [1 2] 255)
        15
++  end  
  Comments:
        tail
  Description:
        Accepts a block 'a' and two atoms, 'b' and 'c'.
        Produces the 'b' blocks of length 'a' on the end of 'c'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block (an atom) and
        two atoms.
        Multiplies the binary exponent of 'a' (2^a) with 'b', then takes the binary exponent
        of that (2^((2^a)*b)) to finally produce the modulus of 'c' and the ensuing product.
  Examples:
        ~ronrem-lonsem/try=> `@ub`12
        0b1100
        ---
        ~ronrem-lonsem/try=> `@ub`(end 0 3 12)
        0b100
        ---
        ~ronrem-lonsem/try=> (end 0 3 12)
        4
        ---
        ~ronrem-lonsem/try=> `@ub`(end 1 3 12)
        0b1100
        ---
        ~ronrem-lonsem/try=> (end 1 3 12)
        12
        ---
        ~ronrem-lonsem/try=> (end 3 1 256)
        0
        ---
        ~ronrem-lonsem/try=> (end 3 1 255)
        255 
++  fil  
  Comments:
        fill bloqstream
  Description:
        
  Explanation:
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        two other atoms.
        Let 'n' be 0.
        Let 'd' be 'c'.
        Creates and kicks a dry %gold trap whose result is cast to a atom.
        Builds an if-then-else statement on n=b.
        If so, produce the right-shift of 'd' by one block.
        Else, recursively call the trap with 'd' replaced by the sum of 'c' and the one block
        left-shift of 'b', n replaced by the increment of n.
  Examples:
        
++  lsh  
  Comments:
        left shift
  Description:
        Accepts a block size 'a' and two atoms 'b' and 'c'.  Produces 'c' left-shifted 
        'b' times by the block size.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block (an atom) and
        two atoms.
        Multiplies 'c' times the binary exponent of the binary exponent of 'a' times 'b',
        that is ((2^((2^a)*b))*c), this producing the desired left-shift on 'c'.
  Examples:
        ~ronrem-lonsem/try=> `@ub`1
        0b1
        ---
        ~ronrem-lonsem/try=> `@ub`(lsh 0 1 1)
        0b10
        ---
        ~ronrem-lonsem/try=> (lsh 0 1 1)
        2
        ---
        ~ronrem-lonsem/try=> `@ub`255
        0b1111.1111
        ---
        ~ronrem-lonsem/try=> `@ub`(lsh 3 1 255)
        0b1111.1111.0000.0000
        ---
        ~ronrem-lonsem/try=> (lsh 3 1 255)
        65.280
++  met  
  Comments:
        measure
  Description:
        Measures the number of blocks of size 'a' are in 'b'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        an atom.
        Casts the result to an atom.
        Let 'c' be 0.
        Creates and kicks a dry %gold trap.
        Builds an if-then-else statement on b=0.
        If so, produce c.
        Else, recursively call the trap, with 
        'b' replaced by the single-block right-shift of 'b' and 'c' by the increment of 'c'.
  Examples:
        ~ronrem-lonsem/try=> (met 0 1)
        1
        ~ronrem-lonsem/try=> (met 0 2)
        2
        ~ronrem-lonsem/try=> (met 3 255)
        1
        ~ronrem-lonsem/try=> (met 3 256)
        2
++  rap  
  Comments:
        assemble nonzero
  Description:
        Concatenates a list of atoms, obeying a given blocksize.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        a list of atoms.
        Casts the result to an atom.
        Builds an if-then-else statement on "b is an atom."
        If so, produce 0.
        Else, concateate the head of 'b' with the recursive call of rap on the tail of 'b',
        with block size a.
  Examples:
        ~palryp-hocsyt/try=> (rap 2 (limo [1 2 3 4 ~]))
        17.185
        ---
        ~palryp-hocsyt/try=> (rap 1 (limo [1 2 3 4 ~]))
        313
        ---
        ~palryp-hocsyt/try=> (rap 0 (limo [0 0 0 ~]))
        0
        ---
        ~palryp-hocsyt/try=> (rap 0 (limo [0 0 1 ~]))
        1
++  rep  
  Comments:
        assemble single
  Description:
        Assembles 
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        a list of atoms.
        Casts the result to an atom.
        Let 'c' be 0.
        Creates and kicks a dry %gold trap.
        Build an if-then-else statement on "b is an atom."
        If so, produce 0.
        Else, produce the binary logical OR of the 'c' time left-shift on the last block
        of the head of 'b' and the recursive call of the trap with:
        'c' replaced by the increment of 'c'.
        'b' replaced by the tail of 'b'.
  Examples:
        ~palryp-hocsyt/try=> (rep 0 (limo [1 2 3 4 ~]))
        5
        ---
        ~palryp-hocsyt/try=> (rep 1 (limo [1 2 3 4 ~]))
        57
        ---
        ~palryp-hocsyt/try=> (rep 0 (limo [1 0 0 ~]))
        1
        ---
        ~palryp-hocsyt/try=> (rep 0 (limo [1 0 0 0 ~]))
        1
        ---
        ~palryp-hocsyt/try=> (rep 0 (limo [0 1 0 0 ~]))
        2
        ---
        ~palryp-hocsyt/try=> (rep 0 (limo [0 1 0 1 ~]))
        10
        ---
        ~palryp-hocsyt/try=> (rep 0 (limo [0 1 0 1 0 1 ~]))
        42
++  rip  
  Comments:
        disassemble
  Description:
        Produces a list of the bits of an atom, in little endian order, according to
        block size.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and 
        any number.
        Cast the result to a list of atoms.
        Builds an if-then-else statement on b=0.
        If so, produce null.
        Else, produce a tuple with head of (end a 1 b), the single-block tail of 'b', and
        the resursive call of rip with 'b' replaced by the single-block right-shift of 'b'.
        in little endian.
  Examples:
        palryp-hocsyt/try=> `@ub`155
        0b1001.1011
        ---
        ~palryp-hocsyt/try=> (rip 0 155)
        ~[1 1 0 1 1 0 0 1]
        ---
        ~palryp-hocsyt/try=> (rip 2 155)
        ~[11 9]
        ---
        ~palryp-hocsyt/try=> (rip 1 155)
        ~[3 2 1 2]
        ---
        ~palryp-hocsyt/try=> `@ub`256
        0b1.0000.0000
        ---
        ~palryp-hocsyt/try=> (rip 0 256)
        ~[0 0 0 0 0 0 0 0 1]
        ---
        ~palryp-hocsyt/try=> (rip 2 256)
        ~[0 0 1]
        ---
        ~palryp-hocsyt/try=> (rip 3 256)
        ~[0 1]
        
++  rsh  
  Comments:
        right shift
  Description:
        Accepts a block size 'a' and two atoms, 'b' and 'c'.  Right-shifts 'c' by 'b' blocks
        of size 'a'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        two atoms.
        Takes the binary exponent of the binary exponent of 'a' multiplied by 'b',
        that is (2^(((2^a)*b))) and divides 'c' by it, producing the desired 
        right-shift on 'c'.
  Examples:
        ~ronrem-lonsem/try=> `@ub`145
        0b1001.0001
        ---
        ~ronrem-lonsem/try=> `@ub`(rsh 1 1 145)
        0b10.0100
        ---
        ~ronrem-lonsem/try=> (rsh 1 1 145)
        36
        ---
        ~ronrem-lonsem/try=> `@ub`(rsh 2 1 145)
        0b1001
        ---
        ~ronrem-lonsem/try=> (rsh 2 1 145)
        9
        ---
        ~ronrem-lonsem/try=> `@ub`10
        0b1010
        ---
        ~ronrem-lonsem/try=> `@ub`(rsh 0 1 10)
        0b101
        ---
        ~ronrem-lonsem/try=> (rsh 0 1 10)
        5
        ---
        ~ronrem-lonsem/try=> `@ub`1
        0b1
        ---
        ~ronrem-lonsem/try=> (rsh 0 1 1)
        0
        ---
        ~ronrem-lonsem/try=> (rsh 0 1 1)
        0
++  swap 
  Comments:
        reverse bloq order
  Description:
        Produces the reversed block order of a number, obeying block number.
        Switches little ending to big and vice versa.
  Explanation:
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        an atom.
        Rips apart the atom by the block size, then reverses the tape that is produced.
        Once it is reversed, it is re-assembled using rep.
  Examples:
        ~palryp-hocsyt/try=> `@ub`24
        0b1.1000
        ---
        ~palryp-hocsyt/try=> (swap 0 24)
        3
        ---
        ~palryp-hocsyt/try=> `@ub`3
        0b11
        ---
        ~palryp-hocsyt/try=> (swap 0 0)
        0
        ---
        ~palryp-hocsyt/try=> (swap 1 24)
        9
        ---
        ~palryp-hocsyt/try=> (swap 0 128)
        1
section 2cB, bit logic                

++  con  
  Comments:
        binary or
  Description:
        Produces the bit-wise logical OR of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Let 'c' be 0, d be 0.
        Creates and kicks a dry %gold trap.  Casts the result to an atom.
        Builds an if-then-else statement on a=b AND b=0.
        If so, produce 'd'.
        Else, recursively call the trap with:
        'a' replaced by the single 0-block right shift of 'a'.
        'b' replaced by the single 0-block right-shift of 'b'.
        'c' replaced by the increment of c.
        'd' replaced by the sum of 'd' and the 'c' 0-block left-shift of the
            logical AND of (last bit of 'a')=0 AND (last bit of 'b')=0.
        (==) terminates the list of changes.
  Examples:
        ~palryp-hocsyt/try=> (con 0 1)
        1
        ---
        ~palryp-hocsyt/try=> (con 1 0)
        1
        ---
        ~palryp-hocsyt/try=> (con 0 0)
        0
        ---
        ~palryp-hocsyt/try=> (con 4 4)
        4
        ---
        ~palryp-hocsyt/try=> (con 10.000 234)
        10.234
++  dis  
  Comments:
        binary and
  Description:
        Produces the bit-wise logical AND of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Pushes the bunt of a two atom tuple onto the subject.
        Creates and kicks a dry %gold trap.  Casts its result to an atom.
        Builds an if-then-else statement on a=0 or b=0.
        If so, produce 'd'.
        Else, recursively call the trap with:
        'a' replaced by the single 0-block right-shift of 'a'.
        'b' replaced by the single 0-block right-shift of 'b'.
        'c' replaced by the increent of 'c'.
        'd' replaced by the sum of 'd' and the 'c' 0-block left-shift of the
        logical OR of (last bit of 'a')=0 OR (last bit of 'b')=0.
        (==)  terminates the list of changes.
  Examples:
        ~ronrem-lonsem/try=> `@ub`9
        0b1001
        ---
        ~ronrem-lonsem/try=> `@ub`5
        0b101
        ---
        ~ronrem-lonsem/try=> `@ub`(dis 9 5)
        0b1
        ---
        ~ronrem-lonsem/try=> (dis 9 5)
        1
        ---
        ~ronrem-lonsem/try=> `@ub`534
        0b10.0001.0110
        ---
        ~ronrem-lonsem/try=> `@ub`987
        0b11.1101.1011
        ---
        ~ronrem-lonsem/try=> `@ub`(dis 534 987)
        0b10.0001.0010
        ---
        ~ronrem-lonsem/try=> (dis 534 987)
        530
++  mix  
  Comments:
        binary xor
  Description:
        Produces the bit-wise logical exclusive OR of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Casts the result to an atom.
        Let 'c' be 0, 'd' be 0.
        A dry %gold trap is created and kicked.
        Builds an if-then-else statement on a=0 AND b=0.
        If so, produce 'd'.
        Else, recursively call mix with:
        'a' replaced by 
        'b' replaced by
        'c' replaced by the increment of 'c'.
        'd' replaced by
        (==) terminates the list of changes.
  Examples:
        ~ronrem-lonsem/try=> `@ub`2
        0b10
        ~ronrem-lonsem/try=> `@ub`3
        0b11
        ~ronrem-lonsem/try=> `@ub`(mix 2 3)
        0b1
        ~ronrem-lonsem/try=> (mix 2 3)
        1
        ~ronrem-lonsem/try=> `@ub`(mix 2 2)
        0b0
        ~ronrem-lonsem/try=> (mix 2 2)
        0
++  not  
  Comments:
        binary not (sized)
  Description:
        Produces the bit-wise logical NOT over 'b' blocks of the given blocksize.
  Explanation:
        First produces the binary exponent of the binary exponent of the block size times       
        'b'.  This is decremented before being multiplied by 'c'.
        Finally, this product is exclusive ORed and produced.
  Examples:
        ~palryp-hocsyt/try=> `@ub`24
        0b1.1000
        ---
        ~palryp-hocsyt/try=> (not 0 5 24)
        7
        ---
        ~palryp-hocsyt/try=> `@ub`7
        0b111
        ---
        ~palryp-hocsyt/try=> (not 2 5 24)
        1.048.551
        ---
        ~palryp-hocsyt/try=> (not 2 5 1.048.551)
        24
        ---
        ~palryp-hocsyt/try=> (not 1 1 (not 1 1 10))
        10

section 2cC, noun orders              

++  aor  
  Comments:
        a-order
  Description:
        Alphabetic comparator gate.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts two nouns.
        Casts the result to a loobean.
        Builds an if-then-else statement on a=b.
        If so, produce true.
        Else, build an unless-then-else statement on "a is an atom."
        If 'a' is not an atom, build an unless-then-else statement on "b is an atom."
        If so, build an if-then-else statement on (-.a=-.b) where -.a is the head of 'a'.
        If so, recursively call aor with 'a' and 'b' replaced by their respecitve tails.
        Else, recursively call aor with 'a' and 'b' replaced by their respective heads.
        Else (if 'b' is an atom), produce false.
        Else (if 'a' is an atom), build an unless-then-else statement on "b is an atom."
        If so, produce true.
        Else, create and kick a dry %gold gate.
        Let 'c' be the byte tail of 'a', 'd' be the byte tail of 'b'.
        Builds an if-then-else statement on (c=d).
        If so, produce the recursive call to the trap with 'a' replaced by the byte right-shift of 'a'
        and 'b' replaced by the byte right-shift of 'b'.
        Else (if !(c=d)), produce (c<d).
  Examples:
       ~tadbyl-hilbel/try=> (aor 'a' 'b')
        %.y
        ~tadbyl-hilbel/try=> (aor 'b' 'a')
        %.n
        ---
        ~tadbyl-hilbel/try=> (aor "foo" "bar")
        %.n
        ~tadbyl-hilbel/try=> (aor "bar" "foo")
        %.y
        ---
        ~tadbyl-hilbel/try=> (aor "abcdefz" "abcdefa")
        %.n
        ~tadbyl-hilbel/try=> (aor "abcdefa" "abcdefz")
        %.y
        ---
        ~tadbyl-hilbel/try=> (aor 10.000 17.000)
        %.y
        ~tadbyl-hilbel/try=> (aor 10 9)
        %.n
++  dor  
  Comments:
        d-order
  Description:
        Numeric comparator gate.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts two nouns.
        Casts the result to a loobean.
        Builds an if-then-else statement on a=b.
        If so, produce true.
        Else, build an unless-then-else statement on "a is an atom."
        If 'a' is not an atom, build an unless-then-else statement on "b is an atom."
        If so, build an if-then-else statement on (-.a=-.b) where -.a is the head of 'a'.
        If so, recursively call dor with 'a' and 'b' replaced by their respecitve tails.
        Else, recursively call dor with 'a' and 'b' replaced by their respective heads.
        Else ('b' is an atom), produce false.
        Else ('a' is an atom), build an unless-then-else statement on "b is an atom."
        If so, produce true.
        Else, produce (a<b).
  Examples:
        ~tadbyl-hilbel/try=> (dor 1 2)
        %.y
        ~tadbyl-hilbel/try=> (dor 2 1)
        %.n
        ---
        ~tadbyl-hilbel/try=> (dor ~[1 2 3] ~[1 2 4])
        %.y
        ~tadbyl-hilbel/try=> (dor ~[1 2 4] ~[1 2 3])
        %.n
        ---
        ~tadbyl-hilbel/try=> (dor (limo ~[99 100 10.000]) ~[99 101 10.000])
        %.y
        ~tadbyl-hilbel/try=> (dor ~[99 101 10.999] (limo ~[99 100 10.000]))
        %.n
++  gor  
  Comments:
        g-order
  Description:
        Hash comparator gate.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts two nouns.
        Casts the result to a loobean.
        Let 'c' be the mug (FNV-1a hash) of 'a' an 'd' the mug of 'b'.
        Create an if-then-else statement on c=d.
        If so, produce the d-order of 'a' and 'd'.
        Else, produce the loobean (c<d).
  Examples
        ~palryp-hocsyt/try=> (gor 'd' 'c')
        %.y
        ~palryp-hocsyt/try=> 'd'
        'd'
        ~palryp-hocsyt/try=> 'c'
        ~palryp-hocsyt/try=> `@ud`'d'
        100
        ~palryp-hocsyt/try=> `@ud`'c'
        99
        ~palryp-hocsyt/try=> (mug 'd')
        1.628.185.714
        ~palryp-hocsyt/try=> (mug 'c')
        1.712.073.811
        ~palryp-hocsyt/try=> (gor 'd' 'c')
        %.y
        ~palryp-hocsyt/try=> (gor 'c' 'd')
        %.n
        ---
        ~palryp-hocsyt/try=> (gor "foo" "bar")
        %.n
        ---
        ~palryp-hocsyt/try=> (gor (some 10) (limo [1 2 3 ~]))
        %.n
++  hor  
  Comments:
        h-order
  Description:
        Recursive hash comparator gate.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts two nouns.
        Casts the result to a loobean.
        Build an if-then-else statement on "a is an atom."
        If so, build na if-then-else statment on "b is an atom."
        If so, produce  the g-order of 'a' and 'b'.
        Else (if 'b' is not an atom), produce true.
        Else (if 'a' is not an atom), build an if-then-else statement on "b is an atom."
        If so, produce false.
        Else, build an if-then-else statement on (-.a=-.b), where '-.a' is the head of 'a'. 
        If so, produce the g-order of the tails of 'a' and 'b'.
        Else (if the heads of 'a' and 'b' are not equal), produce the g-order of the tails of 'a', 'b'.
  Examples:
        
++  vor
  Comments:
        v-order
  Description:
        Double hash comparator gate.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts two nouns.
        Casts the result to a loobean.
        Let 'c' be the double mug (FNV-1a hash) of 'a', 'd' that of 'b'.
        Builds an if-then-else statement on (c=d).
        If so, produce the d-order of 'a' and 'b'.
        Else, produce the loobean of (c<d).
  Examples:
        ~palryp-hocsyt/try=> (vor 'f' 'g')
        %.y
        ---
        ~palryp-hocsyt/try=> (vor 'a' 'z')
        %.n
        ---
        ~palryp-hocsyt/try=> (vor 43.326 41.106)
        %.n

section 2cD, insecure hashing         

++  fnv
  Comments:
        FNV scrambler
  Description:
        Hashes an atom with the 32-bit FNV non-cryptographic hash algorithm.
  Explanationj
        Multiplies 'a' by the prime number 16,777,619 and then takes the block of
        size 5 off the product's end.
  Examples:
        ~palryp-hocsyt/try=> (fnv 10.000)
        272.465.456
        ---
        ~palryp-hocsyt/try=> (fnv 10.001)
        289.243.075
        ---
        ~palryp-hocsyt/try=> (fnv 1)
        16.777.619
++  mug
  Comments:
        31bit nonzero FNV1a
  Description:
        Hashes any noun with the 31-bit nonzero FNV-1a non-cryptographic hash algorithm.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample accepting any noun.

        (?^ and 'p' subsection fill in.)      

        Let 'b' be 2,166,136,261.
        Create and kick a dry %gold gate.  Cast its result to an atom.
        Let 'c' be 'b'.
        Let 'd' be 0, 'e' be the number of bytes in 'a'.
        Create and kick a dry %gold gate.  Cast its result to an atom.
        Builds an if-then-else statement on d=e.
        If so, let 'f' be the bit-wise XOR on the 31 0-block shift on 'c' and the last
        31 blocks of 'c'.
        Builds an unless-then-else statement on f=0.  If then, produce 'f'.
        Else, recursively call the trap above our current trap with 'b' replaced by +(b).
        Else (d isn't equal to e), then recursively call the trap with 'c' replaced by
        the fnv hash of the logical XOR of 'c' and (cut 3 [d 1] a), 'd' replaced by
        the increment of 'd'.
        
  Examples:
        ~palryp-hocsyt/try=> (mug 10.000)
        178.152.889
        ---
        ~palryp-hocsyt/try=> (mug 10.001)
        714.838.017
        ---
        ~palryp-hocsyt/try=> (mug 1)
        67.918.732
        ---
        ~palryp-hocsyt/try=> (mug (some 10))
        1.872.403.737
        ---
        ~palryp-hocsyt/try=> (mug (limo [1 2 3 4 5 ~]))
        1.067.931.605

section 2cE, phonetic base            

++  po
  Comments:
        left-right syllable
  Description:
        Provides the phonetic syllables and name generators for the Urbit naming system.
  Explanation:
        This arm is jetted.
        Create the cell [sis dex] where 'sis' and 'dex' are the togas on the 
        left-hand ("sinister") and right-hand ("Dexter") phonetic syllable cords, respectively.
        Build a %gold core to contain the following arms.
  ++  ind 
  Comments:
        
  Description:
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts and atom.
        Let 'b' be 0.
        Creates and kicks a dry %gold trap, casting the result to an atomic unit.
        Builds an if-then-else statement on (b=256).  If so, produce null.
        Else, build an if-then-else statement on (a=(tod b)).  If so, produce the atomic unit [~ b].
        Else, recursively call the trap with 'b' replaced by the increment of 'b'.
  Examples:
  
  ++  ins 
  Comments:
        
  Description:
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts and atom.
        Let 'b' be 0.
        Creates and kicks a dry %gold trap with the result cast to an atomic unit.
        Builds an if-then-else statement on (b=256). If so, produce null.
        Else, build an if-then-else statement on (a=(tos b)).  If so, produce the atomic unit [~ b].
        Else, recursively call the trap with 'b' replaced by the increment of 'b'.
  Examples:

  ++  tod 
  Comments:
  Description:
        Selects right-hand phonetic syllable from 'dex'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts and atom.
        Assert that 'a' is less than 256.
        Produce the three tail-end byte blocks in the rght-shift of dex.
  Examples:
        ~palryp-hocsyt/try=> (tod:po 98)
        6.514.020
        ---
        ~palryp-hocsyt/try=> (tod:po 150)       
        6.781.298
        ---
        ~palryp-hocsyt/try=> (tod:po 255)
        7.562.598
        ---
        ~palryp-hocsyt/try=> (tod:po 256)
        ! exit
  ++  tos 
  Comments:

  Description:
        Selects left-hand phonetic syllable from 'sin'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts and atom.
        Assert that 'a' is less than 256.
        Produce the three tail-end byte blocks in the rght-shift of dex.
  Examples:
section 2cF, signed and modular ints  

++  si    
  Comments:
        signed integer
  ++  abs 
  Comments:
        absolute value
  Description:
        Produces the absolute value of a signed integer.
  Explanation:
        Creates a dry %gold gate with a sample which accepts a single atom.
        Sums the last bit of the atom with the single bit-wise block right-shift of the atom,
        producing the absolute value.
  Examples:
        ~palryp-hocsyt/try=> (abs:si -2)
        2
        ---
        ~palryp-hocsyt/try=> (abs:si -10.000)
        10.000
        ---
        ~palryp-hocsyt/try=> (abs:si --2)
        2
  ++  dif 
  Comments:
        subtraction
  Description:
        Produces the difference between two signed integers.
  Explanation:
        Creates a dry %gold gate with a sample which accepts two signed integers.
        Sums the first signed integer with a new signed integer, made from the second by
        (new !(syn b) (abs b)), where !(syn b) is the negative of the second integer's sign.
        This sum, produced, is the difference.
  Examples:
        ~palryp-hocsyt/try=> (dif:si --10 -7)
        --17
        ---
        ~palryp-hocsyt/try=> (dif:si --10 --7)
        --3
        ---
        ~palryp-hocsyt/try=> (dif:si `@s`0 --7)
        -7
        ---
        ~palryp-hocsyt/try=> (dif:si `@s`0 `@s`7)
        --4
  ++  dul 
  Comments:
        modulus
  Description:
        Produces the modulus of two signed integers.
  Explanation:
        Creates a dry %gold gate which accepts a signed integer and an atom.
        Let 'c' be the [sign value] representation of 'a'.
        Builds an if-then-else statement on -.c, the sign of 'a'.
        If so ('a' is positive.), produce the modulus of the absolute value of 'c' and 'b'.
        Else, produce the differenece between 'b' and the absolute value of 'c'.
  Examples:
        ~palryp-hocsyt/try=> (dul:si --9 3)
        0
        ---
        ~palryp-hocsyt/try=> (dul:si --9 4)
        1
        ---
        ~palryp-hocsyt/try=> (dul:si --9 5)
        4
        ---
        ~palryp-hocsyt/try=> (dul:si --9 6)
        3
        ---
        ~palryp-hocsyt/try=> (dul:si --90 --10)
        10
  ++  fra 
  Comments:
        divide
  Description:
        Produces the quotient of two signed integers.
  Explanation:
        Creates a dry %gold gate with a sample which accepts two signed integers.
        Divides the absolute value of 'a', the dividend, and 'b', the divisor, and
        passes that value as the unsigned integer value of a new signed integer.
        The sign of the new signed integer is the bitwise logical XOR of the two integer's 
        signs, meaning the quotient is only positive when both factors are positive.
        This new signed integer is produced.
  Examples:
        ~palryp-hocsyt/try=> (fra:si --4 --2)
        --2
        ---
        ~palryp-hocsyt/try=> (fra:si -4 -2)
        --2
        ---
        ~palryp-hocsyt/try=> (fra:si -4 --2)
        -2
        ---
        ~palryp-hocsyt/try=> (fra:si --4 -2)
        -2
        ---
        ~palryp-hocsyt/try=> (fra:si `@s`4 `@s`2)
        --2
        ---
        ~palryp-hocsyt/try=> (fra:si `@s`4 2)
        ! type-fail
        ! exit
  ++  new 
  Comments:
        [sign value] to @s
  Description:
        Produces a signed integer from a sign value (either & or |) and an atom.
  Explanation:
        Creates a dry %gold gate with a sample which acccepts a loobean and an atom
        Builds an if-then-else statement on the sign value 'a'.
        If so, just produce 'b' multiplied by 2.
        Else, build an if-then-else statement on b=0.  If so, produce 0.
        Else, produce the increment of (2*(dec b)).
        The result is then cast to an integer and produced from new:si.
  Examples:
        ~palryp-hocsyt/try=> (new:si [& 10])
        --10
        ~palryp-hocsyt/try=> (new:si [| 10])
        -10
        ~palryp-hocsyt/try=> (new:si [%.y 7])
        --7
  ++  old
  Comments:
        [sign value]
  Description:
        Produces the cell [sign value] representations of a signed integer.
  Explanation:
        Create a dry %gold date with a with a sample which accepts a signed integer.
        Produce a cell with head (syn a), the sign of 'a', and tail (abs), the absolute value of 'a'.
  Examples:
        ~palryp-hocsyt/try=> (old:si 7)
        ! type-fail
        ! exit
        ---
        ~palryp-hocsyt/try=> (old:si -7)
        [%.n 7]
        ---
        ~palryp-hocsyt/try=> (old:si --7)
        [%.y 7]
        ---
        ~palryp-hocsyt/try=> (old:si `@s`7)
        [%.n 4]
        ---
        ~palryp-hocsyt/try=> (old:si -0)
        [%.y 0]
  ++  pro       
  Comments:
        multiplication
  Description:
        Produces the product of two signed integers.
  Explanation:
        Creates a dry %gold gate with a sample which accepts two signed integers.
        Produces their product by evaluating a new signed integer whose sign is the bitwise 
        XOR of the two number's signs and whose value is the product of their two absolute values.
  Examples:
        palryp-hocsyt/try=> (pro:si -4 --2)
        -8
        ---
        ~palryp-hocsyt/try=> (pro:si -4 -2)
        --8
        ---
        ~palryp-hocsyt/try=> (pro:si --10.000.000 -10)
        -100.000.000
        ---
        ~palryp-hocsyt/try=> (pro:si -1.337 --0)
        --0
  ++  rem 
  Comments:
        remainder
  Description:
        Produces the remainder from a division of two signed integers.
  Explanation:
        Creates a dry %gold gate with a sample which accepts two signed integers.
        Produces the difference between 'a' and the (b*(a/b)).
  Examples:
        ~palryp-hocsyt/try=> (rem:si -10 -4)
        -2
        ---
        ~palryp-hocsyt/try=> (rem:si --10 --4)
        --2
        ---
        ~palryp-hocsyt/try=> (rem:si --10 -4)
        --2
        ---
        ~palryp-hocsyt/try=> (rem:si --7 --3)
        --1
        ---
        ~palryp-hocsyt/try=> (rem:si --0 --10.000)
        --0
  ++  sum 
  Comments:
        addition
  Description:
        Sums two signed integers.
  Explanation:
        Creates a dry %gold gate which accepts two signed integers.
        Prints '%si-sum' in the stack trace if the following code crashes.
        Let 'c' and 'd' be the [sign value] representation of 'a' and 'b', respectively.
        Builds an if-then-else statement on "c is positive".
        If so, build an if-then-else statement on "d is positive".
        If so, produce a new, positive signed integer with value ((abs a)+(abs b))
        Else, build an if-then-else statement on (abs a)>=(abs b)
        If so, produce a new, positive integer with value ((abs a)-(abs d)).
        Else (if !((abs a)>=(abs b))), produce a new, negative signed integer
        with value ((abs d)-(abs c)).
        Else (if c is not positive), build an if-then-else statement on "d is positive".
        If so, build an if-then-else statement on (abs a)>=(abs b).
        If so, produce a new, negative signed intger with value ((abs a)-(abs b))
        Else, produce a new, positive signed integer with value ((abs c)-(abs d))
        Else (if d is not positive), produce a new, negative signed with value ((abs c)+(abs d)).
  Examples:
        ~palryp-hocsyt/try=> (sum:si --10 --10)
        --20
        ---
        ~palryp-hocsyt/try=> (sum:si --10 -0)
        --10
        ---
        ~palryp-hocsyt/try=> (sum:si -10 -7)
        -17
        ---
        ~palryp-hocsyt/try=> (sum:si -10 --7)
        -3
  ++  sun 
  Comments:
        @u to @s
  Description:
        Produces a signed integer from an unsigned integer.
        Note that the result must be manually cast to some @s odor to be inferred as an
        unsigned integer in the type system.
  Explanation:
        Creates a dry %gold gate with a sample which accepts any unsigned integer.
        Produces the integer multiplied by 2.
  Examples:
        ~palryp-hocsyt/try=> `@s`10
        --5
        ---
        ~palryp-hocsyt/try=> (sun:si 10)
        20
        ---
        ~palryp-hocsyt/try=> `@s`(sun:si 10)
        --10
        ---
        ~palryp-hocsyt/try=> `@sd`(sun:si 10)
        --10
        ---
        ~palryp-hocsyt/try=> `@sd`(sun:si 12.345)
        --12.345
  ++  syn 
  Comments:
        sign test
  Description:
        Produces the sign of the signed integer, & being positive and | being negative.
  Explanation:
        Creates a dry %gold gate with a sample which accepts a signed integer.
        Produces the loobean of 0=(last bit in the signed integer)
  Examples:
        ~palryp-hocsyt/try=> (syn:si -7)
        %.n
        ---
        ~palryp-hocsyt/try=> (syn:si --7)
        %.y
        ---
        ~palryp-hocsyt/try=> (syn:si (new:si [& 7]))
        %.y
        ---
        ~palryp-hocsyt/try=> (syn:si -0)
        %.y
        ---
        ~palryp-hocsyt/try=> (syn:si --0)
        %.y
        
++  fe    
  Comments:
        modulo bloq
  Description:
        Binary block modulo math engine.  Defaults to bloq size 1.
  Explanation:
        Builds an %gold tray with a sample accepting a bloq size (an atom).
  ++  dif 
  Comments:
        subtraction
  Description:
        Produces the difference between two atoms in the modular basis representation.
  Explanation:
        Creates a dry %gold gate which accepts two atoms.
        Evaluate the difference between the sum of the 'out' and 
        
  Examples:

  ++  inv 
  Comments:
        invert
  Description:
        Inverts the order of the modular field.
  Explanation:
  Examples:
        palryp-hocsyt/try=> (~(inv fe 3) 255)
        0
        ~palryp-hocsyt/try=> (~(inv fe 3) 256)
        255
        ~palryp-hocsyt/try=> (~(inv fe 3) 0)
        255
        ~palryp-hocsyt/try=> (~(inv fe 3) 1)
        254
        ~palryp-hocsyt/try=> (~(inv fe 3) 2)
        253
        ~palryp-hocsyt/try=> (~(inv fe 3) 3)
        252
  ++  net 
  Comments:
  Description:
  Explanation:
  Examples:

  ++  out 
  Comments:
  Description:
  Explanation:
  Examples:

  ++  rol 
  Comments:
  Description:
  Explanation:
        Creates a dry %gold gate which accepts a block size (an atom) and two other atoms.
        The result of cast to an atom.  'd' is expressed in the modular base as 'e'.
        Let 'f' be the binary exponential difference between 'a' and 'b'.
        Let 'g' be (c mod f).
        Right-shift 'e' by (sub f g) (The difference between 'f' and 'g') blocks of size 'b'.
        Left-shift 'e' by 'g' blocks of size 'b'.
        Take the binary logical OR of these two results and represent them in our modular basis.
  Examples:

  ++  ror 
  Comments:
  Description:
  Explanation:
        Creates a dry %gold gate which accepts a block size (an atom) and two other atoms.
        The result of cast to an atom.  'd' is expressed in the modular base as 'e'.
        Let 'f' be the binary exponential difference between 'a' and 'b'.
        Let 'g' be (c mod f).
        Left-shift 'e' by (sub f g) (The difference between 'f' and 'g') blocks of size 'b'.
        Right-shift 'e' by 'g' blocks of size 'b'.
        Take the binary logical OR of these two results and represent them in our modular basis.
  Examples:

  ++  sum 
  Comments:
        
  Description:
  Explanation:
  Examples:
  ++  sit 
  Comments:
        present
  Description:
        Produces the representation of any atom in the given bloq arithmetic.
  Explanation:
        Creates a dry %gold date that accepts an atom.
        Produces the trailing binary 'a'-block of the number.
  Examples:
        
section 2cG, floating point           

++  rlyd  
++  rlyh  
++  rlyq  
++  rlys  
++  ryld  
++  rylh  
++  rylq  
++  ryls  

section 2cH, urbit time               

++  year  
++  yore  
++  yell  
++  yule  
++  yall  
++  yawn  
++  yelp  
++  yo    
      ++  day 
      ++  era 
      ++  hor 
      ++  jes 
      ++  mit 
      ++  moh 
      ++  moy 
      ++  qad 
      ++  yer 

section 2cI, almost macros            
++  hard
  Comments:
        demand result type
  Description:
        Demands that a gate produce an argument of type 
  Explanation:
        Creates a vulanized wet gate which accepts any gate which accepts any noun and produces
        any noun.
        Creates a dry %gold gate which accepts any noun and casts the result to the 
        higher gate argument's icon.
        Prints "%hard" in the stack trace if the code below crashes.
        Let gol be the higher gate argument slammed with the lower arbitrary noun.
        Assert that the result's icon is equal to that of the lower arbitrary noun
        before producing said result.
  Examples:
        ~palryp-hocsyt/try=> ((hard (list)) (limo [1 2 3 ~]))
        ~[1 2 3]
++  soft
  Comments:
        politely demand
  Description:
  Explanation:
        Creates a vulanized wet gate which accepts any gate which accepts any noun and produces
        any noun.
        Creates a dry %gold gate which accepts any noun and casts the result to the 
        a unit of the higher gate argument's icon.
        Let gol be the higher gate argument slammed with the lower arbitrary noun.
        Build an unless-then-else statement on the result icon's being equal to that of 
        the lower arbitrary noun.
        If so, produce null.
        Else, produce the unit of the result.
  Examples:
        
chapter 2d, containers

section 2dA, sets     
                
++  apt       
  Comments:
        set invariant
  Description:
        Accepts any tree and produces a loobean indicting whether the tree is a set.
  Explanation:
        Creates a dry %gold gate which accepts a tree.
        Builds an if-then-else statement on "a is an atom."
        If so, produce true.
        Else, compute and produce the logical AND of:
        The if "l.a is an atom" then produce true, else (produce the logical AND of the
        v-order of n.a and n.l.a and the h-order of n.l.a and n.a) if-then-else statement.
        The if "r.a is an atom" then prodcue true, else (produce the logical AND of the 
        v-order of n.a and n.r.a and the h-roder of n.a and n.r.a) if-then-else statement.
        (==)  terminates the tall logical AND statement.
  Examples:
        
++  in        
  Comments:
        set engine
  Description:
        Container arm for set set operation arms.  The contained arms inherit it's sample set, 'a'. 
  Explanation:
        This arm is jetted.
        Creates a %gold trap with sample 'a', a set.
  Examples:

  +-  all
  Comments:
        logical AND
  Description:
        Accepts a gate which accepts any noun and produces a loobean.  Slams the gate with each member
        of set 'a', produce the logical AND of the transformed set.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts any gate which produces a loobean.
        Creates and kicks a dry %gold gate, casts the result to a loobean.
        Builds an if-then-else statement on "a is an atom."
        If so, produce true.
        Else, produce the logical AND of (b n.a) and the recursive calls of the trap with
        'a' replaced by 'l.a' and 'a' replaced by 'r.a'.
  Examples:

  +-  any
  Comments:
        logical OR
  Description:
        Accepts a gate which accepts any noun and produces a loobean.  Slams the gate with each member
        of set 'a', produce the logical OR of the transformed set.
  Explanation:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts any gate which produces a loobean.
        Creates and kicks a dry %gold gate, casts the result to a loobean.
        Builds an if-then-else statement on "a is an atom."
        If so, produce false.
        Else, produce the logical OR of (b n.a) and the recursive calls of the trap with
        'a' replaced by 'l.a' and 'a' replaced by 'r.a'.
  Examples:

  +-  del
  Comments:
        b without any a
  Description:
        Accepts any noun 'b' and removes it from the set 'a'.
  Explanations:
        This arm is jetted.
        Creates a vulcanized wet gate which accepts any noun.
        Creates and kicks a dry %gold gate, casts the result to the type of 'a'.
        Builds an if-then-else statement on "a is null."
        If so, produce null.
        Else, builds an unless-then-else on (b=n.a)
        If so, build an if-then-else statement by testing the h-order of 'b' and 'n.a'.
        If so, produce a the cell [n.a $(a l.a) r.a], where $(a l.a) is the recursive call of 
        the trap with 'a' replaced by the left 
  Examples:
  +-  dig
  Comments:
  Description:
  Explanations:
  Examples:
  +-  gas
  Comments:
        concatenate
  Description:
        Accepts a list 'b' with members of the same type as the set 'a' and produces 
        the union set of 'a' and 'b'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts a list of elements of the same type as 'a'.
        Creates and kicks a dry %gold trap whose result is cast to the type of 'a'.
        Builds an if-then-else statement on "b is an atom."
        If so, produce 'a'.
        Else, recursively call the trap with 'b' replaced by the tail of 'b' and the head of 'b'
        put into 'a'.
  Examples:
  +-  has
  +-  put
  +-  rep
  +-  tap
  +-  wyt

section 2dB, maps                     

++  ept       
++  ja        
  +-  get
  +-  add
++  ju        
  +-  get
  +-  has
  +-  put
++  by        
  +-  all
  +-  any
  +-  del
  +-  dig
  +-  gas
  +-  get
  +-  has
  +-  mar
  +-  put
  +-  rep
  +-  rib
  +-  run
  +-  tap
  +-  uni
  +-  wyt

section 2dC, queues                   

++  to        
  +-  bal
  +-  dep
  +-  gas
  +-  get
  +-  nap
  +-  put
  +-  tap
  +-  top

section 2dD, casual containers        

++  mo        
++  sa        
++  qu        

chapter 2e, miscellaneous libs

section 2eA, packing          
        
++  cue       
++  jam       
++  mat       
++  rub       

section 2eB, parsing (tracing)        

++  last  
++  lust  

section 2eC, parsing (custom rules)   

++  cold  
++  cook  
++  easy  
++  fail  
++  full  
++  funk  
++  here  
++  jest  
++  just  
++  knee  
++  mask  
++  next  
++  sear  
++  shim  
++  stag  
++  stet
++  stew
++  stir
++  stun  

section 2eD, parsing (combinators)    

++  bend  
++  comp
++  glue  
++  pfix  
++  plug  
++  pose  
++  sfix  

section 2eE, parsing (composers)      

++  bass
++  boss
++  ifix
++  more
++  most
++  plus  
++  slug
++  star

section 2eF, parsing (ascii)          

++  ace 
++  bar 
++  bas 
++  buc 
++  cab 
++  cen 
++  col 
++  com 
++  doq 
++  dot 
++  fas 
++  gal 
++  gar 
++  hax 
++  kel 
++  ker 
++  ket 
++  lus 
++  hep 
++  pel 
++  pam 
++  per 
++  pat 
++  sel 
++  sem 
++  ser 
++  sig 
++  soq 
++  tar 
++  tec 
++  tis 
++  wut 
++  zap 

section 2eG, parsing (whitespace)     

++  dog 
++  doh 
++  dun 
++  duz 
++  gah 
++  gap 
++  gaq 
++  gay 
++  vul 

section 2eH, parsing (idioms)         

++  alf 
++  aln 
++  alp 
++  bet 
++  bin 
++  but 
++  cit 
++  dem 
++  dit 
++  gul 
++  gon 
++  hex 
++  hig 
++  hit 
++  low 
++  mes 
++  nix 
++  nud 
++  poy 
++  qit 
++  qut 
++  sym
++  ven 
++  vit 

section 2eI, parsing (external)       

++  rash
++  rush
++  rust
++  scan

section 2eJ, formatting (basic text)  

++  cass
++  cuss
++  crip
++  mesc
++  runt
++  sand
++  sane
++  trim
++  trip
++  teff
++  turf
++  tuba
++  tufa
++  tuft
++  wack
++  wick
++  woad
++  wood

section 2eK, formatting (layout)      

++  re
  ++  ram
  ++  win
    ++  din 
    ++  fit 
    ++  rig
    ++  wig

section 2eL, formatting (path)        

++  ab
  ++  bix  
  ++  hif  
  ++  huf  
  ++  hyf  
  ++  pev  
  ++  pew  
  ++  piv  
  ++  piw  
  ++  qeb  
  ++  qex  
  ++  qib  
  ++  qix  
  ++  seb  
  ++  sed  
  ++  sev  
  ++  sew  
  ++  sex  
  ++  sib  
  ++  siq  
  ++  sid  
  ++  siv  
  ++  siw  
  ++  six  
  ++  sov  
  ++  sow  
  ++  sox  
  ++  ted  
  ++  tip  
  ++  tiq  
  ++  tid  
  ++  til  
  ++  urs  
  ++  urt  
  ++  voy  
  ++  vym  
  ++  vyn  
++  ag
  ++  ape  
  ++  bay  
  ++  bip  
  ++  dem  
  ++  dim  
  ++  dum  
  ++  fed  
  ++  hex  
  ++  lip  
  ++  qut  
  ++  sym  
  ++  tyq  
  ++  viz  
  ++  vum  
  ++  wiz  
++  co
      ++  rear
      ++  rent
      ++  rend
      ++  a-co
      ++  d-co
      ++  r-co
      ++  s-co
      ++  v-co
      ++  w-co
      ++  x-co
      ++  y-co
      ++  z-co
  ++  em-co
  ++  ox-co
  ++  ro-co
++  ne
  ++  d  
  ++  x  
  ++  v  
  ++  w  
++  mu
  ++  zag
  ++  zig
  ++  zug
++  so
  ++  bisk
  ++  crub
  ++  nuck
  ++  nusk
  ++  perd
  ++  royl
  ++  tash
  ++  twid
  ++  zust
++  scot 
++  scow 
++  slav  
++  slaw
++  slay
++  smyt

section 2eM, regular-expressions      

++  pars
++  nor
++  les  
++  lep  
++  alm  
++  alb  
++  mis  
++  anns 
++  mall
++  bets
++  ranc
++  flap 
++  rang
++  chun
++  seac
++  sead
++  sade
++  seap
++  cape
++  lower
++  upper
++  digit
++  print
++  graph
++  blank
++  space
++  cntrl
++  alpha
++  alnum
++  punct
++  wordc
++  white
++  xdigi
++  chad
++  escd
++  escp
++  unid
++  proc 
++  cont
++  abor
++  matc
++  chet
++  blak 
++  deep
++  rexp 
++  repg 

section 2eN, pseudo-cryptography      

++  un   
  ++  wre
  ++  wre
  ++  xaf
  ++  xar
  ++  zaf
  ++  zar
  ++  zyf
  ++  zyr

section 2eO, virtualization           

++  mack
++  mink
++  mock
++  mook
++  mang
++  mong
++  mung
++  mule 
++  mute 

section 2eP, diff          **noted as "(move me)" in source**

++  berk 
++  diff 
++  loss 
  ++  abet
  ++  hink
  ++  lonk
  ++  lune
  ++  merg
  ++  main
++  locz  
++  lore  
++  role  
++  lump  
++  lure  
++  limp  
++  hump  
++  husk  
++  lurk  
++  lusk  
  ++  abet
  ++  done
  ++  main
++  nude   
  ++  axes 
  ++  tred 

section 2eW, lite number theory           

++  egcd   
++  pram   
++  ramp   
++  fo     
  ++  dif
  ++  exp
  ++  fra
  ++  inv
  ++  pro
  ++  sit
  ++  sum
++  ga     
      ++  dif 
      ++  dub 
      ++  pro 
      ++  toe 
      ++  sit 
  ++  fra     
  ++  inv     
  ++  pow     
  ++  pro     

section 2eX, jetted crypto                

++  aesc      
  ++  en      
  ++  de      
++  ahem      
        ++  cipa 
          ++  co 
          ++  ix 
          ++  ro 
          ++  su 
    ++  pen      
      ++  co  
      ++  ix  
      ++  ro  
      ++  su  
    ++  pin   
      ++  co  
      ++  ix  
      ++  ro  
      ++  su  
    ++  mcol
    ++  pode  
    ++  sube  
  ++  be      
          ++  ankh
          ++  sark
          ++  srow
          ++  subs
  ++  ex      
  ++  ix      
++  curt      
        ++  cla
        ++  sqr
        ++  inv
        ++  cad
        ++  cub
++  ed         
    ++  norm  
    ++  xrec  
    ++  ward  
    ++  scam  
    ++  etch  
    ++  curv  
    ++  deco  
    ++  bb
  ++  puck    
  ++  suck    
  ++  sign    
  ++  veri    

section 2eY, SHA-256 

++  shad  
++  shaf  
++  shak  
++  sham  
++  shas  
++  shax  
++  shaw  
++  og    
  ++  rad 
  ++  raw 
++  shaz  
++  shal  
++  shan  

section 2eZ, OLD rendering

++  show  
  ++  shep
  ++  shop
++  at
  ++  r
  ++  rf 
  ++  rn 
  ++  rt 
  ++  rta
  ++  rtam
  ++  rub 
  ++  rud 
  ++  rum
  ++  rup
  ++  ruv
  ++  rux 

chapter 2f, Hoon proper

section 2fA, miscellaneous funs       

++  bull
++  cain  
++  cell
++  core
++  cube
++  face
++  bean  
++  flay
++  flee
++  foil
++  fork
++  cove
++  comb
++  cond
++  cons
++  fitz
++  flan
++  flip
++  flor
++  hike
++  hoax
++  hoof
++  jock
++  look
++  make
++  noah  
++  onan  
++  rain
++  ream
++  reck
++  seed
++  seem  
++  seer  
++  sell
++  pave
++  loot
++  slam
++  slim
++  slit
++  slym
++  slap
++  slop
++  skol
++  spat  
++  spuc
++  spec
++  spud  
++  slot
++  slum
++  stab
++  wash

section 2fB, macro expansion          

++  ah
  ++  blue
  ++  gray
  ++  puce
++  al
  ++  blah
  ++  home
  ++  bunt
  ++  clam
  ++  cloq
  ++  whip
++  ap
  ++  etch
  ++  feck
  ++  hock
  ++  open
  ++  rake
  ++  rusk

section 2fC, compilation proper       

++  ut
  ++  burn
  ++  busk
  ++  conk
  ++  crop
    ++  dext
    ++  sint
  ++  cool
  ++  dank
  ++  dart
  ++  deal
  ++  dial
  ++  dish
  ++  doge
  ++  dole
  ++  duck
  ++  dune
  ++  dunk
  ++  fino
  ++  fink
  ++  finq
  ++  fire
  ++  firm
  ++  fish
  ++  fuse
  ++  gain
  ++  hang
  ++  harp
  ++  lose
  ++  chip
  ++  heal
  ++  mint
    ++  nice
    ++  grow
  ++  moot
  ++  mull
    ++  both
    ++  nice
    ++  grow
    ++  bake
  ++  meet  
  ++  nest
    ++  cong
    ++  cram
    ++  dext
    ++  sint
  ++  park
  ++  peek
  ++  play
  ++  reco
  ++  repo
  ++  rest
  ++  seek
  ++  seep
  ++  sift
  ++  snub
  ++  tack
  ++  tock
  ++  wrap

section 2fD, grammar                  

++  vang
++  vast
  ++  gash  
  ++  gasp  
  ++  glam  
  ++  hasp  
  ++  mota  
  ++  plex
  ++  pray
  ++  prey
  ++  phax
  ++  posh
  ++  poof
  ++  poon
  ++  poor
  ++  porc
  ++  rump
  ++  rood
  ++  rupl
  ++  sail 
    ++  ape
    ++  amp
    ++  bam
    ++  bat
    ++  bet
    ++  fry
    ++  hag
    ++  hig
    ++  hog
    ++  hoy
    ++  hul
    ++  jaw
    ++  lif
    ++  luf
    ++  nal
    ++  nol
    ++  nol
    ++  nup
    ++  pab
    ++  ped
    ++  pep
    ++  puv
    ++  rab
    ++  sag
  ++  scat
  ++  soil
  ++  sump 
  ++  noil
    ++  toad
    ++  rung
    ++  gunk
    ++  muck
    ++  butt
    ++  loaf
    ++  lobe
    ++  exqa
    ++  exqb
    ++  exqc
    ++  exqd
    ++  exqe
  ++  norm
    ++  boog
    ++  wisp
    ++  toad
    ++  rune
    ++  glop
    ++  gunk
    ++  butt
    ++  ulva
    ++  hank
    ++  loaf
    ++  lobe
    ++  mash
    ++  muck
    ++  teak
    ++  race
    ++  rack
    ++  rick
    ++  expa
    ++  expb
    ++  expc
    ++  expd
    ++  expe
    ++  expf
    ++  expg
    ++  exph
    ++  expi
    ++  expj
    ++  expk
    ++  expm
    ++  expn
    ++  expo
    ++  expp
    ++  expq
    ++  expr
    ++  exps
    ++  expt
    ++  expu
    ++  expv
    ++  expw
    ++  expx
    ++  expy
    ++  expz
    ++  hina
    ++  hinb
    ++  hinc
    ++  hind
    ++  hine
    ++  hinf
    ++  hing
    ++  bonk
    ++  bont
    ++  bony
    ++  bonz
  ++  lung
  ++  long
  ++  lobo
  ++  loon
  ++  lute
  ++  rope
  ++  tall
  ++  wide
  ++  hill
  ++  howl
  ++  toil
  ++  wart
++  vest
++  vice

volume 3, Arvo models and skeleton

++  arch  
++  bead  
++  care  
++  case  
++  desk  
++  cage  
++  chop  
++  curd  
++  disk  
++  duct  
++  gene  
++  glob  
++  herd  
++  hilt  
++  hypo  
++  khan  
++  lens    
      ++  v 
      ++  w 
      ++  x 
      ++  y 
      ++  z 
++  logo 
++  lode 
++  mark 
++  mill 
++  milt 
++  monk 
++  mold 
++  muse 
++  mosh 
++  move 
++  ovum 
++  pane 
++  pone 
++  ship 
++  sled 
++  slut 
++  vile 
++  wire 
++  slod 
++  slub 

section 3bE, Arvo core                

++  vent 
  ++  ruck   
  ++  wink   
    ++  doze
    ++  sike
    ++  souk
    ++  sunk
    ++  song
    ++  spuc
    ++  sump
    ++  said
    ++  scry
    ++  soar
    ++  swim
++  vint    
++  viol    
++  is      
  ++  beck
  ++  dink  
  ++  dint  
  ++  doos  
  ++  hurl  
  ++  race  
  ++  fire  
  ++  jack  
  ++  kick  

Postface

    ++  come
    ++  keep
    ++  load
    ++  peek
    ++  poke
    ++  wish
++  come    
++  keep    
++  load    
++  peek    
++  poke    
++  vega    
++  veer    
++  wish    
