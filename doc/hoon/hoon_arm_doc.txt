Foreword
Nock

Hoon
Preface

volume 0, version stub
++  stub  

volume 1, Hoon models
++  abel  
++  axis  
++  also  
++  base  
++  beer  
++  beet  
++  bloq  
++  calf  
++  char  
++  chum  
++  claw  
++  coat  
++  coil  
++  coin  
++  cord  
++  date  
++  dime  
++  dram  
++  each  
++  edge  
++  foot  
++  gear  
++  hair  
++  hapt  
++  like  
++  limb  
++  line  
++  list  
++  mane  
++  mano  
++  manx  
++  marl  
++  mars  
++  mart  
++  marx  
++  metl  
++  null  
++  odor  
++  tarp  
++  time  
++  tree  
++  nail  
++  numb  
++  pair  
++  pass  
++  path  
++  pint  
++  port  
++  post  
++  prop  
++  qual  
++  rege  
++  ring  
++  rule  
++  span  
++  spot  
++  tank  
++  tape  
++  term  
++  tiki  
++  tile  
++  toga  
++  trel  
++  tuna  
++  twig  
++  tine  
++  tusk  
++  tyre  
++  tyke  
++  tram  
++  tone  

++  nock  
++  toon  
++  tune  
++  twin  
++  type  
++  typo  
++  udal  
++  udon  
++  umph  
++  unce  
++  unit  
++  upas  
++  urge  
++  vase  
++  vise  
++  wall  
++  wain  
++  wing  
++  wine  
++  woof  
++  wonk  
++  map  
++  qeu  
++  set  
++  jar  
++  jug  

volume 2, Hoon libraries and compiler

chapter 2a, basic unsigned math

++  add 
  Comment:
        add
  Description:
        Sums two numbers.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        It must yield an atom.
        Check if a is equal to 0.
        Builds an if-then-else statement on a=0.  If so, produce 'b'.
        Else, the arm is called again with a replaced by (dec a) and b by +(b).
  Examples:
        ~palryp-hocsyt/try=> (add 2 2)
        4
        ---
        ~palryp-hocsyt/try=> (add 1 1.000.000)
        1.000.001
        ---
        ~palryp-hocsyt/try=> (add 1.333 (mul 2 2))
        1.337
++  cap
  Comment:
        tree head
  Description:
        Yields whether an atom is in the head or tail of a noun.
  Explanation:
        This arm is jetted.
        It must yield either %2 or %3.
        Selects a case below for the actual type of a.
        Yield %2 if a is %2.
        %3 if it is %3.
        Fail if a is either %0 or %1.
        Else, call cap recursively with a replaced by a/2.
        The case statement is closed.
  Examples:
        ~palryp-hocsyt/try=> (cap 4)
        %2
        ---
        ~palryp-hocsyt/try=> (cap 6)
        %3
        ---
        ~palryp-hocsyt/try=> (cap (add 10 9))
        %2
++  dec  
  Comment:
        decrement
  Description:
        Decrements a number - Subtracts one.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        When the following code crashes, print "%decrement-underflow" in the stack trace.
        Produce the next gate asserting a is not 0.
        Let b be 0.
        Creates a dry %gold trap which yields an atom.
        Builds an if-then-else statement on "a is equal to the increment of b."
        If so, produce b.
        Else, recursively call dec by replacing the argument b with the increment of b.
  Examples:
        ~palryp-hocsyt/try=> (dec 7)
        6
        ---
        ~palryp-hocsyt/try=> (dec 0)
        ! decrement-underflow
        ! exit
++  div  
  Comment:
        divide
  Description:
        Divides one number by another.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which  accepts two atoms.
        It must yield an atom.
        When the following code crashes, print "div" in the stack trace.
        Produce the next trap asserting that b is not 0.
        Let 'c' be 0.
        Create a dry %gold trap
        Builds an if-then-else statement on whether a is less than b.
        If so, produce c.
        Else, recursively call with a replaced by the difference of a and b and c by 
        the increment of c.
  Examples:
        ~palryp-hocsyt/try=> (div 4 2)
        2
        ---
        ~palryp-hocsyt/try=> (div 17 8)
        2
        ---
        ~palryp-hocsyt/try=> (div 20 30)
        0 
++  fac  
  Comment:
        factorial
  Description:
        Produces the factorial of a number n, n!.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        It must yield an atom.
        Builds an if-then-else statement on whether a is equal to 0.
        If so, produce 1.
        Else, multiply a by the recursive call of factorial with the decrement of a.
  Examples:
        ~palryp-hocsyt/try=> (fac 3)
        6
        ---
        ~palryp-hocsyt/try=> (fac 0)
        1
        ---
        ~palryp-hocsyt/try=> (fac 11)
        39.916.800
++  gte
  Comment:
        greater than or equal
  Description:
        Produces the loobean a>=b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Yield false if a is less than b, true else.
  Examples:
        ~palryp-hocsyt/try=> (gte 100 10)
        %.y
        ---
        ~palryp-hocsyt/try=> (gte 4 4)
        %.y
        ---
        ~palryp-hocsyt/try=> (gte 3 4)
        %.n
++  gth
  Comment:
        greater than
  Description:
        Produces the loobean a>b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Yield false if a is less than or equal to b, true else.
  Examples:
        ~ronrem-lonsem/try=> (gth 4 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (gth 5 4)
        %.y
        ---
        ~ronrem-lonsem/try=> (gth 5 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (gth 0 0)
        %.n
++  lte  
  Comment:
        less than or equal to
  Description:
        Produces the loobean a<=b.
  Explanation:
        This is a jetted arm.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Use logical OR to yield true if either a=b or (lth a b) is true.
  Examples:
        ~ronrem-lonsem/try=> (lte 4 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lte 5 4)
        %.n
        ---
        ~ronrem-lonsem/try=> (lte 5 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lte 0 0)
        %.y
++  lth  
  Comment:
        less than
  Description:
        Produces the loobean a<b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce a loobean.
        Use logical AND, thus immediately producing false if a=b.
        Then, create and kick a dry %gold trap which produces true on a=0,
        or false if a!=0 and b=0.
        If none of these cases are met, recursively call lth with both a and b decremented.
  Examples:
        ~ronrem-lonsem/try=> (lth 4 5)
        %.y
        ---
        ~ronrem-lonsem/try=> (lth 5 4)
        %.n
        ---
        ~ronrem-lonsem/try=> (lth 5 5)
        %.n
        ---
        ~ronrem-lonsem/try=> (lth 5 0)
        %.n
++  mas  
  Comment:
        tree body
  Description:
       Produces the axis of a within the head or the tail. 
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts an atom.
        Must produce an atom.
        Selects a case below for the actual type of a.
        Exit if a is 1.
        Produce 1 if a is either 2 or 3.
        Else, sum the modulus of a and 2 with the 2 multiplied by the recursive call of 
        mas with a replaced by a/2.
  Examples:
        1 ~ronrem-lonsem/try=> (mas 3)
        1
        ---
        ~ronrem-lonsem/try=> (mas 4)
        2
        ---
        ~ronrem-lonsem/try=> (mas 5)
        3
        ---
        ~ronrem-lonsem/try=> (mas 6)
        2
        ---
        ~ronrem-lonsem/try=> (mas 7)
        3
        ---
        ~ronrem-lonsem/try=> (mas 8)
        4
        ---
        ~ronrem-lonsem/try=> (mas 0)
        ! exit
        ---
        ~ronrem-lonsem/try=> (mas 1)
        ! exit
++  max  
  Comment:
        maximum
  Description:
        Yields the larger of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Builds an if-else-then statement on a>b.
        If so, produce a.
        Else, produce b.
  Examples:
        ~palryp-hocsyt/try=> (max 10 100)
        100
        ---
        ~palryp-hocsyt/try=> (max 10.443 9)
        10.443
        ---
        ~palryp-hocsyt/try=> (max 0 1)
        1
++  min  
  Comment:
        minimum
  Description:
        Yields the smaller of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Builds an if-then-else statement on a<b.
        If so, produce a.
        Else, produce b.
  Examples:
        ~palryp-hocsyt/try=> (min 10 100)
        10
        ---
        ~palryp-hocsyt/try=> (min 10.443 9)
        9
        ---
        ~palryp-hocsyt/try=> (min 0 1)
        0
++  mod  
  Comment:
        remainder
  Description:
        Yields the modulus of (a mod b).
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Assert that b is not 0 before producing the below.
        Produce the difference of a and the product of b times a/b.
  Examples:
++  mul  
  Comment:
        multiply
  Description:
        Multiplies two numbers.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Let 'c' be 0.
        Create and kick a dry %gold trap.
        Builds an if-then-else statement on a=0.
        If so, produce c.
        Else, recursively call multiply with a replaced by decremented a and c replaced by b+c.
  Examples:
++  peg  
  Comment:
        tree connect
  Description:
        Produces the axis of b within the axis of a.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Must produce an atom.
        Select a case below for the actual type of b.
        Yield a on b=1.
        Yield (mul a 2) on b=2.
        Yield the increment of (mul a 2) on b=3.
        Else, sum (b mod 2) with the product of 2 and the recursive call to peg with b replaced by b/2.
  Examples:
        ~ronrem-lonsem/try=> (mul 5 3)
        15
        ---
        ~ronrem-lonsem/try=> (mul 1 0)
        0
++  sub  
  Comment:
        subtract
  Description:
        Accepts two atoms, a and b, and produces a-b.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        When the following code crashes, print "%subtract-underflow" in the stack trace.
        Must produce an atom.
        Builds an if-then-else statement on b=0.
        If so, produce a.
        Else, produce the recursive call of subtract with a and b replaced by their respective decrements.
  Examples:
        ~ronrem-lonsem/try=> (sub 10 5)
        5
        ---
        ~ronrem-lonsem/try=> (sub 243 44)
        199
        ---
        ~ronrem-lonsem/try=> (sub 5 0)
        5
        ---
        ~ronrem-lonsem/try=> (sub 0 5)
        ! subtract-underflow
        ! exit

chapter 2b, basic containers

Section 2bA, units                    

++  biff 
  Comment:
        apply
  Description:
        Accepts a unit 'a' and a gate 'b' which produces a unit from the type of u.a, slamming the gate 
        with the value of a when a isn't null and producing ~ when it is.
  Explanation:
        Creates a vulanixed wet gate with a sample which accepts a unit and a $+(* (unit)) tiled gate.
        Builds an if-then-else statement on "a is null."
        If so, produce null.
        Else, produce b slammed with u.a.
  Examples:
        ~palryp-hocsyt/try=> (biff (some 5) |=(a=@ (some (add a 2))))
        [~ u=7]
        ---
        ~palryp-hocsyt/try=> (biff ~ |=(a=@ (some (add a 2))))
        ~
++  bind 
  Comment:
        argue
  Description:
        Accepts a unit 'a' and a gate 'b', producing a unit with value (b u.a) or, when a is null, null.
  Explanation:
        Creates a wet %gold gate with a sample which accepts a unit and a gate.
        Builds an if-then-else statement on "a is null."
        If so, produce null.
        Else, produce the a unit with value (b u.a), gate 'b' slammed with u.a.
  Examples:
        ~talsur-todres/try=> (bind ((unit ,@) [~ 97]) ,@t)
        [~ `a`]
        ---
        ~talsur-todres/try=> =a |=(a=@ (add a 1))
        ~talsur-todres/try=> (bind ((unit ,@) [~ 2]) a)
        [~ 3]
++  clap 
  Comment:
        combine
  Description:
        Applies a binary operation to the values of two units, producing the product as a unit.
  Explanation:
        Creates a wet %gold gate with a sample which accepts two units and a gate.
        Builds an if-then-else statment on "a is null."
        If so, produce b.
        Else, build an if-then-else statement on "b is null."
        If so, produce a.
        Else, produce the unit with value (c u.a u.b)
  Examples:
        ~palryp-hocsyt/try=> =u ((unit ,@t) [~ 'a'])
        ~palryp-hocsyt/try=> =v ((unit ,@t) [~ 'b'])
        ~palryp-hocsyt/try=> (clap u v |=([a=@t b=@t] (welp (trip a) (trip b))))
        [~ u="ab"]
        ---
        ~talsur-todres/try=> =a ((unit ,@u) [~ 1])
        ~talsur-todres/try=> =b ((unit ,@u) [~ 2])
        ~talsur-todres/try=> =c |=([a=@ b=@] (add a b))
        ~talsur-todres/try=> (clap a b c)
        [~ 3]
++  drop 
  Comment:
        enlist
  Description:
        Accepts a unit and produces the list [u.a ~] or null when the unit is null.
  Explanation:
        Creates a wet %gold gate with a sample which accepts a unit.
        Builds an if-then-else statement on "a is null."
        If so, produces null.
        Else, produce the list [u.a ~].
  Examples:
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> (drop a)
        [i=97 t=~]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~])
        ~divreg-misdef/try=> (drop a)
        ~
++  fall 
  Comment:
        default
  Description:
         a default value 'b' for the unit 'a' when it is null.
  Explanation:
        Creates a wet %gold gate with a sample which accepts a unit and any noun.
        Produces b if a is null and u.a if it is not.
  Examples:
        ~talsur-todres/try=> (fall ~ `a`)
        `a`
        ---
        ~talsur-todres/try=> (fall [~ u=0] `a`)
        0
++  mate 
  Comment:
        choose
  Description:
        Produces the unit 'a' or 'b' which is not null and crashes with error "mate" if they are equal.
  Explanation:
        Creates a wet %gold gate with a sample which accepts a two units.
        Builds an if-then-else statement on "b is null."
        If so, produce a.
        Else, build an if-then-else statement on "a is null."
        If so, produce b.
        Else, build an if-else-then statement on  u.a=u.b.  Crash on "mate" if false, produce a if true.
  Examples:
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~ 97])
        ~divreg-misdef/try=> (mate a b)
        [~ 97]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~])
        ~divreg-misdef/try=> (mate a b)
        [~ 97]
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~ 97])
        ~divreg-misdef/try=> =b ((unit ,@) [~ 98])
        ~divreg-misdef/try=> (mate a b)
        ! 'mate'
        ! exit
++  need 
  Comment:
        demand
  Description:
        Retrieves the value from a unit, crashing if the unit is null.
  Explanation:
        Creates a wet %gold gate with a sample which accepts a unit.
        Builds an if-then-else statement on "a is an atom."
        If so, crash.
        Else, produce u.a from the unit a.
  Examples:
        ~divreg-misdef/try=> =a ((unit ,[@t @t]) [~ [`a` ' b']])
        ~divreg-misdef/try=> (need a)
        [`a` ' b']
        ---
        ~divreg-misdef/try=> =a ((unit ,@) [~])
        ~divreg-misdef/try=> (need a)
        ! exit
++  some 
  Comment:
        lift
  Description:
        Casts any noun a to its unit, [~ a].
  Explanation:
        Creates a wet %gold gate with a sample which accepts any noun.
        Produces the tuple [~ u=a], the unit of value a.
  Examples:
        ~divreg-misdef/try=> (some [`a` `b`])
        [~ u=[`a` `b`]]
        ---
        ~divreg-misdef/try=> (some &)
        [~ u=%.y]

Section 2bB, lists                    

++  flop 
  Comment:
        reverse
  Description:
        Produces the list 'a' with the elements reversed.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate with a sample which accepts a single list.
        'a' is then replaced with (homo a) and used as the subject for the code below (=>).
        The type of the result must be the same as a, our argument list.
        Let b be a list of the type of the icon of a, as it is bunted.
        Create and kick a dry %gold trap
        Builds an if-then-else statement on "a is an atom."
        If so, produce b.
        Else, recursively call flop with a replaced by it's tail and b replaced by [i.a b], where
        i.a is the head of a.
  Examples:
        ~palryp-hocsyt/try=> =lyst (limo [1 2 3 4 ~])
        ~palryp-hocsyt/try=> lyst
        [i=1 t=[i=2 t=[i=3 t=[i=4 t=~]]]]
        ~palryp-hocsyt/try=> (flop lyst)
        ~[4 3 2 1]
        ---
        ~palryp-hocsyt/try=> (flop (limo [1 'a' 2 'b' (some 10) ~]))
        ~[[~ u=10] 98 2 97 1]
++  homo 
  Comment:
        homogenize
  Description:
        Homogenizes a lists' type information.
  Explanation:
        Creates a wet %gold gate with a sample which accepts a single list.
        Makes the type of the result the type of the product of the code below (^+).
        The subject of the arm ($) is then the product of the barcen statement below (=<).
        Creates a %gold core (|%) and the arm '+-  $'.
        XXX BLACK BOX, ABANDON ALL HOPE YE WHO ENTER HERE XXX
        Terminates the core.
        Produces list a.
  Examples:
        ~palryp-hocsyt/try=> lyst
        [i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]
        ~palryp-hocsyt/try=> (homo lyst)
        ~[1 97 2 98 [~ u=10]]
        ---
        ~palryp-hocsyt/try=> =a (limo [1 2 3 ~])
        ~palryp-hocsyt/try=> a
        [i=1 t=[i=2 t=[i=3 t=~]]]
        ~palryp-hocsyt/try=> (homo a)
        ~[1 2 3]
++  limo 
  Comment:
        listify
  Description:
        Produces a list from any null-terminated tuple.
  Explanation:
        Creates a wet %gold gate with a sample which accepts a single list.
        Makes the type of the result the type of the product of the code below (^+).
        The subject of the arm ($) is then the product of the barcen statement below (=<).
        Creates a %gold core (|%) and the arm '+-  $'.
        XXX BLACK BOX, ABANDON ALL HOPE YE WHO ENTER HERE XXX
        Terminates the core.
        Produces list a.
  Examples:
        ~palryp-hocsyt/try=> (limo [1 'a' 2 'b' (some 10) ~])
        [i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]
        ---
        ~palryp-hocsyt/try=> (limo [`a` `b` ~])
        [i=`a` t=[i=`b` t=~]]
        ---
        ~palryp-hocsyt/try=> (limo [2 1 ~])
        [i=2 t=[i=1 t=~]]
++  lent 
  Comment:
        length
  Description:
        Produces the atomic length of any list.
  Explanation:
        This is a jetted arm.
        Creates a dry %gold gate with a sample which accpets a single list.
        Must produce an atom.
        Let b be 0.
        Creates and kicks a dry %gold trap.
        Builds an if-then-else statement on "a is an atom."  If so, produces b.
        Else, recursively calls length with the list set to the tail of a and the accumulator, b, incremented.
  Examples:
        ~palryp-hocsyt/try=> (lent (limo [1 2 3 4 ~]))
        4
        ---
        ~palryp-hocsyt/try=> (lent (limo [1 'a' 2 'b' (some 10) ~]))
        5
++  levy
  Comment:
       all of
  Description:
        Applies the loobean gate 'b' to every element of the list 'a', producing the logical AND of all the results.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate with a sample which accepts a list and a gate with a sample of any noun
        and produces a loobean.
        Then, a dry %gold trap is created and kicked.  It must produce a loobean.
        Builds an if-then-else statement on "a is an atom."
        If so, produce true.
        Else, build an if-then-else statement on (b i.a)
        If so, then recursively call levy with a replaced by the tail of a.
        Else, produce no.
  Examples:
        ~palryp-hocsyt/try=> =b |=(a=@ (gte a 1))
        ~palryp-hocsyt/try=> (levy (limo [0 1 2 1 ~]) b)
        %.n
        ---
        ~palryp-hocsyt/try=> =b |=(a=@ (gte a 0))
        ~palryp-hocsyt/try=> (levy (limo [0 1 2 1 ~]) b)
        %.y        
++  lien 
  Comment:
        some of
  Description:
        Applies the loobean gate 'b' to every element of the list 'a', producing the logical OR of all the results.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate with a sample which accepts a list and a gate with a sample of any noun
        and produces a loobean.
        Then, a dry %gold trap is created and kicked.  It must produce a loobean.
        Builds an if-then-else gate on "a is null."  If so, produce false.
        Else, build an if-then-else gate on (b i.a).  If so, produce true.
        Else, recursively call lien with a replaced by the tail of a (t.a).
  Examples:
        ~palryp-hocsyt/try=> =a |=(a=@ (gte a 1))
        ~palryp-hocsyt/try=> (lien (limo [0 1 2 1 ~]) a)
        %.y
        ---
        ~palryp-hocsyt/try=> =a |=(a=@ (gte a 3))
        ~palryp-hocsyt/try=> (lien (limo [0 1 2 1 ~]) a)
        %.n
++  reel 
  Comment:
        right fold
  Description:
        Accepts a list 'a' and a gate 'b' which accepts two nouns, then folds (recursively calls 'b' across) the 
        list right to left, producing a value of the list element's type.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate with a sample which accepts a list and a trap which accepts two nouns.
        A dry %gold trap is created and kicked.  It must produce the type of the list's elements.
        Builds a if-then-else statement on "a is an atom."
        If so, produce q.b.
        Else, recursivley call b with the head of a and the rest of a replaced by the tail of a.
  Examples:     
        ~palryp-hocsyt/try=> =sum =|([p=@ q=@] |.((add p q)))
        ~palryp-hocsyt/try=> (reel (limo [1 2 3 4 5 ~]) sum)
        15
        ---
        ~palryp-hocsyt/try=> =a =|([p=@ q=@] |.((sub p q)))
        ~palryp-hocsyt/try=> (reel (limo [6 3 1 ~]) a)
        4
        ---
        ~palryp-hocsyt/try=> (reel (limo [3 6 1 ~]) a)
        ! subtract-underflow
        ! exit
++  roll 
  Comment:
        left fold
  Description:
        Accepts a list 'a' and a gate 'b' which accepts two nouns, then folds (recursively calls 'b' across) the
        list left to right, producing a value of the list of the element's type.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate with a sample which accepts a list and a trap which accepts two nouns.
        A dry %gold trap is then created and kicked.  It must produce the type of the list's elements.
        Builds an if-then-else statement on "a is an atom."
        If so, produce q.b.
        Else, recursively call roll with a replaced by the tail of a and b by the recursive call of b
        with q replaced by (b i.a q.b).
  Examples:
        ~barred-tidset/try=> =a =|([p=@ q=@] |.((sub p q)))
        ~barred-tidset/try=> (roll (limo [1 2 3 ~]) a)
        2
        ---
        ~barred-tidset/try=> (roll (limo [3 6 3 ~]) a)
        0
++  skid 
  Comment:
       separate
  Description:
        Accepts a list and a gate which takes any noun and produces a loobean.  Produces two lists, one who's elements
        produce true and one who's produce false by slamming the gate with them.
  Explanation:
        Creates a wet %gold gate with a sample which accepts a list and a gate which accepts any noun and 
        produces a loobean.
        Creates and kicks a dry %gold trap.  It must produce a tuple of two lists af a's type
        Builds an if-then-else statement on "a is null"  If so, produce a tuple of two nulls.
        Else, let 'c' be the recursive call of skid with a replaced by the tail of a.
        Builds an if-then-else statement on (b i.a).  If so, produce [[i.a p.c] q.c].
        Else, produce [p.c [i.a q.c]] where p.c and q.c are the separate list results of c.
  Examples:
        ~dovryp-toblug/try=> =a |=(a=@ (gth a 1))
        ~dovryp-toblug/try=> (skid (limo [0 1 2 3 ~]) a)
        [p=[i=2 t=[i=3 t=~]] q=[i=0 t=[i=1 t=~]]]
++  skim 
  Comment:
        only
  Description:
        Accepts a list 'a' and a gate 'b' which takes any noun and produces loobean.  
        Produces the sublist of 'a' whose elements produce true by slamming the gate with them.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate with a sample which accepts a list and a gate which accepts any noun and 
        produces a loobean.
        Creates and kicks a dry %gold trap.
        Which must produce a list of a's type.
        Builds an if-then-else statement on "a is an atom."
        If so, prodoce null.
        Else, build an if-then-else statement on (b i.a).  If so, produce [i.a $(a t.a)], where $(a t.a) is the recursive
        call of skim with a replaced by the tail of a.
        Else, produce $(a t.a).
  Examples:
        ~dovryp-toblug/try=> =a |=(a=@ (gth a 1))
        ~dovryp-toblug/try=> (skim (limo [0 1 2 3 ~]) a)
        [i=2 t=[i=3 t=~]]
++  skip 
  Comment:
        except
  Description:
        Accepts a 'a' list and a gate 'b' which takes any noun and produces a loobean.
        Produces the sublist of 'a' whose elments produce false by slamming the gate with them.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate with a sample which accepts a list and a gate which accepts any noun and 
        produces a loobean.
        Creates and kicks a dry %gold trap.
        Which must produce a list of a's type.
        Builds an if-then-else statement on "a is an atom."
        If so, produce null.
        Else build na if-then-else statement on (b i.a).  If so, produce the recursive call of skip with a replacd by
        the tail of a.
        Else, produce [i.a $(a t.a)].
  Examples:
        ~dovryp-toblug/try=> =a |=(a=@ (gth a 1))
        ~dovryp-toblug/try=> (skip (limo [0 1 2 3 ~]) a)
        [i=0 t=[i=1 t=~]]
++  scag 
  Comment:
        prefix
  Description:
        Accepts an atom 'n' and list 'b',  producing the first n elements at the front of the list.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate which accepts an atom and a list.
        A dry %gold trap is created and kicked.  It must produce a list of the same type as 'b'.
        Builds an if-then-else statement on the logical OR statement (a=0 or b is in null).
        If so, produce null.
        Else, produce [i.b $(b t.b, a (dec a))] where 'i.b' is the head of 'b' and $(b t.b, a (dec a))
        is the recursive call of scag with 'b' replaced by the tail of 'b' and 'a' decremented.
  Examples:
        ~palryp-hocsyt/try=> (scag 2 (limo [0 1 2 3 ~]))
        [i=0 t=[i=1 t=~]]
        ---
        ~palryp-hocsyt/try=> (scag 10 (limo [1 2 3 4 ~]))
        [i=1 t=[i=2 t=[i=3 t=[i=4 t=~]]]]
++  slag 
  Comment:
        suffix
  Description:
        Accepts an atom 'n' and a list 'b', producing the last n elemnents at the back of the list.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate which accepts an atom and a list.
        A dry %gold trap is created and kicked.  It must produce a list of the same type as 'b'.
        Builds an if-then-else statement on a=0.
        If so, produce 'b'.
        Else, build an if-then-else statement on "b is an atom."
        If so, produce null.
        Else, call slag recursively with b replaced by the tail of b, a replaced by the decrement of a.
  Examples:
        ~palryp-hocsyt/try=> (slag 2 (limo [0 1 2 3 ~]))
        [i=2 t=[i=3 t=~]] 
        ---
        ~palryp-hocsyt/try=> (slag 2 (limo [1 2 3 4 ~]))
        [i=3 t=[i=4 t=~]]
++  snag 
  Comment:
        index
  Description:
        Accepts an atom and a list, producing the element at the index of the atom in the list and failing is the list
        is null.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate which accepts an atom and a list.
        A dry %gold trap is created and kicked.
        Builds an if-then-else statement on "b is null."
        If so, fail with "snag-fail" in the stack trace.
        Else, build an if-then-else statement on a=0.
        If so, produce the head of 'b'.
        Else, recursively call snag with 'b' replaced by the tail of 'b' and 'a' decremented.
  Examples:
        ~palryp-hocsyt/try=> (snag 2 (limo [3 2 1 0 ~]))
        1
        ---
        ~palryp-hocsyt/try=> (snag 4 (limo [1 2 3 4 5 6 7 8 ~]))
        5
++  sort 
  Comment:
        quicksort
  Description:
        Accepts a list and a gate with a sample which accepts two nouns and produces a loobean.  'sort' then produces a 
        list of the elements of 'a' sorted according to 'b'.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate with a sample which accepts a list and a gate which accepts two nouns and
        produces a loobean.
        Homogenizes the list and makes it the subject of the following code, casting the following to the
        homogenized list type.
        Creates and kicks dry %gold trap.  It must produce a list of a's type.
        Builds an if-then-else statement on "a is null."  If so, produce null.
        Slam the weld gate with the q and r below.
        The q and r are then defined to be the recursive call of the trap with the skim of the tail by our sort gate.
        For q, it skims by (b c i.a).  For r, by !(b c i.a).
        r is first cast to the type of the tail of 'a' and produced as a tuple behind the head of 'a'.
  Examples:
        ~dovryp-toblug/try=> =a =|([p=@ q=@] |.((gth p q)))
        ~dovryp-toblug/try=> (sort (limo [0 1 2 3 ~]) a)
        ~[3 2 1 0]
++  swag 
  Comment:
        infix
  Description:
        A range in a list - Produces the values in list 'c' starting at index 'a' and spanning 'b' elements
        more than that.
  Explanation:
        Creates a wet %gold gate with a sample which gate which accepts a tuple of atoms and a list 'c'.
        The last 'a' elements in 'c' are selected by slag.  Then the first 'b' elements of 
        those last elements are selected and produced by scag.
  Examples:
        ~palryp-hocsyt/try=> (swag [0 5] (limo [1 2 3 4 5 6 7 8 9 10 ~]))
        [i=1 t=[i=2 t=[i=3 t=[i=4 t=[i=5 t=~]]]]]
        ---
        ~palryp-hocsyt/try=> (swag [3 5] (limo [1 2 3 4 5 6 7 8 9 10 ~]))
        [i=4 t=[i=5 t=[i=6 t=[i=7 t=[i=8 t=~]]]]]
        ---
        ~palryp-hocsyt/try=> (swag [1 2] (limo [1 2 3 ~]))
        [i=2 t=[i=3 t=~]] 
++  turn 
  Comment:
        transform
  Description:
        Accepts a list and a gate.  Produces the list with the gate applied to each element of the original list.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate which accepts a list and a gate.
        Creates and kicks a dry %gold trap.
        Builds an if-then-else statement on "a is an atom."
        If so, produce null.
        Else, produce the tuple with head (b i.a) and tail that is turn applied recursively to the tail of 'a'.
  Examples:
        ~dovryp-toblug/try=> (turn (limo [104 111 111 110 ~]) ,@t)
        <|h o o n|>
++  weld 
  Comment:
        concatenate
  Description:
        Concatenates two lists.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate which accepts two lists.
        Homogenizes both lists and makes them the subject of the following code.
        A dry %gold trap is created and kicked.  It must produce the type of list 'b'.
        Builds an if-then-else statement on "a is null."  If so, produce 'b'.
        Else, produce the tuple [i.a $(a t.a)].  'i.a' is the head of 'a', $(a t.a) the recursive call of weld
        with 'a' replaced by the tail of a.
  Examples:
        ~palryp-hocsyt/try=> (weld (limo [1 2 3 ~]) (limo [4 5 6 ~]))
        ~[1 2 3 4 5 6]
        ~palryp-hocsyt/try=> (weld "foo" "bar")
        ~[~~f ~~o ~~o ~~b ~~a ~~r]
++  welp 
  Comment:
        perfect weld
  Description:
        Concatenates two lists without losing their type information to homogenization.
        Produces a tape when passed two tapes.
  Explanation:
        XXX DON'T WORRY ABOUT HOW THIS WORKS, IT IS A PERPETUAL MIYSTERY TO US ALL. XXX
  Examples:
        ~palryp-hocsyt/try=> (welp "foo" "bar")
        "foobar"
++  wild 
  Comment:
        concatenate
  Description:
        Concatenates two lists without casting the product back to a list.
  Explanation:
        Creates a wet %gold gate with a sample which accepts two lists.
        Homogenizes both lists and makes them the subject of the following code.
        A dry %gold gate is created and kicked.
        Builds an if-then-else statement on "a is null."  If so, produce 'b'.
        Else, produce the tuple with head (b i.a) and tail that is turn applied recursively to the tail of 'a'.
  Examples:
        ~palryp-hocsyt/try=> =norm (limo [1 2 3 4 5 ~])
        ~palryp-hocsyt/try=> =norm2 (limo [6 7 8 ~])
        ~palryp-hocsyt/try=> (wild norm norm2)
        ~[1 2 3 4 5 6 7 8]
        ---
        ~palryp-hocsyt/try=> (wild "foo" "bar")
        ~[~~f ~~o ~~o ~~b ~~a ~~r]
        ---
        ~palryp-hocsyt/try=> (homo (weld "foo" "bar"))
        ~[~~f ~~o ~~o ~~b ~~a ~~r]
        ~palryp-hocsyt/try=> (homo (wild "foo" "bar"))
        ! -find-limb.t
        ! find-fork
        ! exit
++  zing 
  Comment:
        promote
  Description:
        Turns a list of lists into a single list by promoting the elements of each sublist into the higher.
  Explanation:
        Creates a wet %gold gate with a sample that accepts a list of lists.
        Casts the result to the type the homogenized list head, asserting that 'a' is at least a cell.
        A dry %gold trap is created and kicked.
        Builds an if-then-else statement on "a is null."  If so, produce null.
        Else, weld together the head of a with the recrusive call of zing on the tail of a.
  Examples:
        ~palryp-hocsyt/try=> (zing (limo [(limo ['a' 'b' 'c' ~]) (limo ['e' 'f' 'g' ~]) (limo ['h' 'i' 'j' ~]) ~]))
        ~['a' 'b' 'c' 'e' 'f' 'g' 'h' 'i' 'j']
        ~palryp-hocsyt/try=> (zing (limo [(limo [1 'a' 2 'b' ~]) (limo [3 'c' 4 'd' ~]) ~]))
        ~[1 97 2 98 3 99 4 100]

chapter 2c, simple noun surgery

section 2cA, bit surgery              **capitalization of "section" inconsistent in source**

++  bex  
  Comment:
        binary exponent
  Description:
        Produces 2 to the nth power for some atom 'n'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts a single atom.
        Casts the result to an atom.
        Builds an if-then-else statement on a=0.
        If so, produce 1.
        Else, multiply two by the recursive call of bex on the decrement of a.
  Examples:
        ~palryp-hocsyt/try=> (bex 4)
        16
        ~palryp-hocsyt/try=> (bex (add 19 1))
        1.048.576
        ~palryp-hocsyt/try=> (bex 0)
        1
++  xeb  
  Comment:
        binary logarithm
  Description:
        Takes the base-2 logarithm of an atom.
  Explanation:
        Creates a dry %gold gate with a sample which accepts an atom.
        Casts the result to an atom.
        Evaluates the logarithm by counting the number of bits the number in question occupies.
  Examples:
        ~palryp-hocsyt/try=> (xeb 31)
        5
        --
        ~palryp-hocsyt/try=> (xeb 32)
        6
        --
        ~palryp-hocsyt/try=> (xeb 49)
        6
        --
        ~palryp-hocsyt/try=> (xeb 0)
        0
        --
        ~palryp-hocsyt/try=> (xeb 1)
        1
        --
        ~palryp-hocsyt/try=> (xeb 2)
        2
++  can  
  Comment:
        assemble
  Description:
        Assembles a 
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a bloq size (an atom) and
        a list of atomic tuples.
        Casts the result to an atom.
        Builds an if-then-else statement on "b is null."
        If so, produce 0.
        Else, 
  Examples:
        ~ronrem-lonsem/try=> `@ub`(can 3 ~[[1 1]])
        0b1 
        ---
        ~ronrem-lonsem/try=> `@ub`(can 0 ~[[1 255]])
        0b1
        ---
        ~ronrem-lonsem/try=> `@ub`(can 1 ~[[1 2]])
        0b10
        ---
        ~ronrem-lonsem/try=> `@ub`(can 1 ~[[1 3]])
        0b11
        ---
        ~ronrem-lonsem/try=> `@ub`(can 1 ~[[1 4]])
        0b0
        ---
        ~ronrem-lonsem/try=> `@ub`(can 1 ~[[2 4]])
        0b100
++  cat  
  Comment:
        concatenate
  Description:
        Concatenates two atoms, obeying the given block size.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a bloq size (an atom) and
        two atoms.
        Measures the number of blocks of size 'a' are in 'b'.
        Left shifts 'c' that many times the bock size of 'a'.
        Sums the result of the left shift with 'b'.
  Examples:
        ~ronrem-lonsem/try=> `@ub`(cat 1 1 0)
        0b1
        ~ronrem-lonsem/try=> `@ub`(cat 2 1 0)
        0b1
        ~ronrem-lonsem/try=> `@ub`(cat 4 1 0)
        0b1
        ~ronrem-lonsem/try=> `@ub`(cat 0 1 1)
        0b11
        ~ronrem-lonsem/try=> `@ub`(cat 0 2 1)
        0b110
        ~ronrem-lonsem/try=> `@ub`(cat 2 1 1)
        0b1.0001
        ~ronrem-lonsem/try=> `@ub`256
        0b1.0000.0000
        ~ronrem-lonsem/try=> `@ub`255
        0b1111.1111
        ~ronrem-lonsem/try=> `@ub`(cat 3 256 255)
        0b1111.1111.0000.0001.0000.0000
        ~ronrem-lonsem/try=> `@ub`(cat 2 256 255)
        0b1111.1111.0001.0000.0000
        ~ronrem-lonsem/try=> (cat 3 256 255)
        16.711.936        
++  cut  
  Comment:
        slice
  Description:
        Accepts a block size 'a', a cell of two atoms 'b' and 'c' and another atom 'd'.
        Produces the tail of 'd' that is 'c' blocks long after right-shifting 'd' 'b'-blocks.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom),
        a cell of two atoms, and another atom which will be "cut."
        Right-shifts 'd' by 'b' blocks.  Then produces the 'c' block long tail of this right-shift.
  Examples:
        ~ronrem-lonsem/try=> (cut 0 [1 1] 2)
        1
        ~ronrem-lonsem/try=> (cut 0 [2 1] 4)
        1
        ~ronrem-lonsem/try=> (cut 3 [1 1] 256)
        1
        ~ronrem-lonsem/try=> (cut 2 [1 1] 255)
        15
        ~ronrem-lonsem/try=> (cut 1 [1 1] 255)
        3
        ~ronrem-lonsem/try=> (cut 1 [1 2] 255)
        15
++  end  
  Comment:
        tail
  Description:
        Accepts a block 'a' and two atoms, 'b' and 'c'.
        Produces the 'b' blocks of length 'a' on the end of 'c'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block (an atom) and
        two atoms.
        Multiplies the binary exponent of 'a' (2^a) with 'b', then takes the binary exponent
        of that (2^((2^a)*b)) to finally produce the modulus of 'c' and the ensuing product.
  Examples:
        ~ronrem-lonsem/try=> `@ub`12
        0b1100
        ---
        ~ronrem-lonsem/try=> `@ub`(end 0 3 12)
        0b100
        ---
        ~ronrem-lonsem/try=> (end 0 3 12)
        4
        ---
        ~ronrem-lonsem/try=> `@ub`(end 1 3 12)
        0b1100
        ---
        ~ronrem-lonsem/try=> (end 1 3 12)
        12
        ---
        ~ronrem-lonsem/try=> (end 3 1 256)
        0
        ---
        ~ronrem-lonsem/try=> (end 3 1 255)
        255 
++  fil  
  Comment:
        fill bloqstream
  Description:
        
  Explanation:
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        two other atoms.
        Let 'n' be 0.
        Let 'd' be 'c'.
        Creates and kicks a dry %gold trap whose result is cast to a atom.
        Builds an if-then-else statement on n=b.
        If so, produce the right-shift of 'd' by one block.
        Else, recursively call the trap with 'd' replaced by the sum of 'c' and the one block
        left-shift of 'b', n replaced by the increment of n.
  Examples:
        
++  lsh  
  Comment:
        left shift
  Description:
        Accepts a block size 'a' and two atoms 'b' and 'c'.  Produces 'c' left-shifted 
        'b' times by the block size.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block (an atom) and
        two atoms.
        Multiplies 'c' times the binary exponent of the binary exponent of 'a' times 'b',
        that is ((2^((2^a)*b))*c), this producing the desired left-shift on 'c'.
  Examples:
        ~ronrem-lonsem/try=> `@ub`1
        0b1
        ---
        ~ronrem-lonsem/try=> `@ub`(lsh 0 1 1)
        0b10
        ---
        ~ronrem-lonsem/try=> (lsh 0 1 1)
        2
        ---
        ~ronrem-lonsem/try=> `@ub`255
        0b1111.1111
        ---
        ~ronrem-lonsem/try=> `@ub`(lsh 3 1 255)
        0b1111.1111.0000.0000
        ---
        ~ronrem-lonsem/try=> (lsh 3 1 255)
        65.280
++  met  
  Comment:
        measure
  Description:
        Measures the number of blocks of size 'a' are in 'b'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        an atom.
        Casts the result to an atom.
        Let 'c' be 0.
        Creates and kicks a dry %gold trap.
        Builds an if-then-else statement on b=0.
        If so, produce c.
        Else, recursively call the trap, with 
        'b' replaced by the single-block right-shift of 'b' and 'c' by the increment of 'c'.
  Examples:
        ~ronrem-lonsem/try=> (met 0 1)
        1
        ~ronrem-lonsem/try=> (met 0 2)
        2
        ~ronrem-lonsem/try=> (met 3 255)
        1
        ~ronrem-lonsem/try=> (met 3 256)
        2
++  rap  
  Comment:
        assemble nonzero
  Description:
        Concatenates a list of atoms, obeying a given blocksize.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        a list of atoms.
        Casts the result to an atom.
        Builds an if-then-else statement on "b is an atom."
        If so, produce 0.
        Else, concateate the head of 'b' with the recursive call of rap on the tail of 'b',
        with block size a.
  Examples:
        ~palryp-hocsyt/try=> (rap 2 (limo [1 2 3 4 ~]))
        17.185
        ---
        ~palryp-hocsyt/try=> (rap 1 (limo [1 2 3 4 ~]))
        313
        ---
        ~palryp-hocsyt/try=> (rap 0 (limo [0 0 0 ~]))
        0
        ---
        ~palryp-hocsyt/try=> (rap 0 (limo [0 0 1 ~]))
        1
++  rep  
  Comment:
        assemble single
  Description:
        Assembles 
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        a list of atoms.
        Casts the result to an atom.
        Let 'c' be 0.
        Creates and kicks a dry %gold trap.
        Build an if-then-else statement on "b is an atom."
        If so, produce 0.
        Else, produce the binary logical OR of the 'c' time left-shift on the last block
        of the head of 'b' and the recursive call of the trap with:
        'c' replaced by the increment of 'c'.
        'b' replaced by the tail of 'b'.
  Examples:
        ~palryp-hocsyt/try=> (rep 0 (limo [1 2 3 4 ~]))
        5
        ---
        ~palryp-hocsyt/try=> (rep 1 (limo [1 2 3 4 ~]))
        57
        ---
        ~palryp-hocsyt/try=> (rep 0 (limo [1 0 0 ~]))
        1
        ---
        ~palryp-hocsyt/try=> (rep 0 (limo [1 0 0 0 ~]))
        1
        ---
        ~palryp-hocsyt/try=> (rep 0 (limo [0 1 0 0 ~]))
        2
        ---
        ~palryp-hocsyt/try=> (rep 0 (limo [0 1 0 1 ~]))
        10
        ---
        ~palryp-hocsyt/try=> (rep 0 (limo [0 1 0 1 0 1 ~]))
        42
++  rip  
  Comment:
        disassemble
  Description:
        Produces a list of the bits of an atom, in little endian order, according to
        block size.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and 
        any number.
        Cast the result to a list of atoms.
        Builds an if-then-else statement on b=0.
        If so, produce null.
        Else, produce a tuple with head of (end a 1 b), the single-block tail of 'b', and
        the resursive call of rip with 'b' replaced by the single-block right-shift of 'b'.
        in little endian.
  Examples:
        palryp-hocsyt/try=> `@ub`155
        0b1001.1011
        ---
        ~palryp-hocsyt/try=> (rip 0 155)
        ~[1 1 0 1 1 0 0 1]
        ---
        ~palryp-hocsyt/try=> (rip 2 155)
        ~[11 9]
        ---
        ~palryp-hocsyt/try=> (rip 1 155)
        ~[3 2 1 2]
        ---
        ~palryp-hocsyt/try=> `@ub`256
        0b1.0000.0000
        ---
        ~palryp-hocsyt/try=> (rip 0 256)
        ~[0 0 0 0 0 0 0 0 1]
        ---
        ~palryp-hocsyt/try=> (rip 2 256)
        ~[0 0 1]
        ---
        ~palryp-hocsyt/try=> (rip 3 256)
        ~[0 1]
        
++  rsh  
  Comment:
        right shift
  Description:
        Accepts a block size 'a' and two atoms, 'b' and 'c'.  Right-shifts 'c' by 'b' blocks
        of size 'a'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        two atoms.
        Takes the binary exponent of the binary exponent of 'a' multiplied by 'b',
        that is (2^(((2^a)*b))) and divides 'c' by it, producing the desired 
        right-shift on 'c'.
  Examples:
        ~ronrem-lonsem/try=> `@ub`145
        0b1001.0001
        ---
        ~ronrem-lonsem/try=> `@ub`(rsh 1 1 145)
        0b10.0100
        ---
        ~ronrem-lonsem/try=> (rsh 1 1 145)
        36
        ---
        ~ronrem-lonsem/try=> `@ub`(rsh 2 1 145)
        0b1001
        ---
        ~ronrem-lonsem/try=> (rsh 2 1 145)
        9
        ---
        ~ronrem-lonsem/try=> `@ub`10
        0b1010
        ---
        ~ronrem-lonsem/try=> `@ub`(rsh 0 1 10)
        0b101
        ---
        ~ronrem-lonsem/try=> (rsh 0 1 10)
        5
        ---
        ~ronrem-lonsem/try=> `@ub`1
        0b1
        ---
        ~ronrem-lonsem/try=> (rsh 0 1 1)
        0
        ---
        ~ronrem-lonsem/try=> (rsh 0 1 1)
        0
++  swap 
  Comment:
        reverse bloq order
  Description:
        Produces the reversed block order of a number, obeying block number.
        Switches little ending to big and vice versa.
  Explanation:
        Creates a dry %gold gate with a sample which accepts a block size (an atom) and
        an atom.
        Rips apart the atom by the block size, then reverses the tape that is produced.
        Once it is reversed, it is re-assembled using rep.
  Examples:
        ~palryp-hocsyt/try=> `@ub`24
        0b1.1000
        ---
        ~palryp-hocsyt/try=> (swap 0 24)
        3
        ---
        ~palryp-hocsyt/try=> `@ub`3
        0b11
        ---
        ~palryp-hocsyt/try=> (swap 0 0)
        0
        ---
        ~palryp-hocsyt/try=> (swap 1 24)
        9
        ---
        ~palryp-hocsyt/try=> (swap 0 128)
        1
section 2cB, bit logic                

++  con  
  Comment:
        binary or
  Description:
        Produces the bit-wise logical OR of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Let 'c' be 0, d be 0.
        Creates and kicks a dry %gold trap.  Casts the result to an atom.
        Builds an if-then-else statement on a=b AND b=0.
        If so, produce 'd'.
        Else, recursively call the trap with:
        'a' replaced by the single 0-block right shift of 'a'.
        'b' replaced by the single 0-block right-shift of 'b'.
        'c' replaced by the increment of c.
        'd' replaced by the sum of 'd' and the 'c' 0-block left-shift of the
            logical AND of (last bit of 'a')=0 AND (last bit of 'b')=0.
        (==) terminates the list of changes.
  Examples:
        ~palryp-hocsyt/try=> (con 0 1)
        1
        ---
        ~palryp-hocsyt/try=> (con 1 0)
        1
        ---
        ~palryp-hocsyt/try=> (con 0 0)
        0
        ---
        ~palryp-hocsyt/try=> (con 4 4)
        4
        ---
        ~palryp-hocsyt/try=> (con 10.000 234)
        10.234
++  dis  
  Comment:
        binary and
  Description:
        Produces the bit-wise logical AND of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Pushes the bunt of a two atom tuple onto the subject.
        Creates and kicks a dry %gold trap.  Casts its result to an atom.
        Builds an if-then-else statement on a=0 or b=0.
        If so, produce 'd'.
        Else, recursively call the trap with:
        'a' replaced by the single 0-block right-shift of 'a'.
        'b' replaced by the single 0-block right-shift of 'b'.
        'c' replaced by the increent of 'c'.
        'd' replaced by the sum of 'd' and the 'c' 0-block left-shift of the
        logical OR of (last bit of 'a')=0 OR (last bit of 'b')=0.
        (==)  terminates the list of changes.
  Examples:
        ~ronrem-lonsem/try=> `@ub`9
        0b1001
        ---
        ~ronrem-lonsem/try=> `@ub`5
        0b101
        ---
        ~ronrem-lonsem/try=> `@ub`(dis 9 5)
        0b1
        ---
        ~ronrem-lonsem/try=> (dis 9 5)
        1
        ---
        ~ronrem-lonsem/try=> `@ub`534
        0b10.0001.0110
        ---
        ~ronrem-lonsem/try=> `@ub`987
        0b11.1101.1011
        ---
        ~ronrem-lonsem/try=> `@ub`(dis 534 987)
        0b10.0001.0010
        ---
        ~ronrem-lonsem/try=> (dis 534 987)
        530
++  mix  
  Comment:
        binary xor
  Description:
        Produces the bit-wise logical exclusive OR of two atoms.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample which accepts two atoms.
        Casts the result to an atom.
        Let 'c' be 0, 'd' be 0.
        A dry %gold trap is created and kicked.
        Builds an if-then-else statement on a=0 AND b=0.
        If so, produce 'd'.
        Else, recursively call mix with:
        'a' replaced by 
        'b' replaced by
        'c' replaced by the increment of 'c'.
        'd' replaced by
        (==) terminates the list of changes.
  Examples:
        ~ronrem-lonsem/try=> `@ub`2
        0b10
        ~ronrem-lonsem/try=> `@ub`3
        0b11
        ~ronrem-lonsem/try=> `@ub`(mix 2 3)
        0b1
        ~ronrem-lonsem/try=> (mix 2 3)
        1
        ~ronrem-lonsem/try=> `@ub`(mix 2 2)
        0b0
        ~ronrem-lonsem/try=> (mix 2 2)
        0
++  not  
  Comment:
        binary not (sized)
  Description:
        Produces the bit-wise logical NOT over 'b' blocks of the given blocksize.
  Explanation:
        First produces the binary exponent of the binary exponent of the block size times       
        'b'.  This is decremented before being multiplied by 'c'.
        Finally, this product is exclusive ORed and produced.
  Examples:
        ~palryp-hocsyt/try=> `@ub`24
        0b1.1000
        ---
        ~palryp-hocsyt/try=> (not 0 5 24)
        7
        ---
        ~palryp-hocsyt/try=> `@ub`7
        0b111
        ---
        ~palryp-hocsyt/try=> (not 2 5 24)
        1.048.551
        ---
        ~palryp-hocsyt/try=> (not 2 5 1.048.551)
        24
        ---
        ~palryp-hocsyt/try=> (not 1 1 (not 1 1 10))
        10

section 2cC, noun orders              

++  aor  
  Comment:
        a-order
  Description:
        Alphabetic comparator gate.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts two nouns.
        Casts the result to a loobean.
        Builds an if-then-else statement on a=b.
        If so, produce true.
        Else, build an unless-then-else statement on "a is an atom."
        If 'a' is not an atom, build an unless-then-else statement on "b is an atom."
        If so, build an if-then-else statement on (-.a=-.b) where -.a is the head of 'a'.
        If so, recursively call aor with 'a' and 'b' replaced by their respecitve tails.
        Else, recursively call aor with 'a' and 'b' replaced by their respective heads.
        Else (if 'b' is an atom), produce false.
        Else (if 'a' is an atom), build an unless-then-else statement on "b is an atom."
        If so, produce true.
        Else, create and kick a dry %gold gate.
        Let 'c' be the byte tail of 'a', 'd' be the byte tail of 'b'.
        Builds an if-then-else statement on (c=d).
        If so, produce the recursive call to the trap with 'a' replaced by the byte right-shift of 'a'
        and 'b' replaced by the byte right-shift of 'b'.
        Else (if !(c=d)), produce (c<d).
  Examples:
       ~tadbyl-hilbel/try=> (aor 'a' 'b')
        %.y
        ~tadbyl-hilbel/try=> (aor 'b' 'a')
        %.n
        ---
        ~tadbyl-hilbel/try=> (aor "foo" "bar")
        %.n
        ~tadbyl-hilbel/try=> (aor "bar" "foo")
        %.y
        ---
        ~tadbyl-hilbel/try=> (aor "abcdefz" "abcdefa")
        %.n
        ~tadbyl-hilbel/try=> (aor "abcdefa" "abcdefz")
        %.y
        ---
        ~tadbyl-hilbel/try=> (aor 10.000 17.000)
        %.y
        ~tadbyl-hilbel/try=> (aor 10 9)
        %.n
++  dor  
  Comment:
        d-order
  Description:
        Numeric comparator gate.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts two nouns.
        Casts the result to a loobean.
        Builds an if-then-else statement on a=b.
        If so, produce true.
        Else, build an unless-then-else statement on "a is an atom."
        If 'a' is not an atom, build an unless-then-else statement on "b is an atom."
        If so, build an if-then-else statement on (-.a=-.b) where -.a is the head of 'a'.
        If so, recursively call dor with 'a' and 'b' replaced by their respecitve tails.
        Else, recursively call dor with 'a' and 'b' replaced by their respective heads.
        Else ('b' is an atom), produce false.
        Else ('a' is an atom), build an unless-then-else statement on "b is an atom."
        If so, produce true.
        Else, produce (a<b).
  Examples:
        ~tadbyl-hilbel/try=> (dor 1 2)
        %.y
        ~tadbyl-hilbel/try=> (dor 2 1)
        %.n
        ---
        ~tadbyl-hilbel/try=> (dor ~[1 2 3] ~[1 2 4])
        %.y
        ~tadbyl-hilbel/try=> (dor ~[1 2 4] ~[1 2 3])
        %.n
        ---
        ~tadbyl-hilbel/try=> (dor (limo ~[99 100 10.000]) ~[99 101 10.000])
        %.y
        ~tadbyl-hilbel/try=> (dor ~[99 101 10.999] (limo ~[99 100 10.000]))
        %.n
++  gor  
  Comment:
        g-order
  Description:
        Hash comparator gate.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts two nouns.
        Casts the result to a loobean.
        Let 'c' be the mug (FNV-1a hash) of 'a' an 'd' the mug of 'b'.
        Create an if-then-else statement on c=d.
        If so, produce the d-order of 'a' and 'd'.
        Else, produce the loobean (c<d).
  Examples
        ~palryp-hocsyt/try=> (gor 'd' 'c')
        %.y
        ~palryp-hocsyt/try=> 'd'
        'd'
        ~palryp-hocsyt/try=> 'c'
        ~palryp-hocsyt/try=> `@ud`'d'
        100
        ~palryp-hocsyt/try=> `@ud`'c'
        99
        ~palryp-hocsyt/try=> (mug 'd')
        1.628.185.714
        ~palryp-hocsyt/try=> (mug 'c')
        1.712.073.811
        ~palryp-hocsyt/try=> (gor 'd' 'c')
        %.y
        ~palryp-hocsyt/try=> (gor 'c' 'd')
        %.n
        ---
        ~palryp-hocsyt/try=> (gor "foo" "bar")
        %.n
        ---
        ~palryp-hocsyt/try=> (gor (some 10) (limo [1 2 3 ~]))
        %.n
++  hor  
  Comment:
        h-order
  Description:
        Recursive hash comparator gate.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts two nouns.
        Casts the result to a loobean.
        Build an if-then-else statement on "a is an atom."
        If so, build na if-then-else statment on "b is an atom."
        If so, produce  the g-order of 'a' and 'b'.
        Else (if 'b' is not an atom), produce true.
        Else (if 'a' is not an atom), build an if-then-else statement on "b is an atom."
        If so, produce false.
        Else, build an if-then-else statement on (-.a=-.b), where '-.a' is the head of 'a'. 
        If so, produce the g-order of the tails of 'a' and 'b'.
        Else (if the heads of 'a' and 'b' are not equal), produce the g-order of the tails of 'a', 'b'.
  Examples:
        
++  vor
  Comment:
        v-order
  Description:
        Double hash comparator gate.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts two nouns.
        Casts the result to a loobean.
        Let 'c' be the double mug (FNV-1a hash) of 'a', 'd' that of 'b'.
        Builds an if-then-else statement on (c=d).
        If so, produce the d-order of 'a' and 'b'.
        Else, produce the loobean of (c<d).
  Examples:
        ~palryp-hocsyt/try=> (vor 'f' 'g')
        %.y
        ---
        ~palryp-hocsyt/try=> (vor 'a' 'z')
        %.n
        ---
        ~palryp-hocsyt/try=> (vor 43.326 41.106)
        %.n

section 2cD, insecure hashing         

++  fnv
  Comment:
        FNV scrambler
  Description:
        Hashes an atom with the 32-bit FNV non-cryptographic hash algorithm.
  Explanationj
        Multiplies 'a' by the prime number 16,777,619 and then takes the block of
        size 5 off the product's end.
  Examples:
        ~palryp-hocsyt/try=> (fnv 10.000)
        272.465.456
        ---
        ~palryp-hocsyt/try=> (fnv 10.001)
        289.243.075
        ---
        ~palryp-hocsyt/try=> (fnv 1)
        16.777.619
++  mug
  Comment:
        31bit nonzero FNV1a
  Description:
        Hashes any noun with the 31-bit nonzero FNV-1a non-cryptographic hash algorithm.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate with a sample accepting any noun.

        (?^ and 'p' subsection fill in.)      

        Let 'b' be 2,166,136,261.
        Create and kick a dry %gold gate.  Cast its result to an atom.
        Let 'c' be 'b'.
        Let 'd' be 0, 'e' be the number of bytes in 'a'.
        Create and kick a dry %gold gate.  Cast its result to an atom.
        Builds an if-then-else statement on d=e.
        If so, let 'f' be the bit-wise XOR on the 31 0-block shift on 'c' and the last
        31 blocks of 'c'.
        Builds an unless-then-else statement on f=0.  If then, produce 'f'.
        Else, recursively call the trap above our current trap with 'b' replaced by +(b).
        Else (d isn't equal to e), then recursively call the trap with 'c' replaced by
        the fnv hash of the logical XOR of 'c' and (cut 3 [d 1] a), 'd' replaced by
        the increment of 'd'.
        
  Examples:
        ~palryp-hocsyt/try=> (mug 10.000)
        178.152.889
        ---
        ~palryp-hocsyt/try=> (mug 10.001)
        714.838.017
        ---
        ~palryp-hocsyt/try=> (mug 1)
        67.918.732
        ---
        ~palryp-hocsyt/try=> (mug (some 10))
        1.872.403.737
        ---
        ~palryp-hocsyt/try=> (mug (limo [1 2 3 4 5 ~]))
        1.067.931.605

section 2cE, phonetic base            

++  po
  Comment:
        left-right syllable
  Description:
        Provides the phonetic syllables and name generators for the Urbit naming system.
  Explanation:
        This arm is jetted.
        Create the cell [sis dex] where 'sis' and 'dex' are the togas on the 
        left-hand ("sinister") and right-hand ("Dexter") phonetic syllable cords, respectively.
        Build a %gold core to contain the following arms.
  ++  ind 
  Comment:
        
  Description:
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts and atom.
        Let 'b' be 0.
        Creates and kicks a dry %gold trap, casting the result to an atomic unit.
        Builds an if-then-else statement on (b=256).  If so, produce null.
        Else, build an if-then-else statement on (a=(tod b)).  If so, produce the atomic unit [~ b].
        Else, recursively call the trap with 'b' replaced by the increment of 'b'.
  Examples:
  
  ++  ins 
  Comment:
        
  Description:
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts and atom.
        Let 'b' be 0.
        Creates and kicks a dry %gold trap with the result cast to an atomic unit.
        Builds an if-then-else statement on (b=256). If so, produce null.
        Else, build an if-then-else statement on (a=(tos b)).  If so, produce the atomic unit [~ b].
        Else, recursively call the trap with 'b' replaced by the increment of 'b'.
  Examples:

  ++  tod 
  Comment:
  Description:
        Selects right-hand phonetic syllable from 'dex'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts and atom.
        Assert that 'a' is less than 256.
        Produce the three tail-end byte blocks in the rght-shift of dex.
  Examples:
        ~palryp-hocsyt/try=> (tod:po 98)
        6.514.020
        ---
        ~palryp-hocsyt/try=> (tod:po 150)       
        6.781.298
        ---
        ~palryp-hocsyt/try=> (tod:po 255)
        7.562.598
        ---
        ~palryp-hocsyt/try=> (tod:po 256)
        ! exit
  ++  tos 
  Comment:

  Description:
        Selects left-hand phonetic syllable from 'sin'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts and atom.
        Assert that 'a' is less than 256.
        Produce the three tail-end byte blocks in the rght-shift of dex.
  Examples:
section 2cF, signed and modular ints  

++  si    
  Comment:
        signed integer
  ++  abs 
  Comment:
        absolute value
  Description:
        Produces the absolute value of a signed integer.
  Explanation:
        Creates a dry %gold gate with a sample which accepts a single atom.
        Sums the last bit of the atom with the single bit-wise block right-shift of the atom,
        producing the absolute value.
  Examples:
        ~palryp-hocsyt/try=> (abs:si -2)
        2
        ---
        ~palryp-hocsyt/try=> (abs:si -10.000)
        10.000
        ---
        ~palryp-hocsyt/try=> (abs:si --2)
        2
  ++  dif 
  Comment:
        subtraction
  Description:
        Produces the difference between two signed integers.
  Explanation:
        Creates a dry %gold gate with a sample which accepts two signed integers.
        Sums the first signed integer with a new signed integer, made from the second by
        (new !(syn b) (abs b)), where !(syn b) is the negative of the second integer's sign.
        This sum, produced, is the difference.
  Examples:
        ~palryp-hocsyt/try=> (dif:si --10 -7)
        --17
        ---
        ~palryp-hocsyt/try=> (dif:si --10 --7)
        --3
        ---
        ~palryp-hocsyt/try=> (dif:si `@s`0 --7)
        -7
        ---
        ~palryp-hocsyt/try=> (dif:si `@s`0 `@s`7)
        --4
  ++  dul 
  Comment:
        modulus
  Description:
        Produces the modulus of two signed integers.
  Explanation:
        Creates a dry %gold gate which accepts a signed integer and an atom.
        Let 'c' be the [sign value] representation of 'a'.
        Builds an if-then-else statement on -.c, the sign of 'a'.
        If so ('a' is positive.), produce the modulus of the absolute value of 'c' and 'b'.
        Else, produce the differenece between 'b' and the absolute value of 'c'.
  Examples:
        ~palryp-hocsyt/try=> (dul:si --9 3)
        0
        ---
        ~palryp-hocsyt/try=> (dul:si --9 4)
        1
        ---
        ~palryp-hocsyt/try=> (dul:si --9 5)
        4
        ---
        ~palryp-hocsyt/try=> (dul:si --9 6)
        3
        ---
        ~palryp-hocsyt/try=> (dul:si --90 --10)
        10
  ++  fra 
  Comment:
        divide
  Description:
        Produces the quotient of two signed integers.
  Explanation:
        Creates a dry %gold gate with a sample which accepts two signed integers.
        Divides the absolute value of 'a', the dividend, and 'b', the divisor, and
        passes that value as the unsigned integer value of a new signed integer.
        The sign of the new signed integer is the bitwise logical XOR of the two integer's 
        signs, meaning the quotient is only positive when both factors are positive.
        This new signed integer is produced.
  Examples:
        ~palryp-hocsyt/try=> (fra:si --4 --2)
        --2
        ---
        ~palryp-hocsyt/try=> (fra:si -4 -2)
        --2
        ---
        ~palryp-hocsyt/try=> (fra:si -4 --2)
        -2
        ---
        ~palryp-hocsyt/try=> (fra:si --4 -2)
        -2
        ---
        ~palryp-hocsyt/try=> (fra:si `@s`4 `@s`2)
        --2
        ---
        ~palryp-hocsyt/try=> (fra:si `@s`4 2)
        ! type-fail
        ! exit
  ++  new 
  Comment:
        [sign value] to @s
  Description:
        Produces a signed integer from a sign value (either & or |) and an atom.
  Explanation:
        Creates a dry %gold gate with a sample which acccepts a loobean and an atom
        Builds an if-then-else statement on the sign value 'a'.
        If so, just produce 'b' multiplied by 2.
        Else, build an if-then-else statement on b=0.  If so, produce 0.
        Else, produce the increment of (2*(dec b)).
        The result is then cast to an integer and produced from new:si.
  Examples:
        ~palryp-hocsyt/try=> (new:si [& 10])
        --10
        ~palryp-hocsyt/try=> (new:si [| 10])
        -10
        ~palryp-hocsyt/try=> (new:si [%.y 7])
        --7
  ++  old
  Comment:
        [sign value]
  Description:
        Produces the cell [sign value] representations of a signed integer.
  Explanation:
        Create a dry %gold date with a with a sample which accepts a signed integer.
        Produce a cell with head (syn a), the sign of 'a', and tail (abs), the absolute value of 'a'.
  Examples:
        ~palryp-hocsyt/try=> (old:si 7)
        ! type-fail
        ! exit
        ---
        ~palryp-hocsyt/try=> (old:si -7)
        [%.n 7]
        ---
        ~palryp-hocsyt/try=> (old:si --7)
        [%.y 7]
        ---
        ~palryp-hocsyt/try=> (old:si `@s`7)
        [%.n 4]
        ---
        ~palryp-hocsyt/try=> (old:si -0)
        [%.y 0]
  ++  pro       
  Comment:
        multiplication
  Description:
        Produces the product of two signed integers.
  Explanation:
        Creates a dry %gold gate with a sample which accepts two signed integers.
        Produces their product by evaluating a new signed integer whose sign is the bitwise 
        XOR of the two number's signs and whose value is the product of their two absolute values.
  Examples:
        palryp-hocsyt/try=> (pro:si -4 --2)
        -8
        ---
        ~palryp-hocsyt/try=> (pro:si -4 -2)
        --8
        ---
        ~palryp-hocsyt/try=> (pro:si --10.000.000 -10)
        -100.000.000
        ---
        ~palryp-hocsyt/try=> (pro:si -1.337 --0)
        --0
  ++  rem 
  Comment:
        remainder
  Description:
        Produces the remainder from a division of two signed integers.
  Explanation:
        Creates a dry %gold gate with a sample which accepts two signed integers.
        Produces the difference between 'a' and the (b*(a/b)).
  Examples:
        ~palryp-hocsyt/try=> (rem:si -10 -4)
        -2
        ---
        ~palryp-hocsyt/try=> (rem:si --10 --4)
        --2
        ---
        ~palryp-hocsyt/try=> (rem:si --10 -4)
        --2
        ---
        ~palryp-hocsyt/try=> (rem:si --7 --3)
        --1
        ---
        ~palryp-hocsyt/try=> (rem:si --0 --10.000)
        --0
  ++  sum 
  Comment:
        addition
  Description:
        Sums two signed integers.
  Explanation:
        Creates a dry %gold gate which accepts two signed integers.
        Prints '%si-sum' in the stack trace if the following code crashes.
        Let 'c' and 'd' be the [sign value] representation of 'a' and 'b', respectively.
        Builds an if-then-else statement on "c is positive".
        If so, build an if-then-else statement on "d is positive".
        If so, produce a new, positive signed integer with value ((abs a)+(abs b))
        Else, build an if-then-else statement on (abs a)>=(abs b)
        If so, produce a new, positive integer with value ((abs a)-(abs d)).
        Else (if !((abs a)>=(abs b))), produce a new, negative signed integer
        with value ((abs d)-(abs c)).
        Else (if c is not positive), build an if-then-else statement on "d is positive".
        If so, build an if-then-else statement on (abs a)>=(abs b).
        If so, produce a new, negative signed intger with value ((abs a)-(abs b))
        Else, produce a new, positive signed integer with value ((abs c)-(abs d))
        Else (if d is not positive), produce a new, negative signed with value ((abs c)+(abs d)).
  Examples:
        ~palryp-hocsyt/try=> (sum:si --10 --10)
        --20
        ---
        ~palryp-hocsyt/try=> (sum:si --10 -0)
        --10
        ---
        ~palryp-hocsyt/try=> (sum:si -10 -7)
        -17
        ---
        ~palryp-hocsyt/try=> (sum:si -10 --7)
        -3
  ++  sun 
  Comment:
        @u to @s
  Description:
        Produces a signed integer from an unsigned integer.
        Note that the result must be manually cast to some @s odor to be inferred as an
        unsigned integer in the type system.
  Explanation:
        Creates a dry %gold gate with a sample which accepts any unsigned integer.
        Produces the integer multiplied by 2.
  Examples:
        ~palryp-hocsyt/try=> `@s`10
        --5
        ---
        ~palryp-hocsyt/try=> (sun:si 10)
        20
        ---
        ~palryp-hocsyt/try=> `@s`(sun:si 10)
        --10
        ---
        ~palryp-hocsyt/try=> `@sd`(sun:si 10)
        --10
        ---
        ~palryp-hocsyt/try=> `@sd`(sun:si 12.345)
        --12.345
  ++  syn 
  Comment:
        sign test
  Description:
        Produces the sign of the signed integer, & being positive and | being negative.
  Explanation:
        Creates a dry %gold gate with a sample which accepts a signed integer.
        Produces the loobean of 0=(last bit in the signed integer)
  Examples:
        ~palryp-hocsyt/try=> (syn:si -7)
        %.n
        ---
        ~palryp-hocsyt/try=> (syn:si --7)
        %.y
        ---
        ~palryp-hocsyt/try=> (syn:si (new:si [& 7]))
        %.y
        ---
        ~palryp-hocsyt/try=> (syn:si -0)
        %.y
        ---
        ~palryp-hocsyt/try=> (syn:si --0)
        %.y
        
++  fe    
  Comment:
        modulo bloq
  Description:
        Binary block modulo math engine.  Defaults to bloq size 1.
  Explanation:
        Builds an %gold tray with a sample accepting a bloq size (an atom).
  ++  dif 
  Comment:
        subtraction
  Description:
        Produces the difference between two atoms in the modular basis representation.
  Explanation:
        Creates a dry %gold gate which accepts two atoms.
        Evaluate the difference between the sum of the 'out' and 
        
  Examples:

  ++  inv 
  Comment:
        invert
  Description:
        Inverts the order of the modular field.
  Explanation:
  Examples:
        palryp-hocsyt/try=> (~(inv fe 3) 255)
        0
        ~palryp-hocsyt/try=> (~(inv fe 3) 256)
        255
        ~palryp-hocsyt/try=> (~(inv fe 3) 0)
        255
        ~palryp-hocsyt/try=> (~(inv fe 3) 1)
        254
        ~palryp-hocsyt/try=> (~(inv fe 3) 2)
        253
        ~palryp-hocsyt/try=> (~(inv fe 3) 3)
        252
  ++  net 
  Comment:
  Description:
  Explanation:
  Examples:

  ++  out 
  Comment:
  Description:
  Explanation:
  Examples:

  ++  rol 
  Comment:
  Description:
  Explanation:
        Creates a dry %gold gate which accepts a block size (an atom) and two other atoms.
        The result of cast to an atom.  'd' is expressed in the modular base as 'e'.
        Let 'f' be the binary exponential difference between 'a' and 'b'.
        Let 'g' be (c mod f).
        Right-shift 'e' by (sub f g) (The difference between 'f' and 'g') blocks of size 'b'.
        Left-shift 'e' by 'g' blocks of size 'b'.
        Take the binary logical OR of these two results and represent them in our modular basis.
  Examples:

  ++  ror 
  Comment:
  Description:
  Explanation:
        Creates a dry %gold gate which accepts a block size (an atom) and two other atoms.
        The result of cast to an atom.  'd' is expressed in the modular base as 'e'.
        Let 'f' be the binary exponential difference between 'a' and 'b'.
        Let 'g' be (c mod f).
        Left-shift 'e' by (sub f g) (The difference between 'f' and 'g') blocks of size 'b'.
        Right-shift 'e' by 'g' blocks of size 'b'.
        Take the binary logical OR of these two results and represent them in our modular basis.
  Examples:

  ++  sum 
  Comment:
        
  Description:
  Explanation:
  Examples:
  ++  sit 
  Comment:
        present
  Description:
        Produces the representation of any atom in the given bloq arithmetic.
  Explanation:
        Creates a dry %gold date that accepts an atom.
        Produces the trailing binary 'a'-block of the number.
  Examples:
        
section 2cG, floating point           

++  rlyd  
++  rlyh  
++  rlyq  
++  rlys  
++  ryld  
++  rylh  
++  rylq  
++  ryls  

section 2cH, urbit time               

++  year
  Comment:
        date to @d
  Description:
        Accepts a parsed date of form [[a=? y=@ud] m=@ud t=tarp] and produces its @d representation.
  Explanation:
        Creates a dry %gold gate which accepts a parsed date of type 'date'.
        Casts the result to @d.
        Let 
        Let 'day' be the
  Examples:
        
++  yore  
  Comment:
        @d to date
  Description:
        Produces the parsed date representation of a @d date. 
  Explanation:
        Creates a dry %gold gate which accepts a @d atomic date.
        Casts the result to the parsed date form [[a=? y=@ud] m=@ud t=tarp].
        Let 'rip' be the 'tarp' [day, hour, minute, second time] of the day.
        Let 'ger' be the day of the year in [year month day] format.
        
  Examples:
++  yell  
  Comment:
        tarp from @d
  Description:
        Produces a parsed daily time format from an atomic date.
  Explanation:
        Creates a dry %gold gate which accepts an atomic date, @d.
        Casts the result to a tarp.
        Let 'sec' be the single 64-bit block right-shift of 'now'.
               
        Creates and kicks a dry %gold trap.  Casts the result to a list of unsigned hexadecimal atoms.
        If (0=raw) OR (0=muc), produce null.
        Replace 'muc' with the decrement of 'muc' (3).
        Produce the cell [(cut 4 [muc 1] raw) $(raw (end 4 muc raw))], where
        (cut 4 [muc 1] raw) is the cut of 'raw' of 1-block of size 4 starting at 'muc'.
        $(raw (end 4 muc raw)) is the recursive call to the trap with 'raw' replaced by the last 'muc' blockcs of size
        4 in 'raw'. 
  Examples:
        ~dovryp-toblug/try=> (yell ~2014.3.20..05.42.53..7456)
        [d=106.751.991.820.094 h=5 m=42 s=53 f=~[0x7456]]
        ---
        ~tadbyl-hilbel/try=> (yell ~2014.6.9..19.09.40..8b66)
        [d=106.751.991.820.175 h=19 m=9 s=40 f=~[0x8b66]]
        ---
        ~tadbyl-hilbel/try=> (yell ~1776.7.4)
        [d=106.751.991.733.273 h=0 m=0 s=0 f=~]
++  yule  
  Comment:
        time atom
  Description:
        Accepts a tarp, a parsed daily time, and produces a time atom, @d.
  Explanation:
        Creates a dry %gold gate which accepts a tarp.
        Casts the result to an atomic date.
        Let

        The product of d.rip, , and day:yo, .
        Let

        
  Examples:
        ~tadbyl-hilbel/try=> =murica (yell ~1776.7.4)
        ~tadbyl-hilbel/try=> murica
        [d=106.751.991.733.273 h=0 m=0 s=0 f=~]
        ~tadbyl-hilbel/try=> (yule murica)
        0x8000000b62aaf5800000000000000000
        ---
        ~dovryp-toblug/try=> (yule (yell ~2014.3.20..05.42.53..7456))
        0x8000000d21c88d5d7456000000000000
        ---
        ~tadbyl-hilbel/try=> (yule (yell ~2014.6.9..19.09.40..8b66))
        0x8000000d223413f48b66000000000000
++  yall
  Comment:
        day # to day of year
  Description:
        Produces what day of the year in year, month, day format a day of 
  Explanation:
  Examples:
++  yawn
  Comment:
        days since Jesus
  Description:
        Accepts a year, month, and day (Three unsigned decimal integers) and produces the date's
        CE representation.
  Explanation:
        Creates a dry %gold gate which accepts three unsigned decimal integers.
        Casts the result to an unsigned decimal integer.
        Replaces the month and day values on the subject with their decrements.
        Replaces the subject of the following with the type of the context.
        Evaluates the context with the changes specified below:

        Lets 
        
  Examples:
++  yelp  
  Comment:
        leap year
  Description:
        Produces a loobean indicating whether the given Commen Era year is a leap year.
  Explanation:
        Creates a dry %gold gate which accepts an unsigned decimal integer.  Casts the result to a loobean.
        Produces the logical AND of (0=(mod yer 4)) and the logical OR of (0=(mod yer 100)) and
        (0=(mod yer 400)).
  Examples:
        ~tadbyl-hilbel/try=> (yelp 2.014)
        %.n
        ---
        ~tadbyl-hilbel/try=> (yelp 2.008)
        %.y
        ---
        ~tadbyl-hilbel/try=> (yelp 0)
        %.y
        ---
        ~tadbyl-hilbel/try=> (yelp 14.011)
        %.n
++  yo
  Comment:
        time constants
  Description:
        Constants of time referenced in the urbit time section.
  Explanation:
        Produces a %gold core with |%.
      ++  cet
      Comment:
        (add 24 (mul 100 365))
      Description:
        The number of days in a century.
      Explanation:
        Derived by multiplying the number of days in a year (365) by the number of yaers in a century (100),
        then adding the number days from leap years in a century (24).
      Examples:
        ~tadbyl-hilbel/try=> cet:yo
        36.524
        ---
        ~tadbyl-hilbel/try=> (add 365 cet:yo)
        36.889
        ---
        ~tadbyl-hilbel/try=> (sub (add 24 (mul 100 365)) cet:yo)
        0
      ++  day 
      Comment:
        (mul 24 hor)
      Description:
        The number of seconds in a day.
      Explanation:
        Derived by multiplying the the number of seconds in an hour by the hours in a day.
      Examples:
        ~tadbyl-hilbel/try=> day:yo
        86.400
        ---
        ~tadbyl-hilbel/try=> (add 60 day:yo)
        86.460
      ++  era 
      Comment:
        (add 1 (mul 4 cet))
      Description:
        
      Explanation:
        
      Examples:

      ++  hor 
      Comment:
        (mul 60 mit)
      Description:
        The number of seconds in an hour.
      Explanation:
        Derived by multiplying the number of seconds in a minute by the minutes in an hour.
      Examples:
        ~tadbyl-hilbel/try=> hor:yo
        3.600
      ++  jes
      Comment:
        (mul 730.692.561 era)
      Description:
        
      Explanation:
        
      Examples:

      ++  mit 
      Comment:
        seconds per minute
      Description:
        The number of seconds in a minute.
      Explanation:
        We just knew this one.
      Examples:
        ~tadbyl-hilbel/try=> mit:yo
        60
      ++  moh 
      Description:
        The days in each month of the Gregorian common year.
      Explanation:
        A list of unsigned decimal atoms (Either 28, 30, or 31) denoting the number of days in the month at the 
        year at that index.
      Examples:
        ~tadbyl-hilbel/try=> moh:yo
        ~[31 28 31 30 31 30 31 31 30 31 30 31]
      ++  moy 
      Description:
        The days in each month of the Gregorian leap-year.
      Explanation:
        A list of unsigned decimal atoms (Either 29,30, or 31) denoting the number of days in the month at the
        leap-year at that index.
      Examples:
        ~tadbyl-hilbel/try=> moy:yo
        ~[31 29 31 30 31 30 31 31 30 31 30 31]
      ++  qad 
      Comment:
        (add 1 (mul 4 yer))
      Description:
        The number of seconds in four years
      Explanation:
        Derived by adding one second to the number of seconds in four years.
      Examples:
        ~tadbyl-hilbel/try=> qad:yo
        126.144.001
      ++  yer 
      Comment:
        (mul 365 day)
      Description:
        The number of seconds in a year.
      Explanation:
        Derived by multiplying the number of seconds in a day by 365.
      Examples:
        ~tadbyl-hilbel/try=> yer:yo
        31.536.000

section 2cI, almost macros

++  hard
  Comment:
        demand result type
  Description:
        Ruthlessly demands that a specific type be produced, crashing the program is it is not.
  Explanation:
        Creates a vulanized wet gate which accepts any gate which accepts any noun and produces
        any noun.
        Creates a dry %gold gate which accepts any noun and casts the result to the 
        higher gate argument's icon.
        Prints "%hard" in the stack trace if the code below crashes.
        Let gol be the higher gate argument slammed with the lower arbitrary noun.
        Assert that the result's icon is equal to that of the lower arbitrary noun
        before producing said result.
  Examples:
        ~palryp-hocsyt/try=> ((hard (list)) (limo [1 2 3 ~]))
        ~[1 2 3]
        ~tadbyl-hilbel/try=> ((hard ,@) (add 2 2))
        4
        ~tadbyl-hilbel/try=> ((hard ,@t) (crip "Tape to cord, bro!"))
        'Tape to cord, bro'
        ~tadbyl-hilbel/try=> ((hard tape) (crip "...Tape to cord, bro?..."))
        ! hard
        ! exit
++  soft
  Comment:
        politely demand
  Description:
        Politely requests a specific type to be produced, producing null if it is not.
  Explanation:
        Creates a vulanized wet gate which accepts any gate which accepts any noun and produces
        any noun.
        Creates a dry %gold gate which accepts any noun and casts the result to the 
        a unit of the higher gate argument's icon.
        Let gol be the higher gate argument slammed with the lower arbitrary noun.
        Build an unless-then-else statement on the result icon's being equal to that of 
        the lower arbitrary noun.
        If so, produce null.
        Else, produce the unit of the result.
  Examples:
        ~tadbyl-hilbel/try=> ((soft ,%4) (add 2 2))
        [~ %4]
        ~tadbyl-hilbel/try=> ((soft ,@) (add 2 2))
        [~ 4]
        ~tadbyl-hilbel/try=> ((soft ,%5) (add 2 2))
        ~
        ~tadbyl-hilbel/try=> ((soft ,@t) (crip "Tape to cord, Woohoo!"))
        [~ 'Tape to cord, Woohoo!']
        ~tadbyl-hilbel/try=> ((soft ,@t) (trip 'Cmon man... Tape to cord? Please?!'))
        ~
        
chapter 2d, containers

section 2dA, sets     
                
++  apt       
  Comment:
        set invariant
  Description:
        Accepts any tree and produces a loobean indicating whether the tree is a set.
  Explanation:
        Creates a dry %gold gate which accepts a tree.
        Builds an if-then-else statement on "a is an atom."
        If so, produce true.
        Else, compute and produce the logical AND of:
        The if "l.a is an atom" then produce true, else (produce the logical AND of the
        v-order of n.a and n.l.a and the h-order of n.l.a and n.a) if-then-else statement.
        The if "r.a is an atom" then produce true, else (produce the logical AND of the 
        v-order of n.a and n.r.a and the h-order of n.a and n.r.a) if-then-else statement.
        (==)  terminates the tall logical AND statement.
  Examples 
        ~tadbyl-hilbel/try=> =b (sa `(list ,@t)`['john' 'bonita' 'daniel' 'madeleine' ~])
        ~tadbyl-hilbel/try=> (apt b)
        %.y
        ---
        ~tadbyl-hilbel/try=> =m (mo `(list ,[@t *])`[['a' 1] ['b' [2 3]] ['c' 4] ['d' 5] ~])
        ~tadbyl-hilbel/try=> m
        {[p='d' q=5] [p='a' q=1] [p='c' q=4] [p='b' q=[2 3]]}
        ~tadbyl-hilbel/try=> (apt m)
        %.y
++  in        
  Comment:
        set engine
  Description:
        Container arm for set operation arms.  The contained arms inherit it's sample set, 'a'. 
  Explanation:
        This arm is jetted.
        Creates a %gold trap with sample 'a', a set.
  +-  all
  Comment:
        logical AND
  Description:
        Accepts a gate which accepts any noun and produces a loobean.  Slams the gate with each member
        of set 'a', produce the logical AND of the transformed set.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate which accepts any gate which produces a loobean.
        Creates and kicks a dry %gold gate, casts the result to a loobean.
        Builds an if-then-else statement on "a is an atom."
        If so, produce true.
        Else, produce the logical AND of (b n.a) and the recursive calls of the trap with
        'a' replaced by 'l.a' and 'a' replaced by 'r.a'.
  Examples:
        ~dovryp-toblug/try=> =b (sa `(list ,[@t *])`[['a' 1] ['b' [2 3]] ~])
        ~dovryp-toblug/try=> (~(all in b) |=(a=* ?@(-.a & |)))
        %.n
        ~tadbyl-hilbel/try=> =b (sa `(list ,@t)`['john' 'bonita' 'daniel' 'madeleine' ~])
        ~tadbyl-hilbel/try=> (~(all in b) |=(a=@t (gte a 100)))
        %.y
  +-  any
  Comment:
        logical OR
  Description:
        Accepts a gate which accepts any noun and produces a loobean.  Slams the gate with each member
        of set 'a', produce the logical OR of the transformed set.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate which accepts any gate which produces a loobean.
        Creates and kicks a dry %gold gate, casts the result to a loobean.
        Builds an if-then-else statement on "a is an atom."
        If so, produce false.
        Else, produce the logical OR of (b n.a) and the recursive calls of the trap with
        'a' replaced by 'l.a' and 'a' replaced by 'r.a'.
  Examples:
        ~dovryp-toblug/try=> =b (sa `(list ,[@t *])`[['a' 1] ['b' [2 3]] ~])
        ~dovryp-toblug/try=> (~(any in b) |=(a=* ?@(+.a & |)))
        %.y
        ~tadbyl-hilbel/try=> =b (sa `(list ,@t)`['john' 'bonita' 'daniel' 'madeleine' ~])
        ~tadbyl-hilbel/try=> (~(any in b) |=(a=@t (lte a 100)))
        %.n
  +-  del
  Comment:
        b without any a
  Description:
        Accepts any noun 'b' and removes it from the set 'a'.
  Explanations:
        This arm is jetted.
        Creates a wet %gold gate which accepts any noun.
        Creates and kicks a dry %gold gate, casts the result to the type of 'a'.
        Builds an if-then-else statement on "a is null."
        If so, produce null.
        Else, builds an unless-then-else on (b=n.a)
        If so, build an if-then-else statement by testing the h-order of 'b' and 'n.a'.
        If so, produce a the cell [n.a $(a l.a) r.a], where $(a l.a) is the recursive call of 
        the trap with 'a' replaced by the left 
  Examples:
        ~dovryp-toblug/try=> =b (sa `(list ,@t)`[`a` `b` `c` ~])
        ~dovryp-toblug/try=> (~(del in b) `a`)
        {`c` `b`}
        ---
        ~tadbyl-hilbel/try=> =b (sa `(list ,@t)`['john' 'bonita' 'daniel' 'madeleine' ~])
        ~tadbyl-hilbel/try=> (~(del in b) 'john')
        {'bonita' 'madeleine' 'daniel'}
        ---
        ~tadbyl-hilbel/try=> (~(del in b) 'susan')
        {'bonita' 'madeleine' 'daniel' 'john'}

  +-  dig
  Comment:
        axis of b in a
  Description:
        Produces 
  Explanations:
        Creates a dry %gold gate which accepts a single noun.
        Let 'c' be 1.
        Creates and kicks a dry %gold trap.  Casts the result to an atomic unit.
        Builds an if-then-else statement on "a is null."  If so, produce null.
        Else, build an if-then-else statement on (b=n.a).  If so, produce the unit [~ u=(peg c 2)].
        Else, build an if-then-else statement on the g-order of 'b' and 'n.a'
        If so, produce the recursive call of the trap with 'a' replaced by 'l.a' and 'c' replaced by (peg c 6).
        Else, produce the recursive call of the trap with 'a' replaced by 'r.a' and 'c' replaced by (peg c 7).
  Examples:
        ~talsur-todres/try=> =a (sa `(list ,@)`[1 2 3 4 5 6 7 ~])
        ~talsur-todres/try=> a
        {5 4 7 6 1 3 2}
        ~talsur-todres/try=> -.a
        n=6
        ~talsur-todres/try=> (~(dig in a) 7)
        [~ 12]
        ~talsur-todres/try=> (~(dig in a) 2)
        [~ 14]
        ~talsur-todres/try=> (~(dig in a) 6)
        [~ 2]
  +-  gas
  Comment:
        concatenate
  Description:
        Accepts a list 'b' with members of the same type as the set 'a' and produces 
        the union set of 'a' and 'b'.
  Explanation:
        This arm is jetted.
        Creates a dry %gold gate which accepts a list of elements of the same type as 'a'.
        Creates and kicks a dry %gold trap whose result is cast to the type of 'a'.
        Builds an if-then-else statement on "b is an atom."
        If so, produce 'a'.
        Else, recursively call the trap with 'b' replaced by the tail of 'b' and the head of 'b'
        put into 'a'.
  Examples:
        ~tadbyl-hilbel/try=> b
        {'bonita' 'madeleine' 'rudolf' 'john'}
        ~tadbyl-hilbel/try=> (~(gas in b) `(list ,@t)`['14' 'things' 'number' '1.337' ~])
        {'1.337' '14' 'number' 'things' 'bonita' 'madeleine' 'rudolf' 'john'}
        ---
        ~tadbyl-hilbel/try=> (~(gas in s) `(list ,@t)`['1' '2' '3' ~])
        {'1' '3' '2' 'e' 'd' 'a' 'c' 'b'}
  +-  has
  Comment:
        b exists in a check
  Description:
        Accepts any noun and produces the loobean indicating whether or not that value (n.a) exists in 'a'.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate which accepts any noun.
        Creates and kicks a dry %gold trap.  Casts the result to a loobean.
        Builds an if-then-else statement on "The set (a) is an atom."  If so, produce false.
        Else, build an if-then-else statement on (b=n.a).
        If so, produce true.
        Else, build an if-then-else statement on the h-order of 'b' and 'n.a'
        If so, produce the recursive call to the trap with 'a' replaced by 'l.a'
        If so, produce the recursive call to the trap with 'a' replaced by 'r.a'
  Examples:
        ~dovryp-toblug/try=> =a (~(gas in `(set ,@t)`~) `(list ,@t)`[`a` `b` `c` ~])
        ~dovryp-toblug/try=> (~(has in a) `a`)
        %.y
        ~dovryp-toblug/try=> (~(has in a) 'z')
        %.n
  +-  put
  Comment:
        puts b in a, sorted
  Description:
        Accepts any noun 'b' and produces the set 'a' with 'b' added to its sorted location.
  Explanation:  
        This arm is jetted.
        Creates a wet %gold gate which accepts any atom.
        Creates and kicks a dry %gold gate.  Casts the result to the type of set 'a'.
        Builds an if-then-else statement on "a is an atom."
        If so, produce the null-terminated tuple [b ~ ~].
        Else, build an if-then-else statement on (b=n.a).
        If so, produce the set 'a'.
        Else, build an if-then-else statement on the h-order of 'b' and 'n.a'.
        If so, let 'c' be the recursive call of the trap with 'a' replaced by 'l.a'.
        Then, assert that 'c' is a cell.
        Build an if-then-else statement on the v-order of 'n.a' and 'n.c'.
        If so (their v-order is true), produce the tuple [n.a c r.a]
        Else, produce [n.c l.c [n.a r.c r.a]].
        Else (if 'b' and 'n.a' are not well h-ordered.), let 'c' be the recursive call of the trap with
        'c' replaced 'r.a'.
        Then, assert that 'c' is a cell.
        Builds an if-then-else statement on the v-order of 'n.a' and 'n.c'
        If so, produce [n.a l.a c]
        Else, produce [n.c [n.a l.a l.c] r.c].
  Examples:
        ~talsur-todres/try=> =a (~(gas in `(set ,@t)`~) `(list ,@t)`[`a` `b` `c` ~])
        ~talsur-todres/try=> =b (~(put in a) `d`)
        ~talsur-todres/try=> b
        {`d` `a` `c` `b`}
        ~talsur-todres/try=> -.l.+.b
        n=`d`
  +-  rep
  Comment:
        fold
  Description:
        Accepts a noun and a binary gate.  Produces the 'a' with each member 'n.a' replaced by (c n.a b).
  Explanation:
        Creates a wet %gold gate which accpets a noun and a tile, 'a' and 'b'.
        Creates and kicks a dry %gold gate.
        Builds an if-then-else statement on "a is null."  If so, produce 'b'.
        Else, recursively call the trap with 'a' replaced by 'r.a' and 
        'b' replaced by the recursive call of the trap with 'a' replaced by 'l.a' and 'b' replaced by
        (c n.a b).
  Examples:
        ~talsur-todres/try=> =a (~(gas in *(set ,@)) [1 2 3 ~])
        ~talsur-todres/try=> a
        {1 3 2}
        ~talsur-todres/try=> (~(rep in a) 0 |=([a=@ b=@] (add a b)))
        6
        ---
        
  +-  tap
  Comment:
        cell from concat
  Description:
        Accepts a list of elements of the set and produces a cell of the set with the list concatenated.
  Explanation:  
        This arm is jetted.
        Creates a dry %gold gate which accepts a list of elements with elements of the set's elements type.
        Casts the result to the type of list 'b'.
        If "a is an atom.", produce 'b'.
        Else, produce the resursive call to 'tap' with 'a' replaced by 'r.a' and 'b' replaced by [n.a $(a l.a)]
        where $(a l.a) is the recursive call to 'tap' with 'a' replaced by 'l.a'.
  Examples:
        ~tadbyl-hilbel/try=> =s (sa `(list ,@t)`['a' 'b' 'c' 'd' 'e' ~])
        ~tadbyl-hilbel/try=> s
        {'e' 'd' 'a' 'c' 'b'}
        ---
        ~tadbyl-hilbel/try=> (~(tap by s) `(list ,@t)`['1' '2' '3' ~])
        ~['b' 'c' 'a' 'd' 'e' '1' '2' '3']
        ---
        ~tadbyl-hilbel/try=> b
        {'bonita' 'madeleine' 'daniel' 'john'}
        ~tadbyl-hilbel/try=> (~(tap in b) `(list ,@t)`['david' 'people' ~])
        ~['john' 'daniel' 'madeleine' 'bonita' 'david' 'people']
  +-  wyt
  Comment:
        depth of set
  Description:
        Produces the cardinality (number of elements) of the set.
  Explanation:
        Increment the value produced below.
        Creates and kicks a dry %gold gate.  Casts the result to an atom.
        Builds an if-then-else statement on "a is null."  If so, produce 0.
        Else, produce the increment of the sum of the recursive calls to this trap where 'a' is replaced
        by 'l.a' and 'r.a'.
  Examples:
        ~talsur-todres/try=> =a (~(gas in `(set ,@t)`~) `(list ,@t)`[`a` `b` `c` ~])
        ~talsur-todres/try=> ~(wyt in a)
        4
        ---
        ~tadbyl-hilbel/try=> b
        {'bonita' 'madeleine' 'daniel' 'john'}
        ~tadbyl-hilbel/try=> ~(wyt in b)
        5

section 2dB, maps                     

++  ept       
  Comment:
        map invariant
  Description:
        Accepts a tree of cell paris and produces the loobean indicating whther the tree is a map
        or not.
  Explanation:
        Creates a dry %gold gate which accepts a tree of cell pairs.
        If "a is an atom", produce true.
        Else, produce the logical AND of:
        If "l.a is an atom", produce true.  Else, produce the logical AND of the v-order of 'p.n.a' precedes 'p.n.l.a'
        and the h-order of 'p.n.l.a' precedes 'p.n.a'.
        If "r.a is an atom" produce true.  Else, produce the logical AND of the v-oreder of 'p.n.a' precedes 'p.n.r.a'
        and the h-roder of 'p.n.a' precedes 'p.n.r.a'.
        (==) terminates the AND statement.
  Examples:
        ~tadbyl-hilbel/try=> m
        {[p='d' q=5] [p='a' q=1] [p='c' q=4] [p='b' q=[2 3]]}
        ~tadbyl-hilbel/try=> (ept m)
        %.y
        ---
        ~tadbyl-hilbel/try=> b
        {'bonita' 'madeleine' 'daniel' 'john'}
        ~tadbyl-hilbel/try=> (ept b)
        ! type-fail
        ! exit
        ---
        
        
++  ja        
  +-  get
  +-  add
++  ju        
  +-  get
  +-  has
  +-  put
++  by
  Comment:
        map engine
  Description:
        Container arm for map operation arms.  The contained arms inherit it's sample map, 'a'. 
  Explanation:
        This arm is jetted.
        Builds a %gold tray with a sample which accepts a map.
  +-  all
  Comment:
        logical AND
  Description:
        Accepts a gate which accepts any noun and produces a loobean.  Slams the gate with each member
        of map 'a', produce the logical AND of the transformed map.
  Explanations:
        This arm is jetted.
        Builds a wet %gold gate which accepts the tile of a gate accepts any noun and produces a loobean.
        Creates and kicks a dry %gold gate.  Casts the result to loobean.
        Builds an if-then-else statement on "a is an atom."
        If so, produce true.
        Else, produce the logical AND of (b q.n.a), the recursive call of the trap with 'a' replaced by
        'l.a', and the recursive call of the trap with 'a' replaced by 'r.a'.
  Examples:
        ~talsur-todres/try=> =b (mo `(list ,[@t *])`[['a' 1] ['b' [2 3]] ~])
        ~talsur-todres/try=> (~(all by b) |=(a=* ?@(a & |)))
        %.n
        ---
        ~tadbyl-hilbel/try=> =a (mo `(list ,[@t @u])`[['a' 1] ['b' 2] ['c' 3] ['d' 4] ['e' 5] ~])
        ~tadbyl-hilbel/try=> (~(all by a) |=(a=@ (lte a 6)))
        %.y
        ~tadbyl-hilbel/try=> (~(all by a) |=(a=@ (lte a 4)))
        %.n
  +-  any
  Comment:
        logical OR
  Description:
        Accepts a gate which accepts any noun and produces a loobean.  Slams the gate with each member
        of map 'a', produce the logical OR of the transformed map.
  Explanations:
        This arm is jetted.
        Builds a wet %gold gate which accepts the tile of a gate accepts any noun and produces a loobean.
        Creates and kicks a dry %gold gate.  Casts the result to loobean.
        Builds an if-then-else statement on "a is an atom."
        If so, produce false.
        Else, produce the logical OR of (b q.n.a), the recursive call of the trap with 'a' replaced by
        'l.a', and the recursive call of the trap with 'a' replaced by 'r.a'.
  Examples:
        ~talsur-todres/try=> =b (mo `(list ,[@t *])`[['a' 1] ['b' [2 3]] ~])
        ~talsur-todres/try=> (~(all by b) |=(a=* ?@(a & |)))
        %.y
        ---
        ~tadbyl-hilbel/try=> =a (mo `(list ,[@t @u])`[['a' 1] ['b' 2] ['c' 3] ['d' 4] ['e' 5] ~])
        ~tadbyl-hilbel/try=> (~(any by a) |=(a=@ (lte a 4)))
        %.y
  +-  del
  Comment:
        delete at key b
  Description:
        Accepts a noun 'b', producing the map with the key-value pair of key 'b' removed.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate which accepts a noun.
        Creates and kicks a dry %gold trap.  Casts the result to the type of map 'a'.
        Builds an if-then-else statement on "a is null."
        If so, produce null.
        Else, build an unless-then-else statement on (b=(p.n.a)).
        If so, build the if-then-else statement on the g-order of 'b' and 'p.n.a'.
        If so, produce the the tuple [n.a $(a l.a) r.a] where $(a l.a) is the recursive call of the
        trap with 'a' replaced by 'l.a'.
        Else (g-order of 'b' and 'p.n.a' is not true.), produce [n.a l.a $(a r.a)].
        Else (!(b=(p.n.a))), create and kick a dry %gold trap.
        Cast the result to a fork between null and the tile of the map 'a'.
        Builds an if-then-else statement on "l.a is null."  If so, produce 'r.a'.
        Else, build an if-then-else statement on "r.a is null."  If so, produce 'l.a'.
        Else, build an if-then-else statement on the v-order of 'p.n.l.a' and 'p.n.r.a'.
        If so, produce [n.l.a l.l.a $(l.a r.l.a)],where $(l.a r.l.a) is the recursive call of the 
        trap with 'l.a' replaced by 'r.l.a'.
        Else, produce [n.r.a $(r.a l.r.a) r.r.a], ,where $(r.a l.r.a) is the recursive call of the
        trap with 'r.a' replaced by 'l.r.a'.
  Examples:
        ~talsur-todres/try=> =b (mo `(list ,[@t *])`[['a' 1] ['b' [2 3]] ~])  
        ~talsur-todres/try=> (~(del by b) `a`)
        {[p=`b` q=[2 3]]}
        
  +-  dig
  Comment:
        axis of 'b' key
  Description:
        Accepts any noun 'b' and produces the axis of 'b' in within the values of 'p.a' in map 'a'.
  Explanation:
        Creates a wet %gold gate which accepts a noun.
        Let 'c' be 1.
        Creates and kicks a dry %gold gate.  Casts the result to an atomic unit. 
        Builds an if-then-else statement on "a is null."  If so, produce null.
        Else, build an if-then-else statement on (b=(p.n.a.)).  If so, produce the unit [~ u=(peg c 2)].
        Else, build an if-then-else statement on the g-order of 'b' and 'p.n.a'.
        If so, recursively call the trap with 'a' replaced by 'l.a' and 'c' by (peg c 6).
        Else, recursively call the trap with 'a' replaced by 'r.a' and 'c' by (peg c 7).
  Examples:
        ~talsur-todres/try=> =b (mo `(list ,[@t *])`[['a' 1] ['b' [2 3]] ~])  
        ~talsur-todres/try=> (~(dig by b) `b`)
        [~ 2]

  +-  gas
  Comment:
        concatenate
  Description:
        Accepts any list 'b' of key-value pair cells and produces the map 'a' with the members of 'b' added.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate which accepts a list of cells.
        Replaces 'b' in the subject with the cast of 'b' to a list whose members have the 
        same type as the members of 'a'.
        Creates and kicks a dry %gold trap.  Casts the result to the type of map 'a'.
        Builds an if-then-else statement on "b is an atom."
        If so, produce 'a'.
        Else, recursively call the trap iwth 'b' replaced by the tail of 'b' and 'a' replaced by 
        'a' with the key and value of the head of 'b' added to it.
  Examples:
        ~talsur-todres/try=> =a (mo `(list ,[@t *])`[[`a` 1] [`b` 2] ~])
        ~talsur-todres/try=> =b `(list ,[@t *])`[[`c` 3] [`d` 4] ~]
        ~talsur-todres/try=> (~(gas by a) b)
        {[p=`d` q=4] [p=`a` q=1] [p=`c` q=3] [p=`b` q=2]}
  +-  get
  Comment:
        grab value by key
  Description:
        Produces the value in the map at key 'b'.
  Explanation:
        Creates a wet %gold gate which accepts a noun.
        Creates and kicks a dry %gold trap.  Casts its result to the type of the map's values.
        Builds an if-then-else statement on "a is an atom."
        If so, produces null.
        Else, build an if-then-else statement on (b=(p.n.a)).
        If so, produce the unit [~ u=p.n.a].
        Else, build an if-then-else statement on the g-order of 'b' and 'p.n.a'.
        If so, produce the recursive call to the trap with 'a' replaced by 'l.a'.
        Else, produce the recursive call to the trap with 'a' replaced by 'r.a'.
  Examples:
        ~talsur-todres/try=> =b (mo `(list ,[@t *])`[['a' 1] ['b' [2 3]] ~])  
        ~talsur-todres/try=> (~(get by b) `b`)
        [~ [2 3]]
  +-  has
  Comment:
        key existence check
  Description:
        Accepts any noun 'b' and produces the loobean indicating whether the noun exists in map 'a'.
  Explanation:
        This arm is jetted.
        Creates a wet %gold gate which accepts a noun.
        Attempts to get 'b' from 'a', then produces the logical NOT of the loobean "get 'b' in 'a' is null"
  Examples:
        ~talsur-todres/try=> =b (mo `(list ,[@t *])`[['a' 1] ['b' [2 3]] ~])  
        ~talsur-todres/try=> (~(has by b) `b`)
        %.y
        ~talsur-todres/try=> (~(has by b) `c`)
        %.n
  +-  mar
  Comment:
        add with validation
  Description:
        Accepts two nouns of the types of the map's keys and values, respectively. 
        Validates that the value is not null and puts the pair in the map. If the value is null, 
        it deletes the key.
  Explanation:
        Creates a wet %gold gate which accepts
  Examples:
  +-  put
  Comment:
  Description:
  Explanation:
  Examples:
  +-  rep
  Comment:
  Description:
  Explanation:
  Examples:
  +-  rib
  Comment:
  Description:
  Explanation:
  Examples:
  +-  run
  Comment:
  Description:
  Explanation:
  Examples:
  +-  tap
  Comment:
  Description:
  Explanation:
  Examples:
  +-  uni
  Comment:
  Description:
  Explanation:
  Examples:
  +-  wyt
  Comment:
  Description:
  Explanation:
  Examples:

section 2dC, queues                   

++  to        
  +-  bal
  +-  dep
  +-  gas
  +-  get
  +-  nap
  +-  put
  +-  tap
  +-  top

section 2dD, casual containers        

++  mo
  Comment:
        make a map
  Description:
        Mapifiy.  Accepts a list of cells and produces a map of key-value pairs from the left-right cell pairs of the list.
  Explanation:
        Creates a wet %gold gate which accepts a list, 'a'.
        Pushes the homogenized list onto the context.
        Casts the list 'a' to a list of cells whose left-right types correspond to the key-value type pairs.
        Let 'b' be the bunt of the map with the properly typed keys and values from the cell at the head of our list.
        Concatenate the elements of 'a' into the empty map of bunt 'b', and produce the result.
  Examples:
        ~talsur-todres/try=> (mo `(list ,[@t *])`[[`a` 1] [`b` 2] ~])
        {[p=`a` q=1] [p=`b` q=2]}
        
++  sa        
  Comment:
        make a set
  Description:
        Setify.  Accepts a list and produces a set of the list's elements.
  Explanation:
        Creates a wet %gold gate which accepts a list, 'a'.
        Pushes the homogenized list onto the context.
        Let 'b' be the bunt of the set with elements of the same type of the elements of 'a'.
        Concatenate the elements of 'a' into the empty set of bunt 'b', and produce the result.
  Examples:
        ~talsur-todres/try=> (sa `(list ,@)`[1 2 3 4 5 ~])
        {5 4 1 3 2}
        ---
        ~talsur-todres/try=> (sa `(list ,[@t *])`[[`a` 1] [`b` 2] ~])
        {[`a` 1] [`b` 2]}
++  qu
  Comment:
        make a set
  Description:
        XXX THIS APPEARS TO BE A COPY OF ++sa. QUEUIFY IS NOT IMPLEMENTED YET. XXX
  Explanation:
  Examples:

chapter 2e, miscellaneous libs

section 2eA, packing          
        
++  cue       
++  jam       
++  mat       
++  rub       

section 2eB, parsing (tracing)        

++  last  
++  lust

section 2eC, parsing (custom rules)   

++  cold  
++  cook  
++  easy  
++  fail  
++  full  
  Comment:
        has to fully parse
  Description:
        Only succeeds if given a rule that successfully parses the entire nail to the end, producing
        a null hair if the rules fails.
  Explanation:
        Creates a wet %gold gate which accepts a rule.
        Creates a dry %gold gate which accepts a nail.
        Let 'vex' be the rule slammed with the nail.
        Builds an if-then-else statement on "q.vex is an atom."  If so, produce 'vex'.
        Else, build an if-then-else statement on "q.q.u.q.vex is null."  If so, produce 'vex'.
        Else, produce the cell [p=p.vex q=~].
  Examples:
        ~tadbyl-hilbel/try=> ((full (just 'a')) [[1 1] "ab"])
        [p=[p=1 q=2] q=~]
        ---
        ~tadbyl-hilbel/try=> ((full (jest 'ab')) [[1 1] "ab"])
        [p=[p=1 q=3] q=[~ u=[p='ab' q=[p=[p=1 q=3] q=""]]]]
        ---
        ~tadbyl-hilbel/try=> ((full ;~(plug (just 'a') (just 'b'))) [[1 1] "ab"])
        [p=[p=1 q=3] q=[~ u=[p=[~~a ~~b] q=[p=[p=1 q=3] q=""]]]]
++  funk  
++  here  
++  jest  
++  just  
++  knee  
++  mask  
++  next  
++  sear  
++  shim  
++  stag  
++  stet
++  stew
++  stir
++  stun  

section 2eD, parsing (combinators)    

++  bend  
++  comp
++  glue  
++  pfix  
++  plug  
++  pose  
++  sfix  

section 2eE, parsing (composers)      

++  bass
++  boss
++  ifix
++  more
++  most
++  plus  
++  slug
++  star

section 2eF, parsing (ascii)          

++  ace
++  bar 
++  bas 
++  buc 
++  cab 
++  cen 
++  col 
++  com 
++  doq 
++  dot 
++  fas 
++  gal 
++  gar 
++  hax 
++  kel 
++  ker 
++  ket 
++  lus 
++  hep 
++  pel 
++  pam 
++  per 
++  pat 
++  sel 
++  sem 
++  ser 
++  sig 
++  soq 
++  tar 
++  tec 
++  tis 
++  wut 
++  zap 

section 2eG, parsing (whitespace)     

++  dog 
++  doh 
++  dun 
++  duz 
++  gah 
++  gap 
++  gaq 
++  gay 
++  vul 

section 2eH, parsing (idioms)         

++  alf 
++  aln 
++  alp 
++  bet 
++  bin 
++  but 
++  cit 
++  dem 
++  dit 
++  gul 
++  gon 
++  hex 
++  hig 
++  hit 
++  low 
++  mes 
++  nix 
++  nud 
++  poy 
++  qit 
++  qut 
++  sym
  Comment:
  Description:
  Explanation:
  Examples:
++  ven 
  Comment:
  Description:
  Explanation:
  Examples:
++  vit 
  Comment:
        base64 digit
  Description:
        Parses a text and produces it in base64 encoding.
  Explanation:
        Builds a list of falling rules to match on with ';~' and pose.
        Encodes capital letters by 
  Examples:

section 2eI, parsing (external)       

++  rash
  Comment:
        demand parse cord
  Description:
        Parse a given cord with a given rule, crashing if the cord isn't entirely parsed.
  Explanation:
        Creates a wet %gold gate which accepts an atom (cord) and a rule.
        Trips the cord to a tape and produces the result that is parsed with scan.
  Examples:
        ~tadbyl-hilbel/try=> (rash 'I was the world in which I walked, and what I saw' (star (shim 0 200)))
        "I was the world in which I walked, and what I saw"
        ~tadbyl-hilbel/try=> (rash 'abc' (just 'a'))
        ! {1 2}
        ! 'syntax-error'
        ! exit
        ~tadbyl-hilbel/try=> (rash 'abc' (jest 'abc'))
        'abc'
        `~tadbyl-hilbel/try=> (rash 'abc' (jest 'ab'))
        ! {1 3}
        ! 'syntax-error'
        ! exit

++  rush
  Comment:
        politely parse cord
  Description:
        Parse a given cord with a given rule, producing null if the cord isn't entirely parsed.
  Explanation:
        Creates a wet %gold gate which accepts an atom (cord) and a rule.
        Trips a cord to a tape and a produces the result that is parsed with rust.
  Examples:
        ~tadbyl-hilbel/try=> (rush 'I was the world in which I walked, and what I saw' (star (shim 0 200)))
        [~ "I was the world in which I walked, and what I saw"]
        ~tadbyl-hilbel/try=> (rush 'abc' (just 'a'))
        ~
        ~tadbyl-hilbel/try=> (rush 'abc' (jest 'abc'))
        [~ 'abc']
        ~tadbyl-hilbel/try=> (rush 'abc' (jest 'ac'))
        ~
        ~tadbyl-hilbel/try=> (rush 'abc' (jest 'ab'))
        ~

++  rust
  Comment:
        demand parse tape
  Description:
        Parse a given tape with a given rule, producing null if the tape isn't entirely parsed.
  Explanation:
        Creates a wet %gold gate which accepts a tape and a rule.
        Let 'vex' be the full parse of the tape using the rule.
        Builds an if-then-else statement on "q.vex is an atom."  If so, produce null.
        Else, produce the unit with value 'p.u.q.vex'.
  Examples 
        ~tadbyl-hilbel/try=> (rust "I was the world in which I walked, and what I saw" (star (shim 0 200)))
        [~ "I was the world in which I walked, and what I saw"]
        ~tadbyl-hilbel/try=> (rust "Or heard or felt came not but from myself;" (star (shim 0 200)))
        [~ "Or heard or felt came not but from myself;"]
        ~tadbyl-hilbel/try=> (rust "And there I found myself more truly and more strange." (jest 'And there I'))
        ~

++  scan
  Comment:
        demand parse tape
  Description:
        Parses a given tape with a given rule, crashing if the tape isn't entirely parsed.
  Explanation:
        Creates a dry %gold gatet which accepts a tape and a rule.
        Let 'vex' be the full parse of the text by the rule.
        Builds an if-then-else statement on "q.vex is an atom."
        If so, insert the 'tank' producing trap (show [%m '{%d %d}'] p.p.vex q.p.vex ~),
        Then, crash the program and print "syntax-error" in the stack trace.
        Else, produce 'p.u.q.vex'.
  Examples:
        ~tadbyl-hilbel/try=> (scan "I was the world in which I walked, and what I saw" (star (shim 0 200)))
        "I was the world in which I walked, and what I saw"
        ~tadbyl-hilbel/try=> (scan "Or heard or felt came not but from myself;" (star (shim 0 200)))
        "Or heard or felt came not but from myself;"
        ~tadbyl-hilbel/try=> (scan "And there I found myself more truly and more strange." (jest 'And there I'))
        ! {1 12}
        ! 'syntax-error'
        ! exit

section 2eJ, formatting (basic text)  

++  cass
++  cuss
++  crip
++  mesc
++  runt
++  sand
++  sane
++  trim
++  trip
++  teff
++  turf
++  tuba
++  tufa
++  tuft
++  wack
++  wick
++  woad
++  wood

section 2eK, formatting (layout)      

++  re
  ++  ram
  ++  win
    ++  din 
    ++  fit 
    ++  rig
    ++  wig

section 2eL, formatting (path)        

++  ab
  ++  bix  
  ++  hif  
  ++  huf  
  ++  hyf  
  ++  pev  
  ++  pew  
  ++  piv  
  ++  piw  
  ++  qeb  
  ++  qex  
  ++  qib  
  ++  qix  
  ++  seb  
  ++  sed  
  ++  sev  
  ++  sew  
  ++  sex  
  ++  sib  
  ++  siq  
  ++  sid  
  ++  siv  
  ++  siw  
  ++  six  
  ++  sov  
  ++  sow  
  ++  sox  
  ++  ted  
  ++  tip  
  ++  tiq  
  ++  tid  
  ++  til  
  ++  urs  
  ++  urt  
  ++  voy  
  ++  vym  
  ++  vyn  
++  ag
  ++  ape  
  ++  bay  
  ++  bip  
  ++  dem  
  ++  dim  
  ++  dum  
  ++  fed  
  ++  hex  
  ++  lip  
  ++  qut  
  ++  sym  
  ++  tyq  
  ++  viz  
  ++  vum  
  ++  wiz  
++  co
      ++  rear
      ++  rent
      ++  rend
      ++  a-co
      ++  d-co
      ++  r-co
      ++  s-co
      ++  v-co
      ++  w-co
      ++  x-co
      ++  y-co
      ++  z-co
  ++  em-co
  ++  ox-co
  ++  ro-co
++  ne
  ++  d  
  ++  x  
  ++  v  
  ++  w  
++  mu
  ++  zag
  ++  zig
  ++  zug
++  so
  ++  bisk
  ++  crub
  ++  nuck
  ++  nusk
  ++  perd
  ++  royl
  ++  tash
  ++  twid
  ++  zust
++  scot 
++  scow 
++  slav  
++  slaw
++  slay
++  smyt

section 2eM, regular-expressions      

++  pars
++  nor
++  les  
++  lep  
++  alm  
++  alb  
++  mis  
++  anns 
++  mall
++  bets
++  ranc
++  flap 
++  rang
++  chun
++  seac
++  sead
++  sade
++  seap
++  cape
++  lower
++  upper
++  digit
++  print
++  graph
++  blank
++  space
++  cntrl
++  alpha
++  alnum
++  punct
++  wordc
++  white
++  xdigi
++  chad
++  escd
++  escp
++  unid
++  proc 
++  cont
++  abor
++  matc
++  chet
++  blak 
++  deep
++  rexp 
++  repg 

section 2eN, pseudo-cryptography      

++  un   
  ++  wre
  ++  wre
  ++  xaf
  ++  xar
  ++  zaf
  ++  zar
  ++  zyf
  ++  zyr

section 2eO, virtualization           

++  mack
  Comment:
        XX
  Description:
        Accepts a nock subject-formula cell.
        Produces a unit result, treating 11 as a crash (i.e. pure nock).
  Explanation:
        Creates a dry %gold gate accepting cell ['sub' 'fol'].
        Its output is a unit (of a noun).
        Let 'ton' be the result of minking the sample, with a sky that produces
        ~ on any input, halting interpretation.
        Unless ton has stem 0, produce the empty unit, otherwise produce one
        containing ton's bulb.
  Examples 
        ~zod/try=> (mack [[1 2 3] [0 1]])
        [~ [1 2 3]]
        ~zod/try=> (mack [41 4 0 1])
        [~ 42]
        ~zod/try=> (mack [4 0 4])
        ~
        ~zod/try=> (mack [[[0 2] [1 3]] 4 4 4 4 0 5])
        [~ 6]
        ~zod/try=> ;;((unit ,@tas) (mack [[1 %yes %no] 6 [0 2] [0 6] 0 7]))
        [~ %no]
++  mink
  Comment:
        XX
  Description:
        Bottom-level mock (virtual nock) interpreter.
        Accepts a nock subject-formula cell, and an %iron gate which 
          accepts any noun and produces a unit, which is defined to be mock 11.
        Produces a ++tone, which is the result of the virtualized computation.
  Explanation:
        For clarity, a ++tone with stem %0 will be referred to as a "success",
        one with stem %1 as a "block", and one with stem %2 as a "crash".
        ---
        This arm is jetted.
        Creates a dry %gold gate accepting cell ['sub' 'fol'] and gate 'sky'.
        Let 'tax' be a statically bunted list of term-noun pairs. (hint list)
        Do (recursion point) produce a tone:
        If fol is an atom
          Produce a crash of fol.
        Else if the head of fol is a cell
          Let hed be the result of recurring with fol replaced by its head.
          If hed is a crash
            Yield it
          Otherwise let 'tal' be the result of recurring with fol replaced 
          by its tail.
          Switch on the type of tal by stem:
            If tal is a success
              If hed is a block produce hed.
              Else (success) produce a success of a cell of the bulbs of hed 
              and tal.
            If tal is a block
              If hed is a success produce tal.
              Else (block) produce a block of welding the bulbs of hed and tal.
            Else (crash) produce tal
        Otherwise (the head of fol is an atom) switch on fol,
          by default producing a crash of tax.
            If fol has stem 0 and an atom bulb we name 'b'
          If b is 0 produce a crash of tax.
          If b is 1 produce a success of sub.
          If sub is an atom produce a crash of tax
          Otherwise let 'now' be the cap of b, and 'lat' be the mas of b
          Tail-recur with b replaced by lat, and sub replaced by: if now is 2,
          its head, else its tail.
            If fol has stem 1 and a bulb we name 'b'
          Produce a success of b
            If fol has stem 2 and a bulb whose head is a cell.
          Let 'ben' be the result of recurring with fol replaced by its bulb.
          Unless ben is a success, produce ben.
          Else assert that ben contains a cell, and tail-recur with 
          sub and fol replaced by the head and tail of ben's bulb
            If fol has stem 3 and a bulb we name 'b'
          Let 'ben' be the result of recurring with fol replaced by b.
          Unless ben is a success, produce ben.
          Else produce a success of (loobean) whether ben contains a cell.
            If fol has stem 4 and a bulb we name 'b'
          Let 'ben' be the result of recurring with fol replaced by b.
          Unless ben is a success, produce ben.
          Else unless ben contains an atom produce a crash of tax.
          Otherwise produce a success of ben's contents, incremented.
            If fol has stem 5 and a bulb we name 'b'
          Let 'ben' be the result of recurring with fol replaced by b.
          Unless ben is a success, produce ben.
          Else unless ben contains a cell produce a crash of tax.
          Otherwise produce a success of (loobean) whether the bulb of ben has
          a tail equal to its head.
            If fol has stem 6, 7, 8, or 9
          Tail-recur with its bulb expanded per nock specification.
            If fol has stem 10 and a cell bulb whose head is an atom
          Tail-recur with for replaced by its bulb's tail
            If fol has stem 10 and a bulb that can be destructured as [[b c] d]
          Let ben be the result of recurring with fol replaced by v.
          Unless ben is a success, produce ben.
          If b is %hunk, %lose, %mean, or %spot
            Tail-recur with fol replaced by d and tax prepended with a pair of
            b and the bulb of ben.
          Else tail-recur with just fol replaced by d.
  Examples:
        XX
++  mock
  Comment:
        XX
  Description:
        Accepts a nock subject-formula cell and an %iron gate which
          accepts any noun and produces a unit (this is used as nock 11).
        Produces a ++toon, which is a sucesful, blocked, or crashed result.
  Explanation:
        Compose ++mook and ++mink.
  Examples 
        ~zod/try=> (mock [5 4 0 1] ,~)
        [%0 p=6]
        ~zod/try=> (mock [~ 11 1 0] |=(* `999))
        [%0 p=999]
        ~zod/try=> (mock [~ 0 1.337] ,~)
        [%2 p=~]
        ~zod/try=> (mock [~ 11 1 1.337] ,~)
        [%1 p=~[1.337]]
        ~zod/try=> (mock [[[4 4 4 4 0 3] 10] 11 9 2 0 1] |=(* `[+<]))
        [%0 p=14]
        ~zod/try=> (mock [[[4 4 4 4 0 3] 10] 11 9 2 0 1] |=(* `[<+<>]))
        [%0 p=[49 52 0]]
        ~zod/try=> ;;(tape +:(mock [[[4 4 4 4 0 3] 10] 11 9 2 0 1] |=(* `[<+<>])))
        "14"

++  mook
  Comment:
        XX
  Description:
        Intelligently render crash annotation.
        Accepts a ++tone, produces a ++toon
  Explanation:
        Create a dry %gold gate accepting a tone we name 'ton'
        Its output is a toon.
        Unless the stem of ton is %2, produce ton.
        Produce a frond with a stem of 2 and the following bulb:
        Let yel be the length of ton's bulb.
        Replace the bulb of ton,
          If yel > 256 (otherwise keep it static)
          With the weld of
            its top 128 elements
          And a list of term-noun pairs:
          The last 128 elements of ton's bulb
          Preceded by a %lose-stemmed frond of
          A cord from the tape
            "[skipped "
            A @ud rendering of yel - 256
            " frames]"
        Do (*recursion point*) produce a list of tanks:
        For each element in the bulb of ton
        Switch on its leaf, by default leaving the element out of the product
          For each %hunk, clam it to a tank
          For each %lose, produce a leaf with the element clammed to an atom 
          and tripped (to a tape).
          For each %mean, if the elment is an atom treat it as a %lose
              Otherwise let mac be the element macked by its tail.
              If the computation fails, produce a "####" leaf, else clam
              the result to a tank.
          For each %spot, let sot be the element clammed to a spot.
              Produce a leaf with
              The weld of
                The path in sot converted to a tank and then a tape
                ":<["
                [[p.p ] ] in the pint in sot rendered as @ud
                " "
                [[ q.p] ] in the pint in sot rendered as @ud
                "].["
                [ [p.q ]] in the pint in sot rendered as @ud
                " "
                [ [ q.p]] in the pint in sot rendered as @ud
                "]>"
                
  Examples 
        ~zod/try=> (mook [%0 5 4 5 1])
        [%0 p=[5 4 5 1]]
        ~zod/try=> (mook [%2 ~[[%hunk %rose ["<" "," ">"] ~[[%leaf "err"]]]]])
        [%2 p=~[[%rose p=[p="<" q="," r=">"] q=[i=[%leaf p="err"] t=~]]]]
        ~zod/try=> (mook [%2 ~[[%malformed %elem] [%lose 'do print']]])
        [%2 p=~[[%leaf p="do print"]]]
        ~zod/try=> (mook [%2 ~[[%spot /b/repl [[1 1] 1 2]] [%mean |.(!!)]]])
        [%2 p=~[[%leaf p="/b/repl/:<[1 1].[1 2]>"] [%leaf p="####"]]]
++  mang
  Comment:
        XX
  Description:
        XX
  Explanation:
        XX
  Examples 
        XX
++  mong
  Comment:
        XX
  Description:
        XX
  Explanation:
        XX
  Examples 
        XX
++  mung
  Comment:
        XX
  Description:
        XX
  Explanation:
        XX
  Examples 
        XX
++  mule 
  Comment:
        XX
  Description:
        XX
  Explanation:
        XX
  Examples 
        XX
++  mute 
  Comment:
        XX
  Description:
        XX
  Explanation:
        XX
  Examples 
        XX

section 2eP, diff          **noted as "(move me)" in source**

++  berk 
++  diff 
++  loss 
  ++  abet
  ++  hink
  ++  lonk
  ++  lune
  ++  merg
  ++  main
++  locz  
++  lore  
++  role  
++  lump  
++  lure  
++  limp  
++  hump  
++  husk  
++  lurk  
++  lusk  
  ++  abet
  ++  done
  ++  main
++  nude   
  ++  axes 
  ++  tred 

section 2eW, lite number theory           

++  egcd   
++  pram   
++  ramp   
++  fo     
  ++  dif
  ++  exp
  ++  fra
  ++  inv
  ++  pro
  ++  sit
  ++  sum
++  ga     
      ++  dif 
      ++  dub 
      ++  pro 
      ++  toe 
      ++  sit 
  ++  fra     
  ++  inv     
  ++  pow     
  ++  pro     

section 2eX, jetted crypto                

++  aesc      
  ++  en      
  ++  de      
++  ahem      
        ++  cipa 
          ++  co 
          ++  ix 
          ++  ro 
          ++  su 
    ++  pen      
      ++  co  
      ++  ix  
      ++  ro  
      ++  su  
    ++  pin   
      ++  co  
      ++  ix  
      ++  ro  
      ++  su  
    ++  mcol
    ++  pode  
    ++  sube  
  ++  be      
          ++  ankh
          ++  sark
          ++  srow
          ++  subs
  ++  ex      
  ++  ix      
++  curt      
        ++  cla
        ++  sqr
        ++  inv
        ++  cad
        ++  cub
++  ed         
    ++  norm  
    ++  xrec  
    ++  ward  
    ++  scam  
    ++  etch  
    ++  curv  
    ++  deco  
    ++  bb
  ++  puck    
  ++  suck    
  ++  sign    
  ++  veri    

section 2eY, SHA-256 

++  shad  
++  shaf  
++  shak  
++  sham  
++  shas  
++  shax  
++  shaw  
++  og    
  ++  rad 
  ++  raw 
++  shaz  
++  shal  
++  shan  

section 2eZ, OLD rendering

++  show  
  ++  shep
  ++  shop
++  at
  ++  r
  ++  rf 
  ++  rn 
  ++  rt 
  ++  rta
  ++  rtam
  ++  rub 
  ++  rud 
  ++  rum
  ++  rup
  ++  ruv
  ++  rux 

chapter 2f, Hoon proper

section 2fA, miscellaneous funs       

++  bull
++  cain  
++  cell
++  core
++  cube
++  face
++  bean  
++  flay
++  flee
++  foil
++  fork
++  cove
++  comb
++  cond
++  cons
++  fitz
++  flan
++  flip
++  flor
++  hike
++  hoax
++  hoof
++  jock
++  look
++  make
++  noah  
++  onan  
++  rain
++  ream
++  reck
++  seed
++  seem  
++  seer  
++  sell
++  pave
++  loot
++  slam
++  slim
++  slit
++  slym
++  slap
++  slop
++  skol
++  spat  
++  spuc
++  spec
++  spud  
++  slot
++  slum
++  stab
++  wash

section 2fB, macro expansion          

++  ah
  ++  blue
  ++  gray
  ++  puce
++  al
  ++  blah
  ++  home
  ++  bunt
  ++  clam
  ++  cloq
  ++  whip
++  ap
  ++  etch
  ++  feck
  ++  hock
  ++  open
  ++  rake
  ++  rusk

section 2fC, compilation proper       

++  ut
  ++  burn
  ++  busk
  ++  conk
  ++  crop
    ++  dext
    ++  sint
  ++  cool
  ++  dank
  ++  dart
  ++  deal
  ++  dial
  ++  dish
  ++  doge
  ++  dole
  ++  duck
  ++  dune
  ++  dunk
  ++  fino
  ++  fink
  ++  finq
  ++  fire
  ++  firm
  ++  fish
  ++  fuse
  ++  gain
  ++  hang
  ++  harp
  ++  lose
  ++  chip
  ++  heal
  ++  mint
    ++  nice
    ++  grow
  ++  moot
  ++  mull
    ++  both
    ++  nice
    ++  grow
    ++  bake
  ++  meet  
  ++  nest
    ++  cong
    ++  cram
    ++  dext
    ++  sint
  ++  park
  ++  peek
  ++  play
  ++  reco
  ++  repo
  ++  rest
  ++  seek
  ++  seep
  ++  sift
  ++  snub
  ++  tack
  ++  tock
  ++  wrap

section 2fD, grammar                  

++  vang
++  vast
  ++  gash  
  ++  gasp  
  ++  glam  
  ++  hasp  
  ++  mota  
  ++  plex
  ++  pray
  ++  prey
  ++  phax
  ++  posh
  ++  poof
  ++  poon
  ++  poor
  ++  porc
  ++  rump
  ++  rood
  ++  rupl
  ++  sail 
    ++  ape
    ++  amp
    ++  bam
    ++  bat
    ++  bet
    ++  fry
    ++  hag
    ++  hig
    ++  hog
    ++  hoy
    ++  hul
    ++  jaw
    ++  lif
    ++  luf
    ++  nal
    ++  nol
    ++  nol
    ++  nup
    ++  pab
    ++  ped
    ++  pep
    ++  puv
    ++  rab
    ++  sag
  ++  scat
  ++  soil
  ++  sump 
  ++  noil
    ++  toad
    ++  rung
    ++  gunk
    ++  muck
    ++  butt
    ++  loaf
    ++  lobe
    ++  exqa
    ++  exqb
    ++  exqc
    ++  exqd
    ++  exqe
  ++  norm
    ++  boog
    ++  wisp
    ++  toad
    ++  rune
    ++  glop
    ++  gunk
    ++  butt
    ++  ulva
    ++  hank
    ++  loaf
    ++  lobe
    ++  mash
    ++  muck
    ++  teak
    ++  race
    ++  rack
    ++  rick
    ++  expa
    ++  expb
    ++  expc
    ++  expd
    ++  expe
    ++  expf
    ++  expg
    ++  exph
    ++  expi
    ++  expj
    ++  expk
    ++  expm
    ++  expn
    ++  expo
    ++  expp
    ++  expq
    ++  expr
    ++  exps
    ++  expt
    ++  expu
    ++  expv
    ++  expw
    ++  expx
    ++  expy
    ++  expz
    ++  hina
    ++  hinb
    ++  hinc
    ++  hind
    ++  hine
    ++  hinf
    ++  hing
    ++  bonk
    ++  bont
    ++  bony
    ++  bonz
  ++  lung
  ++  long
  ++  lobo
  ++  loon
  ++  lute
  ++  rope
  ++  tall
  ++  wide
  ++  hill
  ++  howl
  ++  toil
  ++  wart
++  vest
++  vice

volume 3, Arvo models and skeleton

++  arch  
++  bead  
++  care  
++  case  
++  desk  
++  cage  
++  chop  
++  curd  
++  disk  
++  duct  
++  gene  
++  glob  
++  herd  
++  hilt  
++  hypo  
++  khan  
++  lens    
      ++  v 
      ++  w 
      ++  x 
      ++  y 
      ++  z 
++  logo 
++  lode 
++  mark 
++  mill 
++  milt 
++  monk 
++  mold 
++  muse 
++  mosh 
++  move 
++  ovum 
++  pane 
++  pone 
++  ship 
++  sled 
++  slut 
++  vile 
++  wire 
++  slod 
++  slub 

section 3bE, Arvo core                

++  vent 
  ++  ruck   
  ++  wink   
    ++  doze
    ++  sike
    ++  souk
    ++  sunk
    ++  song
    ++  spuc
    ++  sump
    ++  said
    ++  scry
    ++  soar
    ++  swim
++  vint    
++  viol    
++  is      
  ++  beck
  ++  dink  
  ++  dint  
  ++  doos  
  ++  hurl  
  ++  race  
  ++  fire  
  ++  jack  
  ++  kick  

Postface

    ++  come
    ++  keep
    ++  load
    ++  peek
    ++  poke
    ++  wish
++  come    
++  keep    
++  load    
++  peek    
++  poke    
++  vega    
++  veer    
++  wish    
