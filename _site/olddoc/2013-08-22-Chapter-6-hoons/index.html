<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Chapter 6 &#58; 29 ways of looking at a hoon &middot; Urbit
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">

  <!-- Icons -->

   <link rel="shortcut icon" href="/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <img src="/public/urbit_logo_ur.svg">
      <br>
      <h1>Urbit</h1>
      <p class="lead">a personal cloud computer</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
        <a href="/">What is Urbit?</a>
      </li>

      

      
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/about/">About</a>
            </li>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
<<<<<<< HEAD
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
=======
>>>>>>> fbe1946cebf8a6abfa8ee8fce81a18646724a412
            <li class="sidebar-nav-item">
              <a href="/blog/">Blog</a>
            </li>
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/dev/">Developer</a>
            </li>
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/doc/">Documentation</a>
            </li>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/setup/">Setup</a>
            </li>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <li class="sidebar-nav-item"><a href="https://github.com/urbit/urbit">GitHub</a></li>
      <li class="sidebar-nav-item"><a href="https://groups.google.com/forum/#!forum/urbit-dev">Mailing List</a></li>
      <li class="sidebar-nav-item">Cooling at <a href="/blog/2014/02/16/mars/">544 Kelvin</a></li>
      <li>Last Continuity Breach: <a href="/blog/2014/01/06/continuity/">~2014.1.6</a></li>
    </ul>
    <p>urbit@urbit.org</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Chapter 6 &#58; 29 ways of looking at a hoon</h1>
  <p>Since writing the last chapter (this here is a <em>living document</em>,
darn it), we&#39;ve bowed to the inevitable and changed the name of
the Hoon AST node type from the vague and pretentious <code>gene</code>, to
the bold country-flavored <code>hoon</code>.  </p>

<p>This can and will be deployed broadly - it is ridiculous to speak
of &quot;Hoon runes&quot; when you could just say &quot;hoons.&quot;  Somehow the
same word means the symbol, the source code, the expression, etc.</p>

<p>Let&#39;s start off with two big hoons.  The first is the definition
of <code>++hoon</code> (in /~ship/arvo=/hoon/hoon):</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">      |%                                                      ::
      ++  axis  ,@                                            ::
      ++  beer  $|(@ [~ p=hoon])                              ::
      ++  foot  $%  [%ash p=hoon]                             ::
                    [%elm p=hoon]                             ::
                    [%oak ~]                                  ::
                    [%yew p=(map term foot)]                  ::
                ==                                            ::
      ++  gens  (list hoon)                                   ::
      ++  gent  (list ,[p=hoon q=hoon])                       ::
      ++  genu  (list ,[p=term q=hoon])                       ::
      ++  goon  (list (unit hoon))                            ::
      ++  hoon  $&amp;  [p=hoon q=hoon]                           ::
                $%                                            ::
                  [%$ p=axis]                                 ::
                ::                                            ::
                  [%bcbr p=hoon q=hoon]                       ::
                  [%bccb p=hoon]                              ::
                  [%bccl p=gens]                              ::
                  [%bccn p=hoon q=gens]                       ::
                  [%bccm p=hoon]                              ::
                  [%bckt p=hoon]                              ::
                  [%bcpm p=hoon q=hoon]                       ::
                  [%bctr p=hoon]                              ::
                  [%bcts p=bozo]                              ::
                  [%bcwt p=hoon q=gens]                       ::
                ::                                            ::
                  [%brbr p=hoon q=hoon]                       ::
                  [%brcb p=hoon q=(map term foot)]            ::
                  [%brcl p=hoon q=(map term foot)]            ::
                  [%brcn p=(map term foot)]                   ::
                  [%brdt p=hoon]                              ::
                  [%brkt p=hoon q=(map term foot)]            ::
                  [%brhp p=hoon]                              ::
                  [%brls p=hoon q=hoon]                       ::
                  [%brtr p=hoon q=hoon]                       ::
                  [%brts p=hoon q=hoon]                       ::
                  [%brwt p=hoon]                              ::
                ::                                            ::
                  [%clcb p=hoon q=hoon]                       ::
                  [%clcn p=gens]                              ::
                  [%clfs p=hoon]                              ::
                  [%clkt p=hoon q=hoon r=hoon s=hoon]         ::
                  [%clhp p=hoon q=hoon]                       ::
                  [%clls p=hoon q=hoon r=hoon]                ::
                  [%clsg p=gens]                              ::
                  [%cltr p=gens]                              ::
                  [%clzp p=gens]                              ::
                ::                                            ::
                  [%cnbc p=term]                              ::
                  [%cncb p=wing q=gent]                       ::
                  [%cncl p=hoon q=hoon]                       ::
                  [%cndt p=hoon q=hoon]                       ::
                  [%cnhp p=hoon q=gens]                       ::
                  [%cnhx p=wing]                              ::
                  [%cntr p=wing q=hoon r=gent]                ::
                  [%cnkt p=hoon q=hoon r=hoon s=hoon]         ::
                  [%cnls p=hoon q=hoon r=hoon]                ::
                  [%cnsg p=wing q=hoon r=hoon]                ::
                  [%cnts p=wing q=gent]                       ::
                ::                                            ::
                  [%dtkt p=hoon]                              ::
                  [%dtls p=hoon]                              ::
                  [%dtpt p=term q=@]                          ::
                  [%dtsg p=term q=*]                          ::
                  [%dttr p=hoon q=hoon]                       ::
                  [%dtts p=hoon q=hoon]                       ::
                  [%dtwt p=hoon]                              ::
                ::                                            ::
                  [%hxgl p=gens]                              ::
                  [%hxgr p=gens]                              ::
                ::                                            ::
                  [%ktbr p=hoon]                              ::
                  [%ktls p=hoon q=hoon]                       ::
                  [%ktdt p=hoon q=hoon]                       ::
                  [%kthp p=hoon q=hoon]                       ::
                  [%ktpm p=hoon]                              ::
                  [%ktsg p=hoon]                              ::
                  [%ktts p=term q=hoon]                       ::
                  [%ktwt p=hoon]                              ::
                ::                                            ::
                  [%sgbr p=hoon q=hoon]                       ::
                  [%sgcl p=[p=@ q=@] q=hoon]                  ::
                  [%sgcn p=chop q=hoon r=genu s=hoon]         ::
                  [%sgfs p=chop q=hoon]                       ::
                  [%sggl p=$|(term [p=term q=hoon]) q=hoon]   ::
                  [%sggr p=$|(term [p=term q=hoon]) q=hoon]   ::
                  [%sgbc p=term q=hoon]                       ::
                  [%sghx p=term q=hoon]                       ::
                  [%sgkt p=hoon q=hoon]                       ::
                  [%sgls p=@ q=hoon]                          ::
                  [%sgpm p=@ud q=hoon r=hoon]                 ::
                  [%sgts p=hoon q=hoon]                       ::
                  [%sgwt p=@ud q=hoon r=hoon s=hoon]          ::
                  [%sgzp p=hoon q=hoon]                       ::
                ::                                            ::
                  [%smcb p=hoon q=hoon]                       ::
                  [%smcl p=hoon q=gens]                       ::
                  [%smcm p=hoon q=gens]                       ::
                  [%smcn p=gens]                              ::
                  [%smdt p=hoon q=gens]                       ::
                  [%smdq p=(list beer)]                       ::
                  [%smgl p=hoon q=hoon r=hoon]                ::
                  [%smgr p=hoon q=hoon r=hoon]                ::
                  [%smkt p=hoon q=hoon]                       ::
                  [%smhp p=hoon q=hoon]                       ::
                  [%smhx p=(list beer)]                       ::
                  [%smls p=hoon q=hoon]                       ::
                  [%smpm p=hoon q=gens]                       ::
                  [%smsg p=hoon q=gens]                       ::
                  [%smsm p=hoon q=hoon]                       ::
                  [%smtr p=hoon q=hoon]                       ::
                  [%smts p=hoon q=hoon]                       ::
                  [%smwt p=hoon q=hoon]                       ::
                ::                                            ::
                  [%tsbr p=hoon q=hoon]                       ::
                  [%tscl p=gent q=hoon]                       ::
                  [%tsdt p=hoon q=hoon r=hoon]                ::
                  [%tsgl p=hoon q=hoon]                       ::
                  [%tsgr p=hoon q=hoon]                       ::
                  [%tskt p=hoon q=hoon r=hoon s=hoon]         ::
                  [%tsls p=hoon q=hoon]                       ::
                  [%tshp p=hoon q=hoon]                       ::
                  [%tssg p=gens]                              ::
                ::                                            ::
                  [%wtbr p=gens]                              ::
                  [%wthp p=hoon q=gent]                       ::
                  [%wtcl p=hoon q=hoon r=hoon]                ::
                  [%wtcn p=hoon q=hoon]                       ::
                  [%wtdt p=hoon q=hoon r=hoon]                ::
                  [%wtkt p=hoon q=hoon r=hoon]                ::
                  [%wtgl p=hoon q=hoon]                       ::
                  [%wtgr p=hoon q=hoon]                       ::
                  [%wtls p=hoon q=hoon r=gent]                ::
                  [%wtpm p=gens]                              ::
                  [%wtpt p=hoon q=hoon r=hoon]                ::
                  [%wtsg p=hoon q=hoon r=hoon]                ::
                  [%wtts p=hoon q=hoon]                       ::
                  [%wtzp p=hoon]                              ::
                ::                                            ::
                  [%zpcb p=spot q=hoon]                       ::
                  [%zpcm p=hoon q=hoon]                       ::
                  [%zpcn ~]                                   ::
                  [%zpfs p=hoon]                              ::
                  [%zpgr p=hoon]                              ::
                  [%zpsm p=hoon q=hoon]                       ::
                  [%zpts p=hoon]                              ::
                  [%zpzp ~]                                   ::
                ==                                            ::
      ++  limb  $|(term $%([&amp; p=axis] [| p=@ud q=term]))      ::
      ++  pint  ,[p=[p=@ q=@] q=[p=@ q=@]]                    ::
      ++  spot  ,[p=path q=pint]                              ::
      ++  term  ,@tas                                         ::
      ++  wing  (list limb)                                   ::
      --
</code></pre></div>
<p>Wha?  Of course, we learned to use this subset of Hoon in the
last chapter.  We know that <code>++hoon</code> is a function which
normalizes an untyped noun into a hoon.  (And Australians,
really, you can stop laughing now.)</p>

<p>But perhaps we missed the <code>$&amp;</code> hoon.   This tells us that hoons
use the same &quot;autocons&quot; trick as Nock formulas.  </p>

<p>A hoon is always a cell.  If the head of that hoon is also a
cell, the whole hoon is a cell [p=hoon q=hoon], and its product
against any subject is the equivalent of Lisp <code>(cons p q)</code>.  But
there is no <code>cons</code> in Hoon - you just say <code>[p q]</code>.</p>

<p>The next simplest kind of hoon is exactly the same as the Nock
formula.  <code>%$</code> is the empty formula and an <code>axis</code> is just <code>@</code>,
so <code>[%$ p=axis]</code> just means the cell <code>[0 p]</code>, as in Nock <code>/p</code>.</p>

<p>This reminds us that Hoon is just Nock in a fancy suit.  In Nock,
we write a Nock formula that specifies a function of the subject.
In Hoon we write a hoon that, with the semantic assistance of the
subject type, is converted into a Nock formula.  Much as C is
just a fancy macro assembler for machine code, Hoon is just a
fancy macro assembler for Nock.</p>

<p>The basic function in this assembler is <code>++mint</code>, which maps a 
cell <code>[type hoon]</code> to a cell <code>[type nock]</code>.  (If you look at the
code for <code>++mint</code>, you&#39;ll see it also takes a second type <code>gol</code>,
but this goal type is only for more accurate error location.)</p>

<p>But in the compiler core, <code>++ut</code>, there are only three arms
where we <code>?-</code> on this giant clan of hoons.  These are <code>++mint</code>;
<code>++play</code>, an abbreviated mint that only does type inference;
and <code>++mung</code>, which implements generic polymorphism.  Let&#39;s look
at <code>++play</code>, because it&#39;s the simplest.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    |%
    ++  play  
      ~/  %play
      =&gt;  .(vet |)
      |=  gen=hoon
      ?-  gen
        [^ *]      (cell $(gen p.gen) $(gen q.gen))
        [%brcl *]  (heir(sut $(gen p.gen)) q.gen)
        [%brcn *]  (core sut %gold sut [[%0 0] p.gen])
        [%cnts *]  =+  lar=(foil (seek %read p.gen))
                   =+  mew=(swab q.gen)
                   =+  rag=q.q.lar
                   %-  fire
                   |-  ^-  (list ,[p=type q=foot])
                   ?~  mew
                     rag
                   $(mew t.mew, rag q:(tock p.i.mew ^$(gen q.i.mew) rag))
        [%dtkt *]  %noun
        [%dtls *]  [%atom %$]
        [%dtpt *]  ?:(=(%f p.gen) ?&gt;((lte q.gen 1) bean) [%atom p.gen])
        [%dtsg *]  [%cube q.gen ?:(.?(q.gen) %noun [%atom p.gen])]
        [%dttr *]  %noun
        [%dtts *]  bean
        [%dtwt *]  bean
        [%ktbr *]  (wrap(sut $(gen p.gen)) %iron)
        [%ktdt *]  $(gen (snap(sut $(gen p.gen)) q.gen))
        [%ktls *]  $(gen p.gen)
        [%ktpm *]  (wrap(sut $(gen p.gen)) %zinc)
        [%ktsg *]  $(gen p.gen)
        [%ktts *]  (face p.gen $(gen q.gen))
        [%ktwt *]  (wrap(sut $(gen p.gen)) %lead)
        [%sggr *]  $(gen q.gen)
        [%tsgr *]  $(gen q.gen, sut $(gen p.gen))
        [%wtcl *]  =+  [fex=(gain p.gen) wux=(lose p.gen)]
                   %+  fork
                     ?:(=(%void fex) %void $(sut fex, gen q.gen))
                   ?:(=(%void wux) %void $(sut wux, gen r.gen))
        [%wtcn *]  bean
        [%zpcb *]  ~!((show %o p.gen) $(gen q.gen))  
        [%zpcm *]  (play p.gen)
        [%zpcn ~]  p:seed
        [%zpfs *]  %void
        [%zpsm *]  (cell $(gen p.gen) $(gen q.gen))
        [%zpts *]  %noun
        [%zpzp ~]  %void
        *          =+  doz=~(open ap gen) 
                   ?:  =(doz gen)
                     ~!  (show [%c &#39;hoon&#39;] [%q gen])
                     ~|(%play-open !!)
                   $(gen doz)
      ==
    --
</code></pre></div>
<p>The first thing we notice about this code, which almost fits on a
page but doesn&#39;t quite, is that there are only 28 runes we
evaluate directly.  The rest go into <code>++open</code> in <code>++ut</code>, where
they are expanded as macros.</p>

<p>Which makes no difference at all if you&#39;re trying to learn Hoon
from the top down, tutorial style.  We&#39;ll do that later.  But if
you&#39;re trying to understand it from the bottom up... that means,
there are only 28 runes we have to understand.  And honestly,
most of them are pretty minor.</p>

<p>Let&#39;s start with a simple but important one:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %wtcl ?: &quot;wutcol&quot; [%wtcl p=hoon q=hoon r=hoon]
</code></pre></div>
<p>This is exactly the same as the C operator and has the same
semantics.  It&#39;s also the same as Nock operator <code>6</code>.</p>

<p>So how do we infer type through it?  Since both <code>q</code> and <code>r</code> are
applied to the same subject as the original hoon, you might think 
the code would be </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    [%wtcl *]  [%fork $(gen q.gen) $(gen r.gen)]
</code></pre></div>
<p>But in fact, it&#39;s </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    [%wtcl *]  =+  [fex=(gain p.gen) wux=(lose p.gen)]
               %+  fork
                 ?:(=(%void fex) %void $(sut fex, gen q.gen))
               ?:(=(%void wux) %void $(sut wux, gen r.gen))
</code></pre></div>
<p>What&#39;s going on here is that we analyze <code>p.gen</code>, the test in the
if, to refine the subject type.  On either branch, we&#39;ve learned
something about the subject, so we should have a new type -
created by <code>++gain</code> for the yes branch, <code>++lose</code> for the no.
Then, the product type is the union of both branches.</p>

<p>The power of <code>+gain</code> and <code>++lose</code> shouldn&#39;t be overstated.  It
can analyze simple boolean logic (but is not a SAT solver) and
can use the results of <code>?%</code> (which is normally used through the
macro <code>?=</code>, testing if a noun matches a type.  </p>

<p>Moreover, this is not enforced in <code>++play</code>, but when the type
system figures out that a path isn&#39;t taken, that&#39;s an error -
you&#39;ll see <code>mint-vain</code>, meaning that your code is in vain.</p>

<p>When you see the <code>?-</code> pattern-matching macro, it simply resolves
down to a series of <code>?:</code> tests.  Eventually it should probably be
pulled into <code>++ut</code>, to be more efficient than linear search.</p>

<p><code>wutcol</code> is actually the second most important hoon.  Let&#39;s do the
most important and complex:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %cnts %= &quot;centis&quot; [%cnts p=wing q=gent]
</code></pre></div>
<p><code>centis</code> could be described as &quot;query with changes.&quot;  First let&#39;s
look at the data structures it uses:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    ++  axis  ,@
    ++  gent  (list ,[p=hoon q=hoon])
    ++  limb  $|(term $%([&amp; p=axis] [| p=@ud q=term]))
    ++  term  ,@tas
    ++  wing  (list limb)
</code></pre></div>
<p><code>p</code> is the query, <code>q</code> the changes.  Let&#39;s forget about <code>q</code> and
just think about <code>p</code> for right now.</p>

<p>What is a <code>wing</code>?  It&#39;s a way to reference either a part of a
typed noun (a fragment, as in Nock <code>/</code>; or <code>leg</code>), or a computed
expression (<code>arm</code>).  Each <code>limb</code> in the wing can be either a tree
address (like <code>+3</code>, meaning Nock&#39;s <code>/3</code>) or a name (like <code>foo</code>).
Syntactically, these run outward from right to left, so</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    +3.foo.bar.+7.moo
</code></pre></div>
<p>means &quot;+3 in foo in bar in +7 in moo&quot; - ie, the opposite of the 
&quot;object.attribute&quot; order you&#39;re used to from Earth languages.</p>

<p>Obviously, <code>+3</code> is always a leg.  Whereas <code>moo</code> can resolve
either when it finds a <code>%face</code>, or when it finds a <code>%core</code>.
When searching in a type, the search stops at a <code>%face</code> that
conflicts with the term we&#39;re looking for, but continues into 
the payload of a <code>%core</code> that doesn&#39;t have an arm that matches
the term we&#39;re looking for.  </p>

<p>Moreover, a term limb has a numeric parameter that lets us skip
the first <code>p</code> matches; so, <code>moo</code> means the first <code>moo</code> we find,
but <code>^^moo</code> means &quot;skip over the first 2 <code>moo</code>s we find and
accept the third.&quot;</p>

<p>This explains mysterious usages like <code>^^$</code>.  <code>$</code> is just a syntax
for the empty symbol - <code>$</code> compares to <code>%$</code> as <code>moo</code> to %moo.
The one is a limb, the other a constant.  In practice, <code>$</code> is
used for &quot;the nameless function or loop we&#39;re inside.&quot;  </p>

<p>So <code>^$</code> gives us the functional equivalent of multi-level break.
Indeed, if there is one practical problem with most functional
languages, it&#39;s the inability to refer to anonymous functions
that you&#39;re inside.</p>

<p>Finally, what happens if you resolve to an arm midway through
the wing?  Eg, </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    foo.bar.moo.baz
</code></pre></div>
<p>where <code>moo.baz</code> is an arm?  As you might expect, <code>moo.baz</code>
resolves to the core containing <code>++moo</code>, and <code>foo.bar</code>
references into it.  This explains bizarre tokens like
<code>..$</code>; the simplest limb is <code>.</code>, meaning <code>+1</code>, so <code>..$</code>
means <code>+1.$</code> - ie, it refers to the nameless function we&#39;re
inside, without actually calling it.</p>

<p>Then we have the changes.  Actually, Hoon in Hoon is relatively
old code, and done right it would be </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    ++  gent  (list ,[p=wing q=hoon])
</code></pre></div>
<p>But a wing is one case of a hoon, so we just parse it as a
general hoon and reduce it by brute force.</p>

<p>This isn&#39;t rocket science: we produce the query described in <code>p</code>,
with each of the wings in <code>q</code> replaced by the corresponding hoon
(computed against the current subject).  So, for example, when
calling a classic function, we produce a gate or &quot;lambda&quot; of the
form </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    [formula [sample context]]
</code></pre></div>
<p>and evaluate the formula (typically the single arm <code>$</code>) with the
sample, (<code>+6</code>), replaced with your actual argument.  Hence, the
code for this, supposing you have your gate in <code>moo</code>, and your
argument is <code>bar</code>, would look like</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %=  $.moo
      +6  bar
    ==
</code></pre></div>
<p>and <code>centis</code> in this case means &quot;replace the sample with the
argument, and execute the function body.&quot;</p>

<p>And with <code>?:</code> and <code>%=</code>, we&#39;ve actually explained all the really
interesting hoons.  The rest are boring.  But let&#39;s go through
them anyway.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %brcl |: &quot;barcol&quot; [%brcl p=hoon q=(map term foot)]
</code></pre></div>
<p><code>barcol</code> does inheritance.  This isn&#39;t used in Hoon or Arvo now,
so don&#39;t use it or expect it to work.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %brcn |% &quot;barcen&quot; [%brcn p=(map term foot)]
</code></pre></div>
<p><code>barcen</code> is the way we create cores.  For any subject type <code>sut</code>,
<code>barcen</code> produces the core type <code>[%core sut %gold ~ p.gen]</code>.  If
the subject noun is <code>ctx</code>, the product is <code>[bat ctx]</code>, where
<code>bat</code> is the battery generated by <code>p.gen</code>.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %dtkt .^ &quot;dotket&quot; [%dtkt p=hoon]
</code></pre></div>
<p><code>dotket</code> dereferences the global namespace, generating Nock
operator 11.  &quot;But there is no Nock operator 11,&quot; you protest.
That&#39;s right - but your Arvo code runs not in Nock, but in a
<em>superset</em> of it, <code>++mock</code>, in which there is an operator 11.<br>
Its operand is an untyped noun and so is its product.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %dtls .+ &quot;dotlus&quot; [%dtls p=hoon]
</code></pre></div>
<p>Nock increment.  Requires and produces an atom, obviously.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %dtpt .@ &quot;dotpat&quot; [%dtpt p=term q=@] 
</code></pre></div>
<p>Constant atom.  <code>p</code> is the odor.  Just generated by the parser -
you won&#39;t see any <code>.@</code> runes in your Hoon file.  The type is
<code>[%atom p.gen]</code>.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %dtsg .~ &quot;dotsig&quot; [%dtsg p=term q=*] 
</code></pre></div>
<p>Constant atom or cell.  You might think this is redundant with
<code>%dtpt</code>, but the type it produces is a <code>%cube</code>, typed as a 
constant - eg, if <code>q</code> is an atom, <code>[%cube [%atom p.gen] q.gen]</code>.
Still, there is something confusing and ugly here.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %dttr .* &quot;dottar&quot; [%dttr p=hoon q=hoon]
</code></pre></div>
<p>Nock <code>2</code>.  If you want to run Nock from Hoon without another
layer of virtualization, this is what you use.  Needless to say,
the product is an untyped noun.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %dtts .= &quot;dottis&quot; [%dtts p=hoon q=hoon]
</code></pre></div>
<p>Nock <code>5</code>, ie, equals.  <code>0</code> is yes, <code>1</code> is no.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %dtwt .? &quot;dotwut&quot; [%dtwt p=hoon]
</code></pre></div>
<p>Nock <code>3</code> - <code>0</code> (yes, <code>&amp;</code>) for cell, <code>1</code> (false, <code>|</code>) for atom.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %ktbr ^| &quot;ketbar&quot; [%ktbr p=hoon]
</code></pre></div>
<p><code>ketbar</code> converts a gold core to <code>%iron</code>, ie, contravariant.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %ktdt ^. &quot;ketdot&quot; [%ktdt p=hoon q=hoon]
</code></pre></div>
<p><code>ketdot</code> - snap.  This takes the superficial namespace of 
<code>p</code> and applies it to <code>q</code>.  You will never use this; it appears
only in the bowels of macros; and if we had to explain why it
exists at all, we&#39;d be embarrassed.  So we won&#39;t.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %ktpm ^&amp; &quot;ketpam&quot; [%ktpm p=hoon q=hoon]
</code></pre></div>
<p><code>ketpam</code> converts a gold core to <code>%zinc</code>, ie, covariant.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %ktls ^+ &quot;ketlus&quot; [%ktls p=hoon q=hoon]
</code></pre></div>
<p><code>ketlus</code> casts <code>q.gen</code> to <code>p.gen</code>, so long as <code>q.gen</code> is
geometrically compatible with <code>p.gen</code> (ie, any product of
<code>q.gen</code> with the present subject can be used as if it was
the product of <code>p.gen</code> with the present subject).</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %ktsg ^~ &quot;ketsig&quot; [%ktsg p=hoon]
</code></pre></div>
<p><code>ketsig</code> tries to execute <code>p.gen</code> statically at compile time.
If it fails, it just leaves the dynamic expression.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %ktts ^= &quot;kettis&quot; [%ktts p=term q=hoon]
</code></pre></div>
<p><code>kettis</code> wraps a <code>%face</code> around <code>q.gen</code>, ie, names it.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %ktwt ^? &quot;ketwut&quot; [%ktwt p=hoon q=hoon]
</code></pre></div>
<p><code>ketwut</code> converts any core to <code>%lead</code>, ie, bivariant.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %sggr ~&gt; &quot;siggar&quot; [%sggr p=$|(term [p=term q=hoon]) q=hoon]
</code></pre></div>
<p><code>siggar</code> is a hint - any hint (Nock <code>10</code>).  There are many hints,
all semantically transparent.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %tsgr =&gt; &quot;tisgar&quot; [%tsgr p=hoon q=hoon]
</code></pre></div>
<p><code>tisgar</code> uses the product of <code>p</code> as the subject of <code>q</code>.  The code
from <code>++play</code> should say it all: <code>$(gen q.gen, sut $(gen p.gen))</code></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %wtcn ?% &quot;wutcen&quot; [%wtcn p=hoon q=hoon]
</code></pre></div>
<p><code>wutcen</code>, normally used only through the macro <code>?=</code>, is true if
and only if the dynamic product of <code>q</code> is in the range of <code>p</code>.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %zpcb !_ &quot;zapcab&quot; [%zpcb p=spot q=hoon]
</code></pre></div>
<p><code>zapcab</code> is only generated by the parser, within a <code>!:</code> hoon,
to produce debugging traces.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %zpcm !, &quot;zapcom&quot; [%zpcm p=hoon q=hoon]
</code></pre></div>
<p><code>zapcom</code> produces the literal hoon <code>q</code> as a constant, casting it
to the type of <code>p</code> - which had better be <code>++hoon</code>.  This should
be enforced, but isn&#39;t right now.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %zpcn !% &quot;zapcen&quot; [%zpcn ~]
</code></pre></div>
<p><code>zapcen</code> is obsolete but used to help with booting.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %zpfs !/ &quot;zapfas&quot; [%zpfs p=hoon]
</code></pre></div>
<p><code>zapfas</code>, only generated by the parser, indicates a path that
should never be taken.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %zpsm !; &quot;zapsem&quot; [%zpsm p=hoon q=hoon]
</code></pre></div>
<p><code>zapsem</code> produces a <code>[type value]</code> pair, sometimes known as
a <code>vase</code>.  <code>p</code> should be <code>++type</code>.  This should be checked,
but isn&#39;t.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %zpts != &quot;zaptis&quot; [%zpts p=hoon]
</code></pre></div>
<p><code>zaptis</code> produces the Nock formula generated by <code>p</code> as an
untyped noun.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    %zpzp !! &quot;zapzap&quot; [%zpzp ~]
</code></pre></div>
<p><code>zapzap</code> always exits, and of course produces void.</p>

</div>



    </div>

  </body>
</html>
