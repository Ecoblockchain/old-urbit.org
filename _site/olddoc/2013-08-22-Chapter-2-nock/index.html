<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Chapter 2 &#58; Crash course in Nock &middot; Urbit
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">

  <!-- Icons -->

   <link rel="shortcut icon" href="/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <img src="/public/urbit_logo_ur.svg">
      <br>
      <h1>Urbit</h1>
      <p class="lead">a personal cloud computer</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
        <a href="/">What is Urbit?</a>
      </li>

      

      
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/about/">About</a>
            </li>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/blog/">Blog</a>
            </li>
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/dev/">Developer</a>
            </li>
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/doc/">Documentation</a>
            </li>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/setup/">Setup</a>
            </li>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <li class="sidebar-nav-item"><a href="https://github.com/urbit/urbit">GitHub</a></li>
      <li class="sidebar-nav-item"><a href="https://groups.google.com/forum/#!forum/urbit-dev">Mailing List</a></li>
      <li class="sidebar-nav-item">Cooling at 544 Kelvin</li>
      <li>Last Continuity Breach: <a href="/blog/2014/01/06/continuity/">~2014.1.6</a></li>
    </ul>
    <p>urbit@urbit.org</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Chapter 2 &#58; Crash course in Nock</h1>
  <p>So let&#39;s learn Nock!  But wait - why learn Nock?  After all,
we&#39;re going to be programming in Hoon, not Nock.</p>

<p>Like JVM bytecode, Nock is as inscrutable as assembly language.
In fact, you can think of it as a sort of &quot;functional assembly
language.&quot;  There are sometimes reasons to program in real
assembly language.  There is never a reason to program in Nock.
Except to learn Nock.</p>

<p>Indeed, it is not necessary for the Hoon programmer to learn
Nock.  We recommend it strongly, however, because Hoon has a very
special relationship with Nock - not unlike the relationship
between C and assembly language.  </p>

<p>Just as C is a very shallow layer over the raw CPU, Hoon is a
very shallow layer over raw Nock - often little more than a
macro.  If you try to learn C without understanding the CPU under
it, you will be forever bemused by why it works the way it does.</p>

<p>So let&#39;s learn Nock!  But wait - which Nock?  Nock, though more
frozen than Walt Disney, does have versions.  Nock versions are
measured by integer degrees Kelvin, newer being colder.  The
newest, Nock 5K - roughly the temperature of Neptune. No change
is anticipated between 5K and absolute zero, though you never
know.  Any such change would certainly be quite painful.</p>

<h1>1.1 Definition</h1>

<p>The best way to learn Nock is to read the spec and write your own
naive interpreter.  Here is Nock 5K:</p>

<p><strong>1. Structures</strong></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">A noun is an atom or a cell.  An atom is a natural number.  
A cell is an ordered pair of nouns.
</code></pre></div>
<p><strong>2. Pseudocode</strong></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    1  ::    nock(a)             *a
    2  ::    [a b c]             [a [b c]]
    3  ::
    4  ::    ?[a b]              0
    5  ::    ?a                  1
    6  ::    +[a b]              +[a b]
    7  ::    +a                  1 + a
    8  ::    =[a a]              0
    9  ::    =[a b]              1
    10 ::    =a                  =a
    11 ::
    12 ::    /[1 a]              a
    13 ::    /[2 [a b]]          a
    14 ::    /[3 [a b]]          b
    15 ::    /[(a + a) b]        /[2 /[a b]]
    16 ::    /[(a + a + 1) b]    /[3 /[a b]]
    17 ::    /a                  /a
    18 ::
    19 ::    *[a [[b c] d]]      [*[a [b c]] *[a d]]
    20 ::
    21 ::    *[a [0 b]]          /[b a]
    22 ::    *[a [1 b]]          b
    23 ::    *[a [2 [b c]]]      *[*[a b] *[a c]]
    24 ::    *[a [3 b]]          ?*[a b]
    25 ::    *[a [4 b]]          +*[a b]
    26 ::    *[a [5 b]]          =*[a b]
    27 ::
    28 ::    *[a [6 [b [c d]]]]  *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
    29 ::    *[a [7 [b c]]]      *[a 2 b 1 c]
    30 ::    *[a [8 [b c]]]      *[a 7 [[7 [0 1] b] 0 1] c]
    31 ::    *[a [9 [b c]]]      *[a 7 c 2 [0 1] 0 b]
    32 ::    *[a [10 [[b c] d]]] *[a 8 c 7 [0 3] d]
    33 ::    *[a [10 [b c]]]     *[a c]
    34 ::
    35 ::    *a                  *a
</code></pre></div>
<p>Your interpreter should be no more than a page of code in
any language.  For extra credit, <code>6</code>-<code>10</code> are macros; implement 
them directly.  For extra extra credit, optimize tail calls.
To test your code, write a decrement formula b such that
<code>*[a b]</code> is <code>a - 1</code> for any atomic nonzero <code>a</code>.</p>

<h1>1.2 Installation</h1>

<p>The second best way to learn Nock is to boot up your own Arvo
virtual computer.  See the Arvo tutorial for instructions.</p>

<h1>1.3 Nock</h1>

<p>To make Nock make sense, let&#39;s work through Nock 5K line by line.
First the data model:</p>

<h2>1. Structures</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">A noun is an atom or a cell.  An atom is any natural number.
A cell is any ordered pair of nouns.
</code></pre></div>
<p>Nouns are the dumbest data model ever.  Nouns make JSON look like
XML and XML look like ASN.1.  It may also remind you of Lisp&#39;s
S-expressions - you can think of nouns as &quot;S-expressions without
the S.&quot;</p>

<p>To be exact, a noun <em>is</em> an S-expression, except that classic
S-expressions have multiple atom types (&quot;S&quot; is for &quot;symbol&quot;).
Since Nock is designed to be used with a higher-level type system
(such as Hoon&#39;s), it does not need low-level types.  An atom is
just an unsigned integer of any size.</p>

<p>For instance, it&#39;s common to represent strings (or even whole
text files) as atoms, arranging them LSB first - so &quot;foo&quot; becomes
<code>0x6f6f66</code>.  How do we know to print this as &quot;foo&quot;, not <code>0x6f6f66</code>?
We need external information - such as a Hoon type.  Similarly,
other common atomic types - signed integers, floating point, etc
- are all straightforward to map into atoms.</p>

<p>It&#39;s also important to note that, unlike Lisp, Nock cannot create
cyclical data structures.  It is normal and common for nouns in a
Nock runtime system to have acyclic structure - shared subtrees.
But there is no Nock computation that can make a child point to
its parent.  One consequence: Nock has no garbage collector.
(Nor can dag structure be detected, as with Lisp <code>eq</code>.)</p>

<p>There is also no single syntax for nouns.  If you have nouns you
have Nock; if you have Nock you have Hoon; if you have Hoon, you
can write whatever parser you like.</p>

<p>Let&#39;s continue:</p>

<h2>2. Pseudocode</h2>

<p>It&#39;s important to recognize that the pseudocode of the Nock spec
is just that: pseudocode.  It looks a little like Hoon.  It isn&#39;t
Hoon - it&#39;s just pseudocode.  Or in other words, just English.
At the bottom of every formal system is a system of axioms, which
can only be written in English.  (Why pseudocode, not Hoon?  Since
Hoon is defined in Nock, this would only give a false impression
of nonexistent precision.)</p>

<p>The logic of this pseudocode is a pattern-matching reduction,
matching from the top down.  To compute Nock, repeatedly reduce
with the first line that matches.   Let&#39;s jump right in!</p>

<h2>Line 1:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">1  ::    nock(a)           *a
</code></pre></div>
<p>Nock is a pure (stateless) function from noun to noun.  In our
pseudocode (and only in our pseudocode) we express this with the
prefix operator <code>*</code>.</p>

<p>This function is defined for every noun, but on many nouns it
does nothing useful.  For instance, if <code>a</code> is an atom, <code>*a</code>
reduces to... <code>*a</code>.  In theory, this means that Nock spins
forever in an infinite loop.  In other words, Nock produces no
result - and in practice, your interpreter will stop.</p>

<p>(Another way to see this is that Nock has &quot;crash-only&quot; semantics.
There is no exception mechanism.  The only way to catch Nock
errors is to simulate Nock in a higher-level virtual Nock -
which, in fact, we do all the time.  A simulator (or a practical
low-level interpreter) can report, out of band, that Nock would
not terminate.  It cannot recognize all infinite loops, of
course, but it can catch the obvious ones - like <code>*42</code>.)</p>

<p>Normally <code>a</code> in <code>nock(a)</code> is a cell <code>[s f]</code>, or as we say</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[subject formula]
</code></pre></div>
<p>Intuitively, the formula is your function and the subject is 
its argument.  We call them something different because Hoon,
or any other high-level language built on Nock, will build its
own function calling convention which <em>does not</em> map directly
to <code>*[subject formula]</code>.</p>

<h2>Line 2:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">2  ::    [a b c]           [a [b c]]
</code></pre></div>
<p>Ie, brackets (in our pseudocode, as in Hoon) associate to the
right.  For those with Lisp experience, it&#39;s important to note
that Nock and Hoon use tuples or &quot;improper lists&quot; much more
heavily than Lisp.  The list terminator, normally 0, is never 
automatic.  So the Lisp list </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">(a b c)
</code></pre></div>
<p>becomes the Nock noun</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[a b c 0]
</code></pre></div>
<p>which is equivalent to</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[a [b [c 0]]]
</code></pre></div>
<p>Note that we can and do use unnecessary brackets anyway, for
emphasis.</p>

<p>Let&#39;s move on to the axiomatic functions.  </p>

<h2>Lines 4-10:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">4  ::    ?[a b]            0
5  ::    ?a                1
6  ::    +[a b]            +[a b]
7  ::    +a                1 + a
8  ::    =[a a]            0
9  ::    =[a b]            1
</code></pre></div>
<p>Here we define more pseudocode operators, which we&#39;ll use in
reductions further down.  So far we have four built-in functions:
<code>*</code> meaning Nock itself, <code>?</code> testing whether a noun is a cell or
an atom, <code>+</code> incrementing an atom, and <code>=</code> testing for equality.
Again, no rocket science here.</p>

<p>We should note that in Nock and Hoon, <code>0</code> (pronounced &quot;yes&quot;) is
true, and <code>1</code> (&quot;no&quot;) is false.  Why?  It&#39;s fresh, it&#39;s different,
it&#39;s new.  And it&#39;s annoying.  And it keeps you on your toes.
And it&#39;s also just intuitively right.</p>

<h2>Lines 12-16:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">12 ::    /[1 a]            a
13 ::    /[2 a b]          a
14 ::    /[3 a b]          b
15 ::    /[(a + a) b]      /[2 /[a b]]
16 ::    /[(a + a + 1) b]  /[3 /[a b]]
</code></pre></div>
<p>Slightly more interesting is our tree numbering.  Every noun is of course a tree.  The <code>/</code> operator - pronounced
&quot;slot&quot; - imposes an address space on that tree, mapping every
nonzero atom to a tree position.</p>

<p>1 is the root.  The head of every node <code>n</code> is <code>2n</code>; the tail is
<code>2n+1</code>.  Thus a simple tree:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">     1
  2      3
4   5  6   7
         14 15
</code></pre></div>
<p>If the value of every leaf is its tree address, this tree is</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[[4 5] [6 14 15]]
</code></pre></div>
<p>and, for some examples of addressing:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">/[1 [[4 5] [6 14 15]]] 
</code></pre></div>
<p>is <code>[[4 5] [6 14 15]]</code></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">/[2 [[4 5] [6 14 15]]]  
</code></pre></div>
<p>is <code>[4 5]</code></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">/[3 [[4 5] [6 14 15]]]  
</code></pre></div>
<p>is <code>[6 14 15]</code>, and</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">/[7 [[4 5] [6 14 15]]]  
</code></pre></div>
<p>is <code>[14 15]</code></p>

<p>I do hope this isn&#39;t so terribly hard to follow.  </p>

<h2>Line 21:</h2>

<p>Now we enter the definition of Nock itself - ie, the <code>*</code>
operator.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">21 ::    *[a 0 b]          /[b a]
</code></pre></div>
<p><code>0</code> is simply Nock&#39;s tree-addressing operator.  Let&#39;s try it out
from the Arvo command line.  </p>

<p>Note that we&#39;re using Hoon syntax here.  Since we do not use Nock
from Hoon all that often (it&#39;s sort of like embedding assembly in
C), we&#39;ve left it a little cumbersome.  In Hoon, instead of
writing <code>*[a 0 b]</code>, we write </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">.*(a [0 b])
</code></pre></div>
<p>So, to reuse our slot example, let&#39;s try the interpreter:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*([[4 5] [6 14 15]] [0 7])
</code></pre></div>
<p>gives, while the sky remains blue and the sun rises in the east:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[14 15]
</code></pre></div>
<p>Even stupider is line 21:</p>

<h2>Line 21:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">21 ::    *[a 1 b]          b
</code></pre></div>
<p><code>1</code> is the constant operator.  It produces its argument without
reference to the subject.  So</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(42 [1 153 218])
</code></pre></div>
<p>yields</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[153 218]
</code></pre></div>
<h2>Line 23:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">23 ::    *[a 2 b c]        *[*[a b] *[a c]]
</code></pre></div>
<p>Line 22 brings us the essential magic of recursion.
<code>2</code> is the Nock operator.  If you can compute a subject and a
formula, you can evaluate them in the interpreter.  In most
fundamental languages, like Lisp, <code>eval</code> is a curiosity.  But
Nock has no <code>apply</code> - so all our work gets done with <code>2</code>.</p>

<p>Let&#39;s convert the previous example into a stupid use of <code>2</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(77 [2 [1 42] [1 1 153 218]])
</code></pre></div>
<p>with a constant subject and a constant formula, gives the same</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[153 218]
</code></pre></div>
<p>Like so:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">*[77 [2 [1 42] [1 1 153 218]]]

22 ::    *[a 2 b c]        *[*[a b] *[a c]]

*[*[77 [1 42]] *[77 [1 1 153 218]]]

21 ::    *[a 1 b]          b

*[42 *[77 [1 1 153 218]]]

*[42 1 153 218]

[153 218]
</code></pre></div>
<h2>Lines 24-26:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">24 ::    *[a 3 b]          ?*[a b]
25 ::    *[a 4 b]          +*[a b]
26 ::    *[a 5 b]          =*[a b]
</code></pre></div>
<p>In lines 23-25, we meet our axiomatic functions again:</p>

<p>For instance, if <code>x</code> is a formula that calculates some product,
<code>[4 x]</code> calculates that product plus one.  Hence:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(57 [0 1])
57
</code></pre></div>
<p>and</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*([132 19] [0 3])
19
</code></pre></div>
<p>and</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(57 [4 0 1])
58
</code></pre></div>
<p>and </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*([132 19] [4 0 3])
20
</code></pre></div>
<p>If this seems obvious, you&#39;re doin&#39; good.  Finally, we jump back up
to line 18, the trickiest in the spec:</p>

<h2>Line 19:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">19 ::    *[a [b c] d]      [*[a b c] *[a d]]
</code></pre></div>
<p>Um, what?</p>

<p>Since Nock of an atom just crashes, the practical domain of the
Nock function is always a cell.  Conventionally, the head of this
cell is the &quot;subject,&quot; the tail is the &quot;formula,&quot; and the result
of Nocking it is the &quot;product.&quot;  Basically, the subject is your
data and the formula is your code.</p>

<p>We could write line 19 less formally:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">*[subject [formula-x formula-y]]
=&gt;  [*[subject formula-x] *[subject formula-y]]
</code></pre></div>
<p>In other words, if you have two Nock formulas <code>x</code> and <code>y</code>, a
formula that computes the pair of them is just <code>[x y]</code>.  We can 
recognize this because no atom is a valid formula, and
every formula that <em>does not</em> use line 19 has an atomic head.</p>

<p>If you know Lisp, you can think of this feature as a sort of
&quot;implicit cons.&quot;  Where in Lisp you would write <code>(cons x y)</code>,
in Nock you write <code>[x y]</code>.</p>

<p>For example,</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(42 [4 0 1])
</code></pre></div>
<p>where <code>42</code> is the subject (data) and <code>[4 0 1]</code> is the formula
(code), happens to evaluate to <code>43</code>.  Whereas</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(42 [3 0 1])
</code></pre></div>
<p>is <code>1</code>.  So if we evaluate</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(42 [[4 0 1] [3 0 1]])
</code></pre></div>
<p>we get</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[43 1]
</code></pre></div>
<p>Except for the crash defaults (lines 6, 10, 17, and 35), we&#39;ve actually
completed all the <em>essential</em> aspects of Nock.  The operators up
through 5 provide all necessary computational functionality.
Nock, though very simple, is actually much more complex than it
formally needs to be.</p>

<p>Operators 6 through 10 are macros.  They exist because Nock is
not a toy, but a practical interpreter.  Let&#39;s see them all
together:</p>

<h2>Lines 28-33:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">28 ::    *[a 6 b c d]      *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
29 ::    *[a 7 b c]        *[a 2 b 1 c]
30 ::    *[a 8 b c]        *[a 7 [[7 [0 1] b] 0 1] c]
31 ::    *[a 9 b c]        *[a 7 c 2 [0 1] 0 b]
32 ::    *[a 10 [b c] d]   *[a 8 c 7 [0 3] d]
33 ::    *[a 10 b c]       *[a c]
</code></pre></div>
<p>Whoa!  Have we entered rocket-science territory?  Let&#39;s try to
figure out what these strange formulas do - simplest first.
The simplest is clearly line 33:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">33 ::    *[a 10 b c]       *[a c]
</code></pre></div>
<p>If <code>x</code> is an atom and <code>y</code> is a formula, the formula <code>[10 x y]</code> 
appears to be equivalent to... <code>y</code>.  For instance:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*([132 19] [10 37 [4 0 3]])
20
</code></pre></div>
<p>Why would we want to do this?  <code>10</code> is actually a hint operator.
The <code>37</code> in this example is discarded information - it is not
used, formally, in the computation.  It may help the interpreter
compute the expression more efficiently, however.</p>

<p>Every Nock computes the same result - but not all at the same
speed.  What hints are supported?  What do they do?  Hints are a
higher-level convention which do not, and should not, appear in
the Nock spec.  Some are defined in Hoon.  Indeed, a naive Nock
interpreter not optimized for Hoon will run Hoon quite poorly.
When it gets the product, however, the product will be right.</p>

<p>There is another reduction for hints - line 32:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">32 ::    *[a 10 [b c] d]   *[a 8 c 7 [0 3] d]
</code></pre></div>
<p>Once we see what <code>7</code> and <code>8</code> do, we&#39;ll see that this complex hint
throws away an arbitrary <code>b</code>, but computes the formula <code>c</code>
against the subject and... throws away the product.  This formula
is simply equivalent to <code>d</code>.  Of course, in practice the product
of <code>c</code> will be put to some sordid and useful use.  It could even
wind up as a side effect, though we try not to get <em>that</em> sordid.</p>

<p>(Why do we even care that <code>c</code> is computed?  Because <code>c</code> could
crash.  A correct Nock cannot simply ignore it, and treat both
variants of <code>10</code> as equivalent.)</p>

<p>We move on to the next simplest operator, <code>7</code>.  Line 29:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    29 ::    *[a 7 b c]        *[a 2 b 1 c]
</code></pre></div>
<p>Suppose we have two formulas, <code>b</code> and <code>c</code>.  What is the formula 
<code>[7 b c]</code>?  This example will show you:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(42 [7 [4 0 1] [4 0 1]])
44
</code></pre></div>
<p><code>7</code> is an old mathematical friend, function composition.  It&#39;s
easy to see how this is built out of <code>2</code>.  The data to evaluate
is simply <code>b</code>, and the formula is <code>c</code> quoted.</p>

<p>Line 30 looks very similar:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">30 ::    *[a 8 b c]        *[a 7 [[7 [0 1] b] 0 1] c]
</code></pre></div>
<p>Indeed, <code>8</code> is <code>7</code>, except that the subject for <code>c</code> is not simply
the product of <code>b</code>, but the ordered pair of the product of <code>b</code>
and the original subject.  Hence:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(42 [8 [4 0 1] [0 1]])
[43 42]
</code></pre></div>
<p>and </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(42 [8 [4 0 1] [4 0 3]])
43
</code></pre></div>
<p>Why would we want to do this?  Imagine a higher-level language
in which the programmer declares a variable.  This language is
likely to generate an <code>8</code>, because the variable is computed
against the present subject, and used in a calculation which
depends both on the original subject and the new variable.</p>

<p>For extra credit, explain why we can&#39;t just define</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">*[a 8 b c]        *[a 7 [b 0 1] c]
</code></pre></div>
<p>Another simple macro is line 31:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">31 ::    *[a 9 b c]        *[a 7 c 2 [0 1] 0 b]
</code></pre></div>
<p><code>9</code> is a calling convention.  With <code>c</code>, we produce a noun which
contains both code and data - a <em>core</em>.  We use this core as the
subject, and apply the formula within it at slot <code>b</code>.</p>

<p>And finally, we come to the piece de resistance - line 28:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">28 ::    *[a 6 b c d]      *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
</code></pre></div>
<p>Great giblets!  WTF is this doing?  It seems we&#39;ve finally
arrived at some real rocket science.</p>

<p>Actually, <code>6</code> is a primitive known to every programmer - good old
&quot;if.&quot;  If <code>b</code> evaluates to <code>0</code>, we produce <code>c</code>; if <code>b</code> evaluates
to <code>1</code>, we produce <code>d</code>; otherwise, we crash.</p>

<p>For instance:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(42 [6 [1 0] [4 0 1] [1 233]])
43
</code></pre></div>
<p>and</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(42 [6 [1 1] [4 0 1] [1 233]])
233
</code></pre></div>
<p>In real life, of course, the Nock implementor knows that <code>6</code> is
&quot;if&quot; and implements it as such.  There is no practical sense in
reducing through this macro, or any of the others.  We could have
defined &quot;if&quot; as a built-in function, like increment - except that
we can write &quot;if&quot; as a macro.  If a funky macro. </p>

<p>It&#39;s a good exercise, however, to peek inside the funk.</p>

<p>We can actually simplify the semantics of <code>6</code>, at the expense of
breaking the system a little, by creating a macro that works as
&quot;if&quot; only if <code>b</code> is a proper boolean and produces <code>0</code> or <code>1</code>.
Perhaps we have a higher-level type system which checks this.</p>

<p>This simpler &quot;if&quot; would be:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">*[a 6 b c d]    *[a [2 [0 1] [2 [1 c d] [[1 0] [4 4 b]]]]]
</code></pre></div>
<p>Or without so many unnecessary brackets:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">*[a 6 b c d]    *[a 2 [0 1] 2 [1 c d] [1 0] [4 4 b]]
</code></pre></div>
<p>How does this work?  We&#39;ve replaced <code>[6 b c d]</code> with the formula
<code>[2 [0 1] [2 [1 c d] [[1 0] [4 4 b]]]]</code>.  We see two uses of <code>2</code>,
our evaluation operator - an outer and an inner.</p>

<p>Call the inner one <code>i</code>.  So we have <code>[2 [0 1] i]</code>.  Which means
that, to calculate our product, we use <code>[0 1]</code> - that is, the
original subject - as the subject; and the product of <code>i</code> as
the formula.</p>

<p>Okay, cool.  So <code>i</code> is <code>[2 [1 c d] [[1 0] [4 4 b]]]</code>.  We compute 
Nock with subject <code>[1 c d]</code>, formula <code>[[1 0] [4 4 b]]</code>.</p>

<p>Obviously, <code>[1 c d]</code> produces just <code>[c d]</code> - that is, the ordered
pair of the &quot;then&quot; and &quot;else&quot; formulas.  <code>[[1 0] [4 4 b]]</code> is a
line 19 cell - its head is <code>[1 0]</code>, producing just <code>0</code>, its tail
<code>[4 4 b]</code>, producing... what?  Well, if <code>[4 b]</code> is <code>b</code> plus <code>1</code>,
<code>[4 4 b]</code> is <code>b</code> plus <code>2</code>.</p>

<p>We&#39;re assuming that <code>b</code> produces either <code>0</code> or <code>1</code>.  So <code>[4 4 b]</code>
yields either <code>2</code> or <code>3</code>.  <code>[[1 0] [4 4 b]]</code> is either <code>[0 2]</code> or
<code>[0 3]</code>.  Applied to the subject <code>[c d]</code>, this gives us either
<code>c</code> or <code>d</code> - the product of our inner evaluation <code>i</code>.  This is
applied to the original subject, and the result is &quot;if.&quot;</p>

<p>But we need the full power of the funk, because if <code>b</code> produces,
say, <code>7</code>, all kinds of weirdness will result.  We&#39;d really like
<code>6</code> to just crash if the test product is not a boolean.  How can
we accomplish this?  This is an excellent way to prove to
yourself that you understand Nock: figure out what the real <code>6</code>
does.  Or you could just agree that <code>6</code> is &quot;if,&quot; and move on.</p>

<p>(It&#39;s worth noting that in practical, compiler-generated Nock, we
never do anything as funky as these <code>6</code> macro internals.  There&#39;s
no reason we couldn&#39;t build formulas at runtime, but we have no
reason to and we don&#39;t - except when actually metaprogramming.
As in most languages, normally code is code and data is data.)</p>

<h1>1.4 Decrement in Nock</h1>

<p>A good practice exercise for Nock is a decrement formula.  Ie, a
formula <code>f</code> which implements the partial function that produces
<code>(s - 1)</code> if <code>s</code> is a nonzero atom, and otherwise does not
terminate.  </p>

<p>The normal Hoon programmer has written one Nock formula: this
one.  Since decrement uses all the Nock techniques the Hoon
compiler uses, the exercise is a good foundation.  After you
write decrement (or just follow this example), you&#39;ll never need
to deal with Nock again.</p>

<p>As we know, the equivalent formula for increment is</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[4 0 1]
</code></pre></div>
<p>Thus:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~&gt;tasfyn-partyv .*(42 [4 0 1])
43
</code></pre></div>
<p>Of course, increment is built into Nock.  So, ha, that&#39;s easy.</p>

<p>How do we decrement?  A good way to start is to gaze fondly on
how we&#39;d do it if we actually had a real language, ie, Hoon.
Here is a minimal decrement in Hoon:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">=&gt;  a=.                     ::  line 1
=+  b=0                     ::  line 2
|-                          ::  line 3
?:  =(a +(b))               ::  line 4
  b                         ::  line 5
$(b +(b))                   ::  line 6
</code></pre></div>
<p>Or for fun, on one line:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">=&gt;(a=. =+(b=0 |-(?:(=(a +(b)) b $(b +(b))))))
</code></pre></div>
<p>Does Hoon actually work?</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt;  =&gt;(42 =&gt;(a=. =+(b=0 |-(?:(=(a +(b)) b $(b +(b)))))))
41
</code></pre></div>
<p>Let&#39;s translate this into English.  How do we decrement the
subject?  First (line 1), we rename the subject <code>a</code>.  Second
(line 2), we add a variable, <code>b</code>, an atom with value <code>0</code>.
Third (line 3), we loop.  Fourth, we test if <code>a</code> equals <code>b</code> plus
1 (line 4), produce <code>b</code> if it does (line 5), repeat the loop with
<code>b</code> set to <code>b</code> plus 1 (line 6) if it doesn&#39;t.  Obviously, while
the syntax is unusual, the algorithm is anything but deep.  We
are calculating <code>b</code> minus one by counting up from <code>0</code>.</p>

<p>(Obviously, this is an O(n) algorithm.  Is there a better way?
There is not.  Do we actually do this in practice?  Yes and no.)</p>

<p>Unfortunately we are missing a third of our Rosetta stone.  We
have decrement in Hoon and we have it in English.  How do we
express this in Nock?  What will the Hoon compiler generate from
the code above?  Let&#39;s work through it line by line.</p>

<p>Nock has no types, variable names, etc.  So line 1 is a no-op.</p>

<p>How do we add a variable (line 2)?  We compute a new subject,
which is a cell of the present subject and the variable.  With
this new subject, we execute another formula.</p>

<p>Since <code>0</code> is a constant, a formula that produces it is</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[1 0]
</code></pre></div>
<p>To combine <code>0</code> with the subject, we compute</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[[1 0] [0 1]]
</code></pre></div>
<p>which, if our subject is 42, gives us</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[0 42]
</code></pre></div>
<p>which we can use as the subject for an inner formula, <code>g</code>.
Composing our new variable with <code>g</code>, we have <code>f</code> as</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[2 [[1 0] [0 1]] [1 g]]
</code></pre></div>
<p>which seems a little funky for something so simple.  But we
can simplify it with the composition macro, <code>7</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[7 [[1 0] [0 1]] g]
</code></pre></div>
<p>and still further with the augmentation macro, <code>8</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[8 [1 0] g]
</code></pre></div>
<p>If you refer back to the Nock definition, you&#39;ll see that all
these formulas are semantically equivalent.</p>

<p>Let&#39;s continue with our decrement.  So what&#39;s <code>g</code>?  We seem to
loop.  Does Nock have a loop operator?  It most certainly does
not.  So what do we do?</p>

<p>We build a noun called a <em>core</em> - a construct which is behind any
kind of interesting control flow in Hoon.  Of course, the Nock
programmer is not constrained to use the same techniques as the
Hoon compiler, but it is probably a good idea. </p>

<p>In Hoon, all the flow structures from your old life as an Earth
programmer become cores.  Functions and/or closures are cores,
objects are cores modules are cores, even loops are cores.</p>

<p>The core is just a cell whose tail is data (possibly containing
other cores) and whose head is code (containing one or more
formulas).  The tail is the <em>payload</em> and the head is the
<em>battery</em>.  Hence your core is</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[bat pay]
</code></pre></div>
<p>To activate a core, pick a formula out of the battery, and use
the entire core (<em>not</em> just the payload) as the subject.  </p>

<p>(A core formula is called an <em>arm</em>.  An arm is almost like an
object-oriented method, but not quite - a method would be an arm
that produces a function on an argument.  The arm is just a
function of the core, ie, a computed attribute.)</p>

<p>Of course, because we feed it the entire core, our arm can
invoke itself (or any other formula in the battery).  Hence, it
can loop.  And this is what a loop is - the simplest of cores.</p>

<p>We need to do two things with this core: create it, and activate
it.  To be precise, we need two formulas: a formula which
produces the core, and one which activates its subject.  We can
compose these functions with the handy <code>7</code> operator:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[8 [1 0] [7 p a]]
</code></pre></div>
<p><code>p</code> produces our core, <code>a</code> activates it.  Let&#39;s take these in
reverse order.  How do we activate a core?</p>

<p>Since we have only one formula, it&#39;s the battery itself.
Thus we want to execute Nock with the whole core (already the
subject, and the entire battery (slot <code>2</code>).  Hence, <code>a</code> is</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[2 [0 1] [0 2]]
</code></pre></div>
<p>We could also use the handy <code>9</code> macro - which almost seems
designed for firing arms on cores:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[9 2 [0 1]]
</code></pre></div>
<p>Which leaves us seeking </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[8 [1 0] [7 p [9 2 0 1]]]
</code></pre></div>
<p>And all we have to do is build the core, <code>p</code>.  How do we build a
core?  We add code to the subject, just as we added a variable
above.  The initial value of our counter was a constant, <code>0</code>.
The initial (and permanent) value of our battery is a constant, 
the loop formula <code>l</code>.  So <code>p</code> is</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[8 [1 l] [0 1]]
</code></pre></div>
<p>Which would leave us seeking</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[8 [1 0] [7 [8 [1 l] [0 1]] [9 2 0 1]]]
</code></pre></div>
<p>except that we have duplicated the <code>8</code> pattern again, since we
know</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[7 [8 [1 l] [0 1]] [9 2 0 1]]
</code></pre></div>
<p>is equivalent to  </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[8 [1 l] [9 2 0 1]]
</code></pre></div>
<p>so the full value of <code>f</code> is</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[8 [1 0] [8 [1 l] [9 2 0 1]]]
</code></pre></div>
<p>Thus our only formula to compose is the loop body, <code>l</code>.
Its subject is the loop core:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[bat pay]
</code></pre></div>
<p>where <code>bat</code> is just the loop formula, and <code>pay</code> is the pair <code>[a
b]</code>, <code>a</code> being the input subject, and <code>b</code> the counter.  Thus we
could also write this subject as</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[l b a]
</code></pre></div>
<p>and we see readily that <code>a</code> is at slot <code>7</code>, <code>b</code> <code>6</code>, <code>l</code> <code>2</code>.
With this subject, we need to express the Hoon loop body</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">?:  =(a +(b))               ::  line 4
  b                         ::  line 5
$(b +(b))                   ::  line 6
</code></pre></div>
<p>This is obviously an if statement, and it calls for <code>6</code>.  Ie:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[6 t y n]
</code></pre></div>
<p>Giving our decrement program as:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[8 [1 0] [8 [1 6 t y n] [9 2 0 1]]]
</code></pre></div>
<p>For <code>t</code>, how do we compute a flag that is yes (<code>0</code>) if <code>a</code> equals
<code>b</code> plus one?  Equals, we recall, is <code>5</code>.  So <code>t</code> can only be</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[5 [0 7] [4 0 6]]
</code></pre></div>
<p>If so, our product <code>y</code> is just the counter <code>b</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[0 6]
</code></pre></div>
<p>And if not?  We have to re-execute the loop with the counter 
incremented.  If we were executing it with the same counter, 
obviously an infinite loop, we could use the same core:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[9 2 0 1]
</code></pre></div>
<p>But instead we need to construct a new core with the counter 
incremented:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[l +(b) a]
</code></pre></div>
<p>ie, </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[[0 2] [4 0 6] [0 7]] 
</code></pre></div>
<p>and <code>n</code> is:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[9 2 [[0 2] [4 0 6] [0 7]]]
</code></pre></div>
<p>Hence our complete decrement.  Let&#39;s reformat vertically so we
can actually read it:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"> [8 
   [1 0] 
   [ 8 
     [ 1 
       [ 6 
         t 
         y 
         n
       ]
     ]
     [9 2 0 1]
   ]
 ]
</code></pre></div>
<p>which becomes</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  [8 
    [1 0] 
    [ 8 
      [ 1 
        [ 6 
          [5 [0 7] [4 0 6]]
          [0 6]
          [9 2 [[0 2] [4 0 6] [0 7]]]
        ]
      ]
      [9 2 0 1]
    ]
  ]
</code></pre></div>
<p>or, on one line without superfluous brackets:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[8 [1 0] 8 [1 6 [5 [0 7] 4 0 6] [0 6] 9 2 [0 2] [4 0 6] 0 7] 9 2 0 1]
</code></pre></div>
<p>which works for the important special case, 42:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; .*(42 [8 [1 0] 8 [1 6 [5 [0 7] 4 0 6] [0 6] 9 2 [0 2] [4 0 6] 0 7] 9 2 0 1])
41
</code></pre></div>
<p>If you understood this, you understand Nock.  At least in principle!</p>

<p>If you want to play around more with Nock, the command line will
start getting unwieldy.  Fortunately, the standard install
contains the above Nock decrement packaged as an Arvo app, which
you can edit and change if you&#39;d like to get ambitious.  Just run</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; :toy/ndec 19
18
</code></pre></div>
<p>The file driving this is </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">hub/$seat/toy/app/ndec.holw
</code></pre></div>
<p>Edit this file, ignoring everything above the Nock formula, and
hit return in the console to see it update:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~tasfyn-partyv&gt; 
: ~tasfyn-partyv/toy/app/ndec/holw/
</code></pre></div>
<p>If decrement seems fun - why not write add?  I wrote a Nock adder
a long, long time ago.  But I&#39;ve forgotten where I put it.  There
is absolutely no use in this exercise, except to prove to
yourself that you&#39;ve mastered Nock.</p>

<h1>Appendix A: Operator Reductions</h1>

<h2><code>6</code> Reduction:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">28 ::    *[a 6 b c d]      *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]

*[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]

23 ::    *[a 2 b c]        *[*[a b] *[a c]]

*[*[a 0 1] *[a 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]]

21 ::    *[a 0 b]          /[b a]

*[a *[a 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]]

23 ::    *[a 2 b c]        *[*[a b] *[a c]]

*[a *[*[a [1 c d]] *[a [1 0] 2 [1 2 3] [1 0] 4 4 b]]]

22 ::    *[a 1 b]          b

19 ::    *[a [b c] d]      [*[a b c] *[a d]]

*[a *[[c d] [*[a 1 0] *[a 2 [1 2 3] [1 0] 4 4 b]]]]

22 ::    *[a 1 b]          b

*[a *[[c d] [0 *[a 2 [1 2 3] [1 0] 4 4 b]]]]

23 ::    *[a 2 b c]        *[*[a b] *[a c]]

*[a *[[c d] [0 *[*[a [1 2 3]] *[a [1 0] 4 4 b]]]]]

22 ::    *[a 1 b]          b

*[a *[[c d] [0 *[[2 3] *[a [1 0] 4 4 b]]]]]

19 ::    *[a [b c] d]      [*[a b c] *[a d]]

*[a *[[c d] [0 *[[2 3] [*[a [1 0]] *[a 4 4 b]]]]]]

22 ::    *[a 1 b]          b

*[a *[[c d] [0 *[[2 3] [0 *[a 4 4 b]]]]]]

25 ::    *[a 4 b]          +*[a b]

*[a *[[c d] [0 *[[2 3] [0 ++*[a b]]]]]]
</code></pre></div>
<p><strong><code>6</code> Reduced:</strong></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">6r ::   *[a 6 b c d]               *[a *[[c d] [0 *[[2 3] [0 ++*[a b]]]]]]
</code></pre></div>
<h2><code>7</code> Reduction:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">29 ::    *[a 7 b c]        *[a 2 b 1 c]

*[a 2 b 1 c]

23 ::    *[a 2 b c]        *[*[a b] *[a c]] 

*[*[a b] *[a 1 c]]

22:    *[a 1 b]          b

*[*[a b] c]
</code></pre></div>
<p><strong><code>7</code> Reduced:</strong></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">7r ::     *[a 7 b c]         *[*[a b] c]
</code></pre></div>
<h2><code>8</code> Reduction:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">30 ::    *[a 8 b c]        *[a 7 [[7 [0 1] b] 0 1] c]

*[a 7 [[7 [0 1] b] 0 1] c]   

7r ::     *[a 7 b c]         *[*[a b] c]

*[*[a [7 [0 1] b] 0 1]] c]

19 ::    *[a [b c] d]      [*[a b c] *[a d]]

*[[*[a [7 [0 1] b]] *[a 0 1]] c]

21 ::    *[a 0 b]          /[b a]

*[[*[a [7 [0 1] b]] /[1 a]] c]

12 ::    /[1 a]            a

*[[*[a [7 [0 1] b]] a] c]

7r ::     *[a 7 b c]         *[*[a b] c]

*[[*[*[a 0 1]] b] a] c]
</code></pre></div>
<p><strong><code>8</code> Reduced:</strong></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">8r ::     *[a 8 b c]        *[[*[a b] a] c]
</code></pre></div>
<h2><code>9</code> Reduction:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">31 :: *[a 9 b c]        *[a 7 c [2 [0 1] [0 b]]]

*[a 7 c [2 [0 1] [0 b]]]

7r ::     *[a 7 b c]         *[*[a b] c]

*[*[a c] [2 [0 1] [0 b]]]

23 ::     *[a 2 b c]        *[*[a b] *[a c]]

*[*[*[a c] [0 1]] *[*[a c] [0 b]]]

21 ::     *[a 0 b]          /[b a]
</code></pre></div>
<p><strong><code>9</code> Reduced:</strong>    </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">9r ::     *[a 9 b c]        *[*[a c] *[*[a c] 0 b]] 
</code></pre></div>
<h2><code>10</code> Reduction:</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">*[a 10 [b c] d]   *[a 8 c 7 [0 3] d]

8r ::     *[a 8 b c]        [[*[a b] a] c]

*[[*[a c] a] 7 [0 2] d]

7r ::     *[a 7 b c]        *[*[a b] c]

*[*[[*[a c] a] 0 3] d]

21 ::     *[a 0 b]          /[b a]
</code></pre></div>
<p><strong><code>10</code> reduced:</strong></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">10r ::    *[a 10 [b c] d]   *[a d]
</code></pre></div>
</div>



    </div>

  </body>
</html>
