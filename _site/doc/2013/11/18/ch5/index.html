<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Chapter V (Intro To Hoon) &middot; Urbit
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">

  <!-- Icons -->

   <link rel="shortcut icon" href="/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <img src="/public/urbit_logo_ur.svg">
      <br>
      <h1>Urbit</h1>
      <p class="lead">a personal cloud computer</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
        <a href="/">What is Urbit?</a>
      </li>

      

      
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/about/">About</a>
            </li>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/blog/">Blog</a>
            </li>
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/dev/">Developer</a>
            </li>
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/doc/">Documentation</a>
            </li>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/setup/">Setup</a>
            </li>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <li class="sidebar-nav-item"><a href="https://github.com/urbit/urbit">GitHub</a></li>
      <li class="sidebar-nav-item"><a href="https://groups.google.com/forum/#!forum/urbit-dev">Mailing List</a></li>
      <li class="sidebar-nav-item">Cooling at 544 Kelvin</li>
      <li>Last Continuity Breach: <a href="/blog/2014/01/06/continuity/">~2014.1.6</a></li>
    </ul>
    <p>urbit@urbit.org</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Chapter V (Intro To Hoon)</h1>
  <p><a href="/doc/2013/11/18/ch4"><strong>Prev</strong>: Using Nock</a>
<a href="/doc/2013/11/18/ch6"><strong>Next</strong>: Moar Hoon Types</a></p>

<p><em>&quot;Like all men in Babylon, I have been proconsul; like all, a slave.&quot;</em>
<strong>(The Lottery in Babylon)</strong></p>

<h2>Principles of type</h2>

<p>By working through the Nock tutorial, you&#39;ve actually come closer
than you know to knowing Hoon.  Hoon is actually not much more
than a fancy wrapper around Nock. People who know C can think of
Hoon as the C to Urbit&#39;s Nock - just a sprinkling of syntax,
wrapped around machine code and memory.</p>

<p>For instance, it&#39;s easy to imagine how instead of calculating
tree axes by hand, we could actually assign <em>names</em> to different
parts of the tree - and those names would stay the same as we
pushed more data on the subject.  It can&#39;t hurt to dream, right?</p>

<p>The way we&#39;re going to do this is by associating something called
a <code>type</code> with the subject.  You may have heard of types before.
Technically, Hoon is a statically typed language, which just
means that the type isn&#39;t a part of your program: it&#39;s just a
piece of data the compiler keeps around as it turns your Hoon
into Nock.</p>

<p>In some languages, especially functional languages, types are
dangerous scary concepts that involve a lot of math.  For those
who like this sort of thing, that&#39;s the sort of thing they like.
For the rest of us, there&#39;s Hoon. It&#39;s a functional language, but
not one of those scary ones.</p>

<p>A lot of other languages use dynamic types, in which the type of
a value is carried along with the data as you use it.  Even
languages like Lisp, which are nominally typeless, look rather
typed from the Hoon perspective.  For example, a Lisp atom knows
dynamically whether it&#39;s a symbol or an integer.  A Hoon atom is
just a Nock atom, which is just a number.  So without a static
type, Hoon doesn&#39;t even know how to print an atom properly.</p>

<p>When we parse a Hoon expression, file, etc, we produce what we
call a <code>twig</code>, which (if you know the CS jargon) is an AST.  A
twig is a noun that&#39;s converted into a Nock formula, with
the assistance of a type which describes the subject of the
formula:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[subject-type twig] =&gt; formula
</code></pre></div>
<p>But actually this isn&#39;t quite right, because Hoon does something
called &quot;type inference.&quot;  When we have a type that describes the
subject for the formula we&#39;re trying to generate, as we generate
that formula we want to also generate a type for the product of
that formula on that subject.  So our compiler computes:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[subject-type twig] =&gt; [product-type formula]
</code></pre></div>
<p>As long as <code>subject-type</code> is a correct description of some
subject, you can take any twig and compile it against
<code>subject-type</code>, producing a <code>formula</code> such that <code>*(subject
formula)</code> is a product correctly described by <code>product-type</code>.</p>

<p>Actually, this works well enough that in Hoon there is no direct
syntax for defining or declaring a type.  There is only a syntax
for constructing twigs.  Types are always produced by inference.</p>

<h2>Printing types</h2>

<p>Let&#39;s start looking at types with the simplest possible kind of
hoon - an atomic constant, which ignores the subject and its
type, and just produces its own subject.  Here&#39;s everyone&#39;s
favorite atomic constant:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; 42
42
</code></pre></div>
<p>Let&#39;s also print its type - in two different ways:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; :type; 42
42
@ud

~waclux-tomwyc/try=&gt; -:!&gt;(42)
[%atom p=&#39;ud&#39;]
</code></pre></div>
<p>W-what?  Since types are of course static, printing them out
dynamically involves a little bit of black magic at the Hoon
and/or Arvo levels.  All will be revealed in due course.</p>

<p>But a type, like everything else in Hoon, is a noun.  Suffice it
to say that <code>-:!&gt;(42)</code> is just printing this noun, whereas
<code>:type; 42</code> is rendering it intelligently as a string.  In this
case, the rendering is actually Hoon syntax, but in general it&#39;s
just a string.</p>

<p>In this case, looking directly at the type noun is preferable.
But for a core, the type actually contains the entire codebase.
For example, if you type</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; -:!&gt;(&quot;string&quot;)
</code></pre></div>
<p>you&#39;ll have to press ^C to rescue yourself, or wait until you&#39;ve
printed out more or less the entire Arvo kernel.  Black magic is
evil magic - it must exact its evil price.  But someday, you&#39;ll 
be more the sorcerer and less his apprentice.</p>

<h2>Atom examples</h2>

<p>Let&#39;s look at some more of these atoms:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; :type; 0x42
0x42
@ux

~waclux-tomwyc/try=&gt; :type; &#39;foo&#39;
&#39;foo&#39;
@ta

~waclux-tomwyc/try=&gt; :type; ~2013.12.6
~2013.12.6
@da

~waclux-tomwyc/try=&gt; :type; .127.0.0.1
.127.0.0.1
@if

~waclux-tomwyc/try=&gt; :type; ~m45
~m45
@dr

~waclux-tomwyc/try=&gt; :type; `@da`(add ~2013.12.6 ~m45)
~2013.12.6..00.45.00
@da
</code></pre></div>
<p>Okay, we got a little out of control with that last one.  But the
point should be clear.</p>

<p>Note again that there is no dynamic type here.  All these values
are atoms.  Let&#39;s cast them all to decimals to see (don&#39;t worry
about the cast syntax - we&#39;ll cover that later):</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ud`0x42
66
~waclux-tomwyc/try=&gt; `@ud`&#39;foo&#39;
7.303.014
~waclux-tomwyc/try=&gt; `@ud`.127.0.0.1
2.130.706.433
~waclux-tomwyc/try=&gt; `@ud`~2013.12.6
170.141.184.500.724.667.905.957.736.036.171.776.000
~waclux-tomwyc/try=&gt; `@ud`~m45
49.806.208.999.015.789.363.200
</code></pre></div>
<p>(Yes, 45 minutes is actually quite a large number when your unit
of time is 2^-64 seconds.)</p>

<p>What are these atoms, anyway?  Let&#39;s look at the actual type noun
(which, without magic, exists only at compile time):</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; -:!&gt;(42)
[%atom p=&#39;ud&#39;]
</code></pre></div>
<p><code>p</code> is called the <code>odor</code> of the atom.  In this case, it&#39;s <code>&#39;ud&#39;</code>,
ie, unsigned decimal:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ud`&#39;ud&#39;
25.717
</code></pre></div>
<p>That&#39;s an unsigned-decimal interpretation of the atom &#39;ud&#39;, which
without a cast is an atom of odor <code>@ta</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; :type; &#39;ud&#39;
&#39;ud&#39;
@ta

~waclux-tomwyc/try=&gt; -:!&gt;(&#39;ud&#39;)
[%atom p=&#39;ta&#39;]
</code></pre></div>
<p>In case this is at all mysterious, we note:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; (add &#39;u&#39; (mul 256 &#39;d&#39;))
25.717
</code></pre></div>
<p>As a general convention, when we represent UTF-8/ASCII text as an
atom, we store it LSB first.  A text atom is generally called a
<code>cord</code>; if it is ASCII only, a <code>span</code>; if it is ASCII restricted
to the Hoon symbol subset (lowercase with hyphens), a <code>term</code>.</p>

<h2>The logic of smell</h2>

<p>What is an odor, anyway?  We&#39;ve seen that the type of an atom
constant gets an odor which is a function of its syntax.  We&#39;ve
also seen that when we print atoms on the console, the printer is
(in some black-magic way) aware of the odor, and can print the
atom in roughly the same syntax we originally entered it.</p>

<p>Hoon&#39;s type system is generally strong, but odors are weak.  The
parser itself will only generate a <code>@ta</code> for an actual ASCII
span, but not every atom is a constant.  For instance, consider
our construction of <code>&#39;ud&#39;</code>.  Let&#39;s look at the type:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; :type; &#39;u&#39;
&#39;u&#39;
@ta

~waclux-tomwyc/try=&gt; :type; 256 
256
@ud

~waclux-tomwyc/try=&gt; :type; (add &#39;u&#39; (mul 256 &#39;d&#39;))
25.717
@
</code></pre></div>
<p>Not only are we mixing atoms of different odors in our
arithmetic, but the result appears to be odorless.  It is
odorless.  But we can cast it back:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; :type; `@ta`(add &#39;u&#39; (mul 256 &#39;d&#39;))
&#39;ud&#39;
@ta
</code></pre></div>
<p>While Hoon&#39;s type system is quite intelligent in some ways, it is
by no means smart enough to evaluate your arithmetic and conclude
that it produces a valid ASCII span.  We can convert any atom to
any other odor of atom, without any sanity checks:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@dr`25.717
~.s0..0000.0000.0000.6475

~waclux-tomwyc/try=&gt; `@if`25.717
.0.0.100.117
</code></pre></div>
<p>It so happens that <code>25.717</code> is a valid amount of time, and also a
valid IPv4 address.  But obviously not all atoms are meaningful
values of every odor.  We&#39;re not going to annoy you by stressing
out the console printer with bad ASCII, but we could.</p>

<p>(And why do we say <code>25.717</code> rather than <code>25,717</code>?  Are we
Germans?  No, but we want all atom syntaxes to be URL-safe.
See below.)</p>

<p>Odors are a weak type system because the programmer often knows,
at a logical level not at all available to the type system, that
(for example) <code>(add &#39;u&#39; (mul 256 &#39;d&#39;))</code> produces an ASCII span.
We want to keep the programmer from accidentally using a date as
if it were text, but we don&#39;t want to keep her from intentionally
converting between odors or ascribing odor to the result of an
arbitrary computation.</p>

<p>An odor is exactly what it looks like - an ASCII span.  This span
is a taxonomy which grows more specific to the right.  For
instance, <code>@t</code> for UTF-8 text, <code>@ta</code> for URL-safe ASCII text,
<code>@tas</code> for a Hoon symbol; or <code>@u</code> for an unsigned integer, <code>@ux</code>
for an unsigned integer formatted as hexadecimal.</p>

<p>The general principle of type enforcement is that atoms change
freely either up or down the taxonomy, but not across.  For
instance, you can treat a <code>@tas</code> as a <code>@t</code>, as in a strong type
system; but you can also treat a <code>@t</code> as a <code>@tas</code>, or an <code>@</code> as
anything.  However, passing a <code>@t</code> to a function that expects an
<code>@ux</code> is a type error.</p>

<p>Even the ability to cast a <code>@ud</code> to a <code>@dr</code> is a syntactic hack;
casts in Hoon do not evade type enforcement.  When you write</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">`@dr`25.717
</code></pre></div>
<p>the parser actually produces the equivalent of</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">`@dr``@`25.717
</code></pre></div>
<p>because we can&#39;t turn <code>@ud</code> directly into <code>@dr</code>, but we can turn
<code>@ud</code> into <code>@</code> and <code>@</code> into <code>@dr</code>.</p>

<h2>The smell of size</h2>

<p>Besides these prefixes, which indicate the rendering and/or
meaning of atoms, the odor system has another orthogonal
mechanism to restrict the size of atoms.  Like the prefix, this
mechanism is weak - it is not enforced and trivially evaded.</p>

<p>An odor span contains two parts, both optional: a lowercase
prefix and an uppercase suffix.  The suffix, if present, is a
single character A-Z <code>c</code> which indicates an atom of size less
than or equal to <code>n</code> bits, where <code>n</code> is <code>1 &lt;&lt; (c - &#39;A&#39;)</code>.
Thus, <code>@tD</code> is one UTF-8 byte (whatever that means); <code>@tN</code>
is a kilobyte or less of UTF-8.</p>

<p>(It&#39;s easy to complain from a standards perspective that &quot;UTF-8&quot;
defines a format for bytestreams, not bytes, and at a strict
level it means no more to say &quot;one UTF-8 byte&quot; than to say, say,
&quot;one GIF byte.&quot;  But odors are not a strict type system.  It is
possible for a byte to <em>smell</em> of UTF-8 - or even of GIF.)</p>

<p>When enforcing conversions, <code>@t</code> has no size information and can
be used as <code>@tD</code>; and <code>@tD</code>, of course, can be used as <code>@t</code>.  But
using <code>@tN</code> as <code>@tD</code> is an error.  There is no way to generate
the smell of size from a constant without a cast.  And of course
arithmetic results have no odor at all.</p>

<p>While the utility of this mechanism is debatable, at worst it
serves as a comment which documents the programmer&#39;s intentions.</p>

<p>A full table - for convenience, not because you&#39;re stupid:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">A   1 bit
B   2 bits
C   4 bits
D   1 byte
E   2 bytes
F   4 bytes
G   8 bytes
H   16 bytes
I   32 bytes
J   64 bytes
K   128 bytes
L   256 bytes
M   512 bytes
N   1K
O   2K
P   4K
Q   8K
R   16K
S   32K
T   64K
U   128K
V   256K
W   512K
X   1MB
Y   2MB
Z   4MB
</code></pre></div>
<p>You of course can build an atom larger than 4MB, though whether
you should is another question entirely.  But the type system
cannot express a size odor above 4MB.</p>

<h2>Known and unknown odors</h2>

<p>The variety of units and formats which an atom can represent is
essentially infinite.  The set of syntaxes which Hoon can parse
and print is fundamentally limited.</p>

<p>For instance, Hoon has no syntax which means &quot;number of miles.&quot;
But within your program, nothing stops you from using the odor
system to distinguish a number of miles from, for instance, a
number of kilometers:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@udm`25.717
25.717
~waclux-tomwyc/try=&gt; `@udk`25.717
25.717
</code></pre></div>
<p>The printer has no idea what a <code>@udm</code> is, but it knows what a
<code>@ud</code> and can print accordingly.  Then, if you have a function
which expects a <code>@udm</code> and you try to pass it a <code>@udk</code>, it will
fail.  The feature seems banal, but spacecraft have been laid low
by less.</p>

<p>This is clearly a crude mechanism.  If you don&#39;t like it, you
don&#39;t have to use it.</p>

<h2>Known odors</h2>

<p>Hoon knows about the following odors, with defined meanings:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">@c              UTF-32 codepoint
@d              date
  @da           absolute date
  @dr           relative date (ie, timespan)
@f              yes or no (inverse boolean)
@n              nil
@p              phonemic base
@r              IEEE floating-point
  @rd           double precision  (64 bits)
  @rh           half precision (16 bits)
  @rq           quad precision (128 bits)
  @rs           single precision (32 bits)
@s              signed integer, sign bit low
  @sb           signed binary
  @sd           signed decimal
  @sv           signed base32
  @sw           signed base64
  @sx           signed hexadecimal
@t              UTF-8 text (cord)
  @ta           ASCII text (span)
    @tas        ASCII symbol (term)
@u              unsigned integer
  @ub           unsigned binary
  @ud           unsigned decimal
  @uv           unsigned base32
  @uw           unsigned base64
  @ux           unsigned hexadecimal
</code></pre></div>
<p>Each of these forms has a URL-safe syntax, which we&#39;ll get to.
Each parses as an atomic constant in Hoon, and each is printed
by the Hoon prettyprinter.</p>

<p>But first, a little more Hoonology.</p>

<h2>The humble type</h2>

<p>What is a Hoon type, anyway?  We know a type is a noun.  So is 
everything.  What are the semantics of this noun?</p>

<p>Regardless of what this highly overloaded word may and does and
does mean in every other system of computation that has deployed
it, a type in Hoon has two roles.  </p>

<p>One, it defines a set of nouns.  Any finite noun is either in 
this set, or not in it.</p>

<p>Two, it ascribes semantics to all nouns in this set.  For
example, a Hoon type exports a semantic namespace.</p>

<p>With this settled, let&#39;s start by introducing, purely in an
informal and totally friendly way, the <code>tile</code> syntax in which 
<code>type</code> itself is defined in <code>/=main=/arvo/hoon/hoon</code>.  This is
not the full definition of <code>type</code>, just a simple subset:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">++  type  $|  ?(%noun %void)
          $%  [%atom p=term]
              [%cell p=type q=type]
          ==
</code></pre></div>
<p>Again, never mind the syntax.  We can easily describe this subset
of <code>type</code> in plain English.</p>

<p>It can be <code>%noun</code> (ie, the atom <code>1.853.189.998</code>).  Set:
all nouns.  Examples:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; :type; *
0
*

~waclux-tomwyc/try=&gt; -:!&gt;(*)
%noun

~waclux-tomwyc/try=&gt; :type; `*`%noun
1.853.189.998
*

~waclux-tomwyc/try=&gt; -:!&gt;(`*`%noun)
%noun
</code></pre></div>
<p>It can be the atom <code>%void</code>.  Set: no nouns.  We can&#39;t show any
examples producing <code>%void</code> - by definition, none of them would
terminate.  Because that&#39;s what <code>%void</code> means.</p>

<p>It can be the cell <code>[%atom p]</code>, where <code>p</code> is a <code>term</code> (<code>@tas</code>),
possibly empty (ie, <code>0</code>).  Set: all atoms.  Examples: above.</p>

<p>It can be the triple <code>[%cell p q]</code> (ie, <code>[%cell [p q]]</code>), where
each of <code>p</code> and <code>q</code> is itself a <code>type</code>.  Set: all cells of <code>p</code>
and <code>q</code>.  Examples:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; :type; [3 4]
[3 4]
[@ud @ud]

~waclux-tomwyc/try=&gt; -:!&gt;([3 4])
[%cell p=[%atom p=%ud] q=[%atom p=%ud]]
</code></pre></div>
<h3>The noble cube</h3>

<p>Let&#39;s introduce another kind of type here, because we&#39;ll need it
to talk about constant syntax:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">++  type  $|  ?(%noun %void)
          $%  [%atom p=term]
              [%cell p=type q=type]
              [%cube p=* q=type]
          ==
</code></pre></div>
<p>Note that when we enter an ordinary constant, like <code>42</code>, its type
<code>[%atom %ud]</code> is the set of all atoms (with odor <code>@ud</code>, but any
atom can have that or any odor).  Its type is certainly not the
set consisting exclusively of the value <code>42</code>.</p>

<p>But here&#39;s how we produce this &quot;cubical&quot; constant:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; :type; %42
%42
%42

~waclux-tomwyc/try=&gt; -:!&gt;(%42)
[%cube p=42 q=[%atom p=%ud]]
</code></pre></div>
<p>In general, a <code>%cube</code> type contains <code>p</code>, a single noun, and <code>q</code>,
a base type which provides semantics.</p>

<p>Syntactically, any atomic constant can be preceded by <code>%</code> to
generate a cube.  The exception is <code>@tas</code>, which always needs <code>%</code>
and is always cubical.</p>

<h2>Canonical atom syntaxes</h2>

<p>Let&#39;s briefly cover the syntax of each built-in odor.  It would
be counterproductive to specify them exactly here; first, this is
a tutorial rather than a spec, and second the spec is the code.
For the exact semantics, consult <code>++so</code> in <code>hoon.hoon</code>.  Rather,
we&#39;ll explain the form and run through some examples.</p>

<p>If some of these syntaxes seem contrived or odd, bear in mind:
none of them collides with any of the others, and they are all
URL-safe and more.  The canonical atom forms use only lowercase 
characters, numbers, <code>.</code>, <code>-</code>, and <code>~</code>.  A cell form adds <code>_</code>.</p>

<h3>Unsigned decimal, <code>@ud</code></h3>

<p>Unsigned decimal is the common or neutral atom representation.
It&#39;s not very compact and in many cases conveys no intelligible
information at all, but it&#39;s impossible to screw up.  <code>@ud</code> is
the default print format for both <code>@u</code> and <code>@</code> - ie, unsigned
numbers with no printing preference, and opaque atoms.</p>

<p>Hoon&#39;s unsigned decimal format is the normal Continental syntax.
It differs from the Anglo-American only in the use of periods,
rather than commas, between groups of 3:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; 0
0
~waclux-tomwyc/try=&gt; 19
19
~waclux-tomwyc/try=&gt; 1.024
1.024
~waclux-tomwyc/try=&gt; 65.536
65.536
~waclux-tomwyc/try=&gt; (bex 20)
1.048.576
</code></pre></div>
<p>An unsigned decimal not broken into groups is a syntax error.
Also, whitespace or even linebreaks can appear between the dot
and the next group. </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; 65.  536
65.536
</code></pre></div>
<h3>Unsigned hexadecimal, <code>@ux</code></h3>

<p><code>@ux</code> has the same syntax as <code>@ud</code>, except that it&#39;s prefixed by 
<code>0x</code> and uses groups of four.  Hex digits are lowercase only.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; 0x0
0x0
~waclux-tomwyc/try=&gt; `@ud`0x17
23
~waclux-tomwyc/try=&gt; `@ux`(bex 20)
0x10.0000
~waclux-tomwyc/try=&gt; 0x10.  0000
0x10.0000
</code></pre></div>
<h3>Unsigned base64, <code>@uw</code></h3>

<h3>Unsigned base32, <code>@uv</code></h3>

<p>The prefix is <code>0w</code> for base64 and <code>0v</code> for base32.  The digits
for <code>@uw</code> are, in order: <code>0-9</code>, <code>a-z</code>, <code>A-Z</code>, -, ~:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ud`0w-
62
</code></pre></div>
<p>For <code>@uv</code>, the digits are <code>0-9</code>, <code>a-v</code>.</p>

<h3>Signed decimal, <code>@sd</code></h3>

<h3>Signed hexadecimal, <code>@sx</code></h3>

<h3>Signed base64, <code>@sw</code></h3>

<h3>Signed base32, <code>@sv</code></h3>

<h3>Signed binary, <code>@sb</code></h3>

<p>Obviously, without finite-sized integers, the sign extension
trick does not work.  A signed integer in Hoon is a different way
to use atoms than an unsigned integer; even for positive numbers,
the signed integer cannot equal the unsigned.</p>

<p>The prefix for a negative signed integer is a single <code>-</code> before
the unsigned syntax.  The prefix for a <em>positive</em> signed integer
is <code>--</code>.  The sign bit is the low bit:  </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; -1
-1
~waclux-tomwyc/try=&gt; --1
--1
~waclux-tomwyc/try=&gt; `@ud`-1
1
~waclux-tomwyc/try=&gt; `@ud`--1
2
~waclux-tomwyc/try=&gt; `@ud`-2
3
~waclux-tomwyc/try=&gt; `@ud`--2
4
~waclux-tomwyc/try=&gt; `@ux`-0x10
0x1f
~waclux-tomwyc/try=&gt; `@ux`--0x10
0x20
~waclux-tomwyc/try=&gt; `@ud`--0w-
124
~waclux-tomwyc/try=&gt; `@sw`124
--0w-
</code></pre></div>
<h3>Absolute date, <code>@da</code></h3>

<p>Urbit dates represent 128-bit chronological time, with 2^64
seconds from the start of the universe to the end.  2^127 is
3:30:08 PM on December 5, AD 226, for reasons not clear or relevant:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@da`(bex 127)
~226.12.5..15.30.08

~waclux-tomwyc/try=&gt; `@da`(dec (bex 127))
~226.12.5..15.30.07..ffff.ffff.ffff.ffff
</code></pre></div>
<p>The time of day and/or second fragment is optional:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ux`~2013.12.7
0x8000.000d.2140.7280.0000.0000.0000.0000

~waclux-tomwyc/try=&gt; `@ux`~2013.12.7..15.30.07
0x8000.000d.2141.4c7f.0000.0000.0000.0000

~waclux-tomwyc/try=&gt; `@ux`~2013.12.7..15.30.07..1234
0x8000.000d.2141.4c7f.1234.0000.0000.0000
</code></pre></div>
<p>We also do BC:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ux`~226-.12.5
0x7fff.fffc.afb1.b800.0000.0000.0000.0000
</code></pre></div>
<p>The semantics of the time system are that UGT (Urbit Galactic
Time) is GMT/UTC as of leap second 25.  UGT is chronological and
will never add leap seconds, even if UTC continues this mistake.
If a gap appears, it must be resolved in the presentation layer, 
with timezones and other human curiosities.</p>

<h3>Relative date, <code>@dr</code></h3>

<p>It&#39;s also nice to have a syntax for basic time intervals:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ux`~s1
0x1.0000.0000.0000.0000

~waclux-tomwyc/try=&gt; `@ux`~m1
0x3c.0000.0000.0000.0000

~waclux-tomwyc/try=&gt; (div ~m1 ~s1)
60

~waclux-tomwyc/try=&gt; (div ~h1 ~m1)
60

~waclux-tomwyc/try=&gt; (div ~h1 ~s1)
3.600

~waclux-tomwyc/try=&gt; (div ~d1 ~h1)
24

~waclux-tomwyc/try=&gt; `@da`(add ~2013.11.30 ~d1)
~2013.12.1
</code></pre></div>
<p>There are no <code>@dr</code> intervals under a second or over a day.  Since
the resolution is so high, though, <code>(div ~s1 1.000.000)</code> produces
a pretty accurate microsecond.</p>

<h3>Loobean, <code>@f</code></h3>

<p>A loobean, or just <code>bean</code>, is 0 or 1.  <code>0</code> is yes, <code>1</code> is no:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ud`.y
0
~waclux-tomwyc/try=&gt; `@ud`.n
1
</code></pre></div>
<p>People who find this strange are probably strange themselves.</p>

<h3>Nil, <code>@n</code></h3>

<p>Nil indicates an absence of information, as in a list terminator.
The only value is <code>~</code>, <code>0</code>.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ud`~
0
</code></pre></div>
<h3>Unicode text, <code>@t</code></h3>

<p><code>@t</code> is a sequence of UTF-8 bytes, LSB first - sometimes called a
<code>cord</code>.  For lowercase numbers and letters, the canonical syntax 
is <code>~~text</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; ~~foo
&#39;foo&#39;
</code></pre></div>
<p>Note that the prettyprinter makes an unprincipled exception and 
prints the text in a noncanonical format:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ux`~~foo
0x6f.6f66
</code></pre></div>
<p>We want to be able to encode an arbitrary Unicode string as a
single URL-safe token, using no punctuation but <code>.~-</code>, in <code>@t</code>.
Space is <code>.</code>, <code>.</code> is <code>~.</code>, <code>~</code> is <code>~~</code>, <code>-</code> is <code>-</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; ~~foo.bar
&#39;foo bar&#39;
~waclux-tomwyc/try=&gt; ~~foo.bar~.baz~~moo-hoo
&#39;foo bar.baz~moo-hoo&#39;
</code></pre></div>
<p>For all other ASCII/Unicode characters, insert the Unicode
codepoint in lower-case hexadecimal, followed by <code>.</code>.  For
example, for U+2605 &quot;BLACK STAR&quot;, write:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; ~~foo~2605.bar
&#39;foo★bar&#39;
</code></pre></div>
<p>This UTF-32 codepoint is of course converted to UTF-8:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ux`~~foo~2605.bar
0x72.6162.8598.e26f.6f66
</code></pre></div>
<h3>URL-safe ASCII text, <code>@ta</code></h3>

<p><code>@ta</code> encodes the ASCII subset that all canonical atom syntaxes
restrict themselves to.  The prefix is <code>~.</code>.  There are no escape
sequences except <code>~~</code>, which means <code>~</code>, and <code>~-</code>, which means
<code>\_</code>.  <code>-</code> and <code>.</code> encode themselves.  No other characters
besides numbers and lowercase letters need apply.</p>

<p>Let&#39;s cast these to <code>@t</code> to see them quoted:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@t`~.foo
&#39;foo&#39;
~waclux-tomwyc/try=&gt; `@t`~.foo.bar
&#39;foo.bar&#39;
~waclux-tomwyc/try=&gt; `@t`~.foo~~bar
&#39;foo~bar&#39;
~waclux-tomwyc/try=&gt; `@t`~.foo~-bar
&#39;foo_bar&#39;
~waclux-tomwyc/try=&gt; `@t`~.foo-bar
&#39;foo-bar&#39;
</code></pre></div>
<p>A <code>@ta</code> atom is called a <code>span</code>.</p>

<h3>Codepoint, <code>@c</code></h3>

<p>Normally when we build atoms of Unicode text, we use a UTF-8
bytestream, LSB first.  But sometimes it&#39;s useful to build atoms
of one or more UTF-32 words.</p>

<p>The codepoint syntax is the same as <code>@t</code>, except with a <code>~-</code>
prefix.  Let&#39;s repeat our examples, with hex display:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ux`~-foo
0x6f.0000.006f.0000.0066

~waclux-tomwyc/try=&gt; `@ux`~-foo.bar
0x72.0000.0061.0000.0062.0000.0020.0000.006f.0000.006f.0000.0066
</code></pre></div>
<h3>Phonemic, <code>@p</code></h3>

<p>We&#39;ve seen <code>@p</code> used for ships, of course.  But it&#39;s not just for
ships - it&#39;s for any short number optimized for memorability, not
for arithmetic.  <code>@p</code> is great for checksums, for instance.</p>

<p>That said, <code>@p</code> is subtly customized for the sociopolitical
design of Urbit as a digital republic.  For example, one feature
we <em>don&#39;t</em> want is the ability to see at a glance which carrier
and cruiser issued a destroyer.  Consider the carrier <code>0x21</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@p`0x21
~mep
</code></pre></div>
<p>It issues <code>255</code> cruisers, including <code>0x4321</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@p`0x4321
~pasnut
</code></pre></div>
<p>Which issues <code>65.535</code> destroyers, including <code>0x8765.4321</code> and
several successors:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@p`0x8765.4321
~famsyr-dirwes
~waclux-tomwyc/try=&gt; `@p`0x8766.4321
~lidlug-maprec
~waclux-tomwyc/try=&gt; `@p`0x8767.4321
~tidlus-roplen
~waclux-tomwyc/try=&gt; `@p`0x8768.4321
~lisnel-lonbet
</code></pre></div>
<p>Of course, anyone who can juggle bits can see that
<code>~famsyr-dirwes</code> is a close cousin of <code>~lidlug-maprec</code>.  But she
actually has to juggle bits to do it.  Obfuscation does not
prevent calculated associations, just automatic ones.</p>

<p>But at the yacht level, we actually want to see a uniform 32-bit
space of yachts directly associated with the destroyer:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@p`0x9.8765.4321
~talfes-sibwaclux-tomwyc-famsyr-dirwes
~waclux-tomwyc/try=&gt; `@p`0xba9.8765.4321
~tacbep-ronreg-famsyr-dirwes
~waclux-tomwyc/try=&gt; `@p`0xd.cba9.8765.4321
~bicsub-ritbyt-famsyr-dirwes
~waclux-tomwyc/try=&gt; `@p`0xfed.cba9.8765.4321
~sivrep-hadfeb-famsyr-dirwes
</code></pre></div>
<h3>IPv4 address, <code>@if</code></h3>

<h3>IPv6 address, <code>@is</code></h3>

<p>Urbit lives atop IP and would be very foolish to not support
a syntax for the large atoms that are IPv4 and IPv6 addresses.</p>

<p><code>@if</code> is the standard IPv4 syntax, prefixed with <code>.</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ux`.127.0.0.1
0x7f00.0001
</code></pre></div>
<p><code>@is</code> is the same as <code>@if</code>, but with 8 groups of 4 hex digits:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ux`.dead.beef.0.cafe.42.babe.dead.beef
0xdead.beef.0000.cafe.0042.babe.dead.beef
</code></pre></div>
<h3>IEEE single-precision, <code>@rs</code></h3>

<h3>IEEE double-precision, <code>@rd</code></h3>

<h3>IEEE quad-precision, <code>@rq</code></h3>

<h3>IEEE half-precision, <code>@rh</code></h3>

<p>Hoon does not yet support floating point, so these syntaxes
don&#39;t actually work.  But the syntax for a single-precision
float is the normal English syntax, with a <code>.</code> prefix:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">.6.2832             ::  τ as @rs
.-6.2832            ::  -τ as @rs
.~6.2832            ::  τ as @rd
.~-6.2832           ::  -τ as @rd
.~~6.2832           ::  τ as @rh
.~~~6.2832          ::  τ as @rq
</code></pre></div>
<p>(Hoon is a Tauist language and promotes International Tau Day.)</p>

<h3>Transparent cell syntax</h3>

<p>By adding <code>_</code>, we can encode arbitrary nouns in our safe subset.
The prefix to a canonical cell is <code>._</code>; the separator is <code>_</code>;
the terminator is <code>__</code>.  Thus:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; ._3_4__
[3 4]

~waclux-tomwyc/try=&gt; :type; ._.127.0.0.1_._0x12_19___~tasfyn-partyv__
[.127.0.0.1 [0x12 19] ~tasfyn-partyv]
[@if [@ux @ud] @p]
</code></pre></div>
<p>Those who don&#39;t see utility in this strange feature have
perhaps never needed to jam a data structure into a URL.</p>

<h3>Opaque noun syntax</h3>

<p>Speaking of jam, sometimes we really don&#39;t care what&#39;s inside our
noun.  Then, the syntax to use is a variant of <code>@uw</code> prefixed by
<code>~</code>, which incorporates the built-in <code>jam</code> and <code>cue</code> marshallers:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; (jam [3 4])
78.241
~waclux-tomwyc/try=&gt; `@uw`(jam [3 4])
0wj6x
~waclux-tomwyc/try=&gt; (cue 0wj6x)
[3 4]
~waclux-tomwyc/try=&gt; ~0wj6x
[3 4]
</code></pre></div>
<h2>Noncanonical syntaxes</h2>

<p>These are syntaxes for constants which don&#39;t fit the canonical
character-set constraints.</p>

<h3>Hoon symbol, <code>@tas</code></h3>

<p><code>@tas</code>, a <code>term</code>, is our most exclusive odor.  The only
characters permitted are lowercase ASCII, <code>-</code> except as the first
or last character, and <code>0-9</code> except as the first character.</p>

<p>The syntax for <code>@tas</code> is the text itself, always preceded by <code>%</code>.
This means a term is always cubical.  You can cast it to <code>@tas</code>
if you like, but we just about always want the cube:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; %dead-fish9
%dead-fish9

~waclux-tomwyc/try=&gt; -:!&gt;(%dead-fish9)
[%cube p=271.101.667.197.767.630.546.276 q=[%atom p=%tas]]
</code></pre></div>
<p>The empty <code>@tas</code> has a special syntax, <code>$</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; %$
%$
</code></pre></div>
<p>A term without <code>%</code> is not a constant, but a name:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; dead-fish9
! -find-limb.dead-fish9
! find-none
! exit
</code></pre></div>
<h3>Loobeans, <code>@f</code></h3>

<p><code>.y</code> is a little cumbersome, so we can say <code>&amp;</code> and <code>|</code>.
The <code>%</code> prefix cubes as usual.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; `@ud`&amp;
0
~waclux-tomwyc/try=&gt; `@ud`|
1
</code></pre></div>
<h3>Cords, <code>@t</code></h3>

<p>The canonical <code>~~</code> syntax for <code>@t</code>, while it has its place, 
is intolerable in a number of ways - especially when it comes to
escaping capitals.  So <code>@t</code> is both printed and parsed in a
conventional-looking single-quote syntax:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; &#39;foo bar&#39;
&#39;foo bar&#39;
~waclux-tomwyc/try=&gt; `@ux`&#39;foo bar&#39;
0x72.6162.206f.6f66
</code></pre></div>
<p>Escape <code>&#39;</code> with <code>\</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; &#39;Foo \&#39;bar&#39;
&#39;Foo \&#39;bar&#39;
~waclux-tomwyc/try=&gt; `@ux`&#39;\&#39;&#39;
0x27
</code></pre></div>
<h3>Strings</h3>

<p>Text in Hoon is generally manipulated in two ways, depending on
what you&#39;re doing: as an atomic cord/span/term, or as a <code>tape</code>
which is a list of bytes (<em>not</em> codepoints).</p>

<p>To generate a tape, use double quotes:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; &quot;foo&quot;
&quot;foo&quot;
~waclux-tomwyc/try=&gt; `*`&quot;foo&quot;
[102 111 111 0]
</code></pre></div>
<p>We&#39;re getting off the constant reservation, but strings also
interpolate with curly-braces:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; &quot;hello {(weld &quot;wor&quot; &quot;ld&quot;)} is a fun thing to say&quot;
&quot;hello world is a fun thing to say&quot;
</code></pre></div>
<p>And they can be joined across space or lines with a <code>.</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~waclux-tomwyc/try=&gt; &quot;hello&quot;.&quot;world&quot;
&quot;helloworld&quot;
~waclux-tomwyc/try=&gt; &quot;hello&quot;. &quot;world&quot;
&quot;helloworld&quot;
</code></pre></div>
<p><a href="/doc/2013/11/18/ch4"><strong>Prev</strong>: Using Nock</a>
<a href="/doc/2013/11/18/ch6"><strong>Next</strong>: Moar Hoon Types</a></p>

</div>



    </div>

  </body>
</html>
