<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Urbit</title>
 <link href="http://urbit.org/atom.xml" rel="self"/>
 <link href="http://urbit.org/"/>
 <updated>2014-02-13T14:40:57-08:00</updated>
 <id>http://urbit.org</id>
 <author>
   <name>Tlon</name>
   <email></email>
 </author>

 
 <entry>
   <title>claiming ~net</title>
   <link href="http://urbit.org/blog/2014/01/15/net/"/>
   <updated>2014-01-15T06:59:00-08:00</updated>
   <id>http://urbit.org/blog/2014/01/15/net</id>
   <content type="html">&lt;p&gt;The quoted material comes from an email sent by Curtis Yarvin-- my reply is in-line.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The general idea of Urbit has always been to use the potential value of the
namespace to drive its development.  Partly this involves doing what we&amp;#39;ve
done, which is to create a company and get funding from evil VCs.  But
fundamentally, Urbit remains an open-source project - for example, there is
no secret codebase - and we can&amp;#39;t really succeed without public
contributions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Urbit is a labor of love, and I&amp;#39;d like to see it go far. Cosmic, even.
I doubt anyone will begrudge you for acting within the guidelines of
today&amp;#39;s Corporations-Are-People mindset, especially since the entire
operation has been transparent since the beginning.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Basically, as in all open-source projects, people have contributed and will
contribute to Urbit, because Urbit is cool and fun.  If they are in a sense
being paid, or expected to be paid, for this work, Urbit becomes less cool
and fun.  So we don&amp;#39;t want to see the real estate as in any sense a bounty,
a payment, a prize, etc, etc.  A crucial element of the scheme is that
those who win, win without any prior expectation of winning.  This
preserves the fun factor.  I hope.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The fun, for me, is in helping to create a virtual world, from scratch,
using no more than some simple mechanical rules. Urbit is fun, and I&amp;#39;m
pleased by how well my contributions have been accepted.  This is
already rewarding, though, of course, I&amp;#39;m not saying &amp;#39;no&amp;#39; to a carrier.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Owning an Urbit carrier is more than just a reward - it is also a duty.
 Urbit is a digital republic, and as a carrier owner you are literally a
senator of this republic.  For the moment, of course, the republic is tiny
and it does not need republican government - it needs a dictator.  As it
grows and succeeds, its governance must and will become not only
republican, but even democratic.  I hope this doesn&amp;#39;t shock anyone.&lt;/p&gt;

&lt;p&gt;It seems clear that those who accept this duty (you can always decline)
should be defined by one word: virtue.  A virtuous republic is impossible
without virtuous governors.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One time, I was talking about Urbit, and someone summarized it as &amp;quot;It
sounds like you&amp;#39;re kind of important in this imaginary world.&amp;quot;  I
shouldn&amp;#39;t let this talk get to my head, but it gets difficult when you
send out messages about how important my participation can be. ;)  Now I
get to talk about being a Rear Admiral in the Urbit Republic, or
something along those lines.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Therefore, I&amp;#39;ve decided to issue urbit.org carriers in the following way:
distribution is in rounds, each of which is defined by a previously
unannounced virtue.  For instance, in 2010, I committed to issuing carriers
to anyone who could write decrement in Nock.  I promised a prize to be
disclosed later.  I don&amp;#39;t think anyone had any idea that this prize would
be something you could sell (please don&amp;#39;t, though!) for over $10,000.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;quot;You can&amp;#39;t even buy these for dollars,&amp;quot; Y.T. says, of her skateboard.
I&amp;#39;m humbled by this reward, and to sell it would be completely contrary
to the virtue expected of us.  `@udd`10.000 is certainly a number, but
its type isn&amp;#39;t compatible with ++zeno.&lt;/p&gt;

&lt;p&gt;All this is to say that I&amp;#39;ll take this duty seriously.  Sinking a
carrier makes a large portion of the address space go dark, a
complication we can all do without.  Urbit is easy, uncomplicated, and
fun, but fun can&amp;#39;t exist without some serious work behind it.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What was the virtue of the 2010 winners?  One of the classic virtues -
luck.  They did the right thing in the right place at the right time.
 Hence, in the carrier database their carriers are listed as &amp;quot;per fortuna.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It still surprises me that Nock, as we know it, has been around this
long.  We live in a culture where something from 3 months ago is
considered old news, which makes the `fortuna&amp;#39; carrier-holders ancient...&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In this round we&amp;#39;re celebrating a different virtue - loyalty to Urbit.
 Your carrier is &amp;quot;per fidelis.&amp;quot;  This reflects the fact that for the last
three months, more or less, you have showed up, chatted, evangelized, sent
bug reports, worked through the doc, etc, etc, etc.  Without any
expectation of being rewarded for this, obviously.  It is the lack of
expectation that makes the reward genuinely effective, and not
overjustified.  I hope.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The experience of poking around in this digital labyrinth is utterly
addictive.  Even without the potential for reward, Urbit would hold my
attention, so the reward is indeed effective.  (I hope.)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Unless you are a present carrier holder, feel free to look through ++zeno
and pick any carrier that is presently assigned to me or to Tlon, other
than ~zod of course.  We&amp;#39;ll adjust the bindings as needed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I like the idea of holding carrier ~net, `@p`79. The associations for
that number are mostly favorable, and I won&amp;#39;t belabor the point by
listing them all out.&lt;/p&gt;

&lt;p&gt;As a final note. I recognize that having a carrier means giving up most
of the privacy I sought in the atax1a mask, but that privacy was
illusory (and orthogonal to Urbit) anyway.  This is the price of living
in our modern world.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Continuity Breach</title>
   <link href="http://urbit.org/blog/2014/01/06/continuity/"/>
   <updated>2014-01-06T06:59:00-08:00</updated>
   <id>http://urbit.org/blog/2014/01/06/continuity</id>
   <content type="html">&lt;p&gt;A continuity breach occurs when the entire Urbit network gets recreated- this will not happen in real life! All ships and piers prior to the breach will no longer work with the new network.&lt;/p&gt;

&lt;p&gt;What does this mean for the Urbit user? If your ships have spontaneously stopped working and you built your ships and piers before the date in the lower left-hand corner of this site, (the Urbit date format is ~year.month.day), run the following commands from your urbit directory:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git pull origin master&lt;/code&gt; to get the up to date source&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make clean; make&lt;/code&gt; to build&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm -rf $URBIT_HOME/*-*&lt;/code&gt; to wipe your old ships. Be sure to save any important files.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm -rf $mypier&lt;/code&gt; to wipe your piers, replace &lt;code&gt;$mypier&lt;/code&gt; with whatever your pier names are.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vere -c $mypier&lt;/code&gt; to build a new pier&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:begin&lt;/code&gt; and relaunch your destroyers&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:chat to chat&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Email &lt;code&gt;urbit@urbit.org&lt;/code&gt; if you have any questions or would like assistance. &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Urbit Is &#58; Chapter 0</title>
   <link href="http://urbit.org/blog/2013/12/13/urbit-ch0/"/>
   <updated>2013-12-13T17:23:00-08:00</updated>
   <id>http://urbit.org/blog/2013/12/13/urbit-ch0</id>
   <content type="html">&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Greetings from the off-world colonies! I&amp;#39;m your guide and scribe,
&lt;code&gt;atax1a&lt;/code&gt;, a character from a book that hasn&amp;#39;t been written yet. Every
great book has a Chapter 0, though, and you are reading mine.&lt;/p&gt;

&lt;p&gt;I am often asked...&lt;/p&gt;

&lt;h1&gt;What Is Urbit?&lt;/h1&gt;

&lt;p&gt;Urbit could be a way of sharing your data in a way that makes it live
forever.  Maybe it&amp;#39;s a Facebook of memories, 140 Twitters of words, or
an Instagram for when you&amp;#39;re a grandpa. Maybe you send Urbit an email.
You can hit it with your web browser right now, but that&amp;#39;s a bit rough
around the edges. (Given time, it could even be that BBS or MUD that
you wanted, but could never have...) It could be anything --- right
now, we use it as a glorified chat program, but one that never loses
messages. Well, almost never.  Sometimes we have to reboot the
Universe, and everything we haven&amp;#39;t backed up is lost.&lt;/p&gt;

&lt;p&gt;You may be getting the idea that Urbit is hard to define precisely. It is,
because it isn&amp;#39;t finished yet. In reality, Urbit is just a labyrinth
of code, written as a book, running on a virtual machine (possibly
running on another virtual machine, and so on), built out of physical
parts, and it&amp;#39;s read and written )and edited( by human mammals on a
planet called Earth. (The Urbit computer follows a &amp;quot;Hears, knows,
does&amp;quot; model, which I can explain later.) A lot of Earthlings call it
an art project, which isn&amp;#39;t far off. Sometime it&amp;#39;s Dada, other times
it&amp;#39;s baroque, but it always has a precise scientific backing in the
form of &lt;em&gt;Nock&lt;/em&gt;, which are the fundamental axioms (rules) of the
Urbiverse. Nock is all numbers, tho, and it&amp;#39;s tiring.&lt;/p&gt;

&lt;p&gt;Urbit is also a programming language. We call that &lt;em&gt;Hoon&lt;/em&gt;, for reasons
I&amp;#39;m still not quite clear on. It takes Nock&amp;#39;s numbers and puts symbols
on them. They&amp;#39;re kinda weird symbols, and most &amp;quot;real&amp;quot; programmers I
know (and work with) take one look at something like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=(x=@ ?:((lth x 2) 1 (add $(x (dec x)) $(x (sub x 2)))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and go pale around the gills. Myself, I grew up speaking a language
called &lt;code&gt;perl&lt;/code&gt;, which has an even bigger love-affair with special
characters, so reading this doesn&amp;#39;t faze me (Hoon uses its special
characters judiciously, so please don&amp;#39;t think of &lt;code&gt;perl&lt;/code&gt; unless you like
that sort of thing).&lt;/p&gt;

&lt;p&gt;An earlier version of Urbit (when Hoon was still called Watt) was
rejected from a real scientific conference because the judges felt
vaguely insulted by the nonstandard language. The Urbit you&amp;#39;re looking
at now has had a few years to cool down and mature, and right now it&amp;#39;s
so cool at the core that it&amp;#39;s well below -400 Fahrenheit. Thankfully,
there is an entire planet built up around its icy core, and on the
surface of that planet, it&amp;#39;s a balmy 25 degrees Celsius, and the water
is like glass.&lt;/p&gt;

&lt;p&gt;Urbit is currently only usable by a hyperliterate set of people ---
it&amp;#39;s immersed in the culture of the word, and it&amp;#39;s struggling for a
glimpse of air, the sound of music, and a taste of freedom.  Really,
though, it&amp;#39;s easy to teach yourself, if you work through it with a
dedicated mind. Having a friend along for the ride is definitely
recommended. People with prior programming experience are welcome, but
be warned: your existing biases and expectations are wrong. We&amp;#39;ll try
and be gentle about breaking them.&lt;/p&gt;

&lt;h1&gt;Why should I care? (the buried lede)&lt;/h1&gt;

&lt;p&gt;In the end, Urbit is a single global computer. Think &amp;quot;Cyberspace&amp;quot; from
&lt;em&gt;Neuromancer&lt;/em&gt;, or &amp;quot;The Metaverse&amp;quot; from &lt;em&gt;Snow Crash&lt;/em&gt;. If you&amp;#39;re really
early, think of Haflinger&amp;#39;s worm from &lt;em&gt;The Shockwave Rider&lt;/em&gt;. But don&amp;#39;t
think of it as the Internet --- the internet is a single global
&lt;em&gt;network&lt;/em&gt;, and it only follows two rules: you can act like a UNIX
machine when prompted, and you speak TCP/IP. Anyone can see what
you&amp;#39;re saying, and most people can understand it. There are gaps in
the network, too: &lt;em&gt;The Great Firewall Of China&lt;/em&gt;, anyone? &amp;quot;Encryption&amp;quot;,
or as I might call it, &lt;em&gt;privacy&lt;/em&gt;, is an afterthought, and people who
Never Say Anything can read a lot of supposedly &amp;quot;private&amp;quot; things, just
by doing the right math. &lt;em&gt;Urbit isn&amp;#39;t like that&lt;/em&gt;. It enables secure,
private, computing, in a way that nobody else can, because it is
&amp;quot;semantically isolated&amp;quot; --- the meaning of the Urbit program is
independent of the outside world (in this case, the Internet).&lt;/p&gt;

&lt;p&gt;Urbit works like an Internet should. If you know someone&amp;#39;s address,
you can send them a message. It will either reliably be delivered, or
get rejected. Likewise with requesting something: if you ask for
tomorrow&amp;#39;s newspaper headline &lt;em&gt;today&lt;/em&gt;, Urbit will gladly give it to
you...  tomorrow. Your ship just waits for it to come in, and when it
does, everything proceeds like normal. &amp;quot;HTTP 404 Not Found&amp;quot;? What the
&lt;code&gt;!^&amp;amp;#&lt;/code&gt; does THAT mean?&lt;/p&gt;

&lt;h2&gt;Who ARE you people?&lt;/h2&gt;

&lt;p&gt;We&amp;#39;re dreamers, but the dream escaped and is slowly consuming the real
world. We&amp;#39;re programmers with a sense of humor and an overload of
whimsy. At the end of the day, though, we&amp;#39;re just people just like
you. People who want to change the world.  Everyone wants to change
the world, right?&lt;/p&gt;

&lt;h2&gt;And what is with all of the weird words?&lt;/h2&gt;

&lt;p&gt;Urbit is a piece of technology. Unfortunately, technology is hard to
explain, and it gets harder when the words we use to explain it are
misunderstood.  If you&amp;#39;re used to speaking about your computers in
terms of a Unix (or Windows) workstation, it&amp;#39;s a bit of a leap to
think in terms of Urbit ships in a pier.&lt;/p&gt;

&lt;p&gt;In short, we use weird words to force a change in how our technology
is perceived. Without that, readers are likely to gloss over important
details, thinking that they understand more than they really do. It&amp;#39;s
why we redefine everything, change the pronunciation of the symbols
you&amp;#39;re used to, and even have our own number system. Count with me,
and feel free to scribble in the margins:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~zod 0   (also &amp;#39;yes&amp;#39;)                 if i were rewriting this
~nec 1   (no)                            i would put &amp;#39;can&amp;#39; b4
~bud 2   [the rest of the numberz        &amp;#39;change meaning…&amp;#39;
~wes 3        change meaning
~sev 4    according to context]
~per 5   ---
~sut 6   &amp;lt;but that&amp;#39;s 0kay&amp;gt;
~let 7   
~ful 8   
~pen 9   ¡you can figure it out!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Saying them out loud helps. You and your friend can agree on the
pronunciation.&lt;/p&gt;

&lt;h1&gt;Introductions&lt;/h1&gt;

&lt;p&gt;You can get in touch with me on Urbit, of course. Join up to &lt;code&gt;:chat&lt;/code&gt;
and use &lt;code&gt;=&lt;/code&gt; to see who&amp;#39;s in the room. On the old internet, I go by
many names, but on this one I try to stick with &lt;code&gt;~hatteb-mitlyd&lt;/code&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Chapter XI (Odds, Ends, Quirks)</title>
   <link href="http://urbit.org/doc/2013/11/19/ch11/"/>
   <updated>2013-11-19T00:00:00-08:00</updated>
   <id>http://urbit.org/doc/2013/11/19/ch11</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/doc/2013/11/19/ch10&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Type Inference&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;A bestiary of cores&lt;/h2&gt;

&lt;p&gt;The Hoon core is just not a gadget you&amp;#39;re familiar with from
your Earth programming career.  A core is not a lambda, a
closure, a library, an object, etc.  Or perhaps we should say:
when we translate any of these into Hoon, we get a core.  So we
cannot translate &amp;quot;core&amp;quot; into any one of them.&lt;/p&gt;

&lt;p&gt;But clearly in practice there are lots of different kinds of
practical cores.  For example, we have already met Hoon&amp;#39;s
equivalent of the lambda, the &lt;code&gt;gate&lt;/code&gt;.  Every gate is a core, but
not every core is a gate.  And the gate is by no means the only
subspecies of core.  So describing cores becomes a big part of
the Hoonist&amp;#39;s alien vocabulary.  &lt;/p&gt;

&lt;p&gt;Let&amp;#39;s review briefly what we know about cores.  A core is a noun
of the form&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[battery payload]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where the &lt;code&gt;battery&lt;/code&gt; is a tree of formulas, each invoked with the
entire core as the subject, and the payload is any noun.&lt;/p&gt;

&lt;p&gt;There are three main ways we can talk about a core: its variance
model, &lt;code&gt;%gold&lt;/code&gt;, &lt;code&gt;%iron&lt;/code&gt;, &lt;code&gt;%zinc&lt;/code&gt; or &lt;code&gt;%lead&lt;/code&gt;, &lt;code&gt;%gold&lt;/code&gt; by default;
the inference approach of each of its feet, &lt;code&gt;%ash&lt;/code&gt; or &lt;code&gt;%elm&lt;/code&gt;,
informally &lt;code&gt;dry&lt;/code&gt; or &lt;code&gt;wet&lt;/code&gt;, &lt;code&gt;dry&lt;/code&gt; or &lt;code&gt;ash&lt;/code&gt; by default; and its
payload pattern, which makes it a &lt;code&gt;gate&lt;/code&gt;, &lt;code&gt;reef&lt;/code&gt;, &lt;code&gt;book&lt;/code&gt;,
&lt;code&gt;trap&lt;/code&gt; or &lt;code&gt;tray&lt;/code&gt;.  There are also several ways of using cores:
you can &lt;code&gt;pull&lt;/code&gt;, &lt;code&gt;kick&lt;/code&gt;, &lt;code&gt;slam&lt;/code&gt; or &lt;code&gt;slug&lt;/code&gt; them.&lt;/p&gt;

&lt;p&gt;For an explanation of variance and inference, see chapter 10.
Here, let&amp;#39;s go over the payload patterns.  Unlike most concepts
in Hoon, these are strictly informal conventions.  A core is a
core - there is no code in &lt;code&gt;hoon.hoon&lt;/code&gt; that deals with a &lt;code&gt;gate&lt;/code&gt;
per se.  Nonetheless, these definitions are precise and
unambiguous.&lt;/p&gt;

&lt;h3&gt;Book&lt;/h3&gt;

&lt;p&gt;A core whose payload is either another core, or a constant
(&lt;code&gt;%cube&lt;/code&gt;), is a &lt;code&gt;book&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Reef&lt;/h3&gt;

&lt;p&gt;A book whose payload is either another reef, or a cube, is a
&lt;code&gt;reef&lt;/code&gt;.  Effectively, a reef is an entirely constant core.&lt;/p&gt;

&lt;h3&gt;Trap&lt;/h3&gt;

&lt;p&gt;Any core with one arm named &lt;code&gt;%$&lt;/code&gt; is a trap.  &amp;quot;It&amp;#39;s a trap!&amp;quot;&lt;/p&gt;

&lt;h3&gt;Gate&lt;/h3&gt;

&lt;p&gt;A gate is a trap whose payload has the form &lt;code&gt;[sample context]&lt;/code&gt;,
&lt;code&gt;sample&lt;/code&gt; being dynamic data and &lt;code&gt;context&lt;/code&gt; being anything.&lt;/p&gt;

&lt;h3&gt;Tray&lt;/h3&gt;

&lt;p&gt;A tray is any core whose payload has the form &lt;code&gt;[sample
context]&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Categories&lt;/h3&gt;

&lt;p&gt;Every reef is a book.  Every gate is a trap.  Every gate is a
tray.&lt;/p&gt;

&lt;h3&gt;Using cores&lt;/h3&gt;

&lt;p&gt;As we already know, a name or axis (which of course applies to
all nouns, not just cores) is a &lt;code&gt;limb&lt;/code&gt;.  A list of limbs is a
&lt;code&gt;wing&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;To access a wing or limb in a core is to &lt;code&gt;pull&lt;/code&gt; it.  When we
write &lt;code&gt;a.b.x&lt;/code&gt;, we pull the wing &lt;code&gt;a.b&lt;/code&gt; (ie, &lt;code&gt;a&lt;/code&gt; within &lt;code&gt;b&lt;/code&gt;) from
&lt;code&gt;x&lt;/code&gt;.  If the result is defined as a subtree of &lt;code&gt;x&lt;/code&gt;, the wing is a
&lt;code&gt;leg&lt;/code&gt;.  If it is computed from &lt;code&gt;x&lt;/code&gt; by a formula, it&amp;#39;s an &lt;code&gt;arm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To pull &lt;code&gt;%$&lt;/code&gt; - the empty name - on a core is to &lt;code&gt;kick&lt;/code&gt; it.  To
replace the sample with &lt;code&gt;a&lt;/code&gt; in gate &lt;code&gt;g&lt;/code&gt; then kick the gate, is
to &lt;code&gt;slam g with a&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;(The archaic usage of &amp;quot;call&amp;quot; for &lt;code&gt;slam&lt;/code&gt; is discouraged, but
common.  Please at least do not use &amp;quot;call&amp;quot; to mean &lt;code&gt;pull&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Slamming is a special case of &lt;code&gt;slug&lt;/code&gt;, which pulls any limb on a
tray after replacing the sample.  To replace the sample with &lt;code&gt;a&lt;/code&gt;
on tray &lt;code&gt;t&lt;/code&gt;, then pull &lt;code&gt;m&lt;/code&gt;, is to &lt;code&gt;slug t to m with a&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Thus when we write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;(~(get by foo) bar)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;++by&lt;/code&gt; produces a tray.  We slug &lt;code&gt;by&lt;/code&gt; to &lt;code&gt;get&lt;/code&gt; with &lt;code&gt;foo&lt;/code&gt;,
producing a gate that searches the map &lt;code&gt;foo&lt;/code&gt;, and slam this gate
with &lt;code&gt;bar&lt;/code&gt;.  This is the most normal possible thing in the
universe, though it must seem strange to you now.&lt;/p&gt;

&lt;h2&gt;On jet propulsion&lt;/h2&gt;

&lt;p&gt;Consider the problem of optimizing a Nock interpreter.  Let&amp;#39;s
assume that this process must not and will not contaminate the
pristine semantics of Nock itself.&lt;/p&gt;

&lt;p&gt;But by definition, the interpreter does not need to be optimized
to compute all possible functions as fast as possible.  It only
needs to be optimized for the functions it computes.&lt;/p&gt;

&lt;p&gt;Moreover, any given function (to use the word in its abstract
mathematical sense), can be computed by an indefinite, and
generally infinite, number of Nock formulas.  Again, we do not
need to optimize all possible formulas - just the ones our
interpreter actually executes.&lt;/p&gt;

&lt;p&gt;A crude approach to this problem would be to compute the hash of
every formula we interpret, and hardcode these hashes into the
interpreter.  For hashes both commonly executed, and known to
match some known algorithm, a manual implementation of that
algorithm would be run.&lt;/p&gt;

&lt;p&gt;Not quite what we do, but it&amp;#39;s close enough.  Nock&amp;#39;s conventional
jet model is more or less this hash-matching with the addition of
a reasonably convenient and effective mechanism for matching
formulas and their manual implementations (&amp;quot;jets&amp;quot;).&lt;/p&gt;

&lt;p&gt;In general it is not correct to match the formula when detecting
jet invocations.  Rather, we need to match the entire core and
the arm being pulled.  In other words, when instrumenting a Nock
interpreter, the correct way to match jets is to sit on top of 
Nock 9 and match both subject and arm.&lt;/p&gt;

&lt;p&gt;When matching the subject to see if we can use a jet, we need a
jet description that (a) expects the subject to be a core, (b)
uses a hash to make sure it has the &lt;em&gt;battery&lt;/em&gt;, and (c) imposes
some other complex constraint on the &lt;em&gt;payload&lt;/em&gt; of the core.&lt;/p&gt;

&lt;p&gt;(Who writes this jet description?  Perhaps the programmer who
wrote the core.  But this requires the programmer to either be the
developer who runs the core, or to have some parallel channel for
delivering her optimizations to the consumer.)&lt;/p&gt;

&lt;p&gt;In any case, our task is matching the core to the jet.  We divide
this into two parts: one, matching the battery (and arm, since
different arms in a core may or may not be jet-propelled); two,
checking the payload constraint.&lt;/p&gt;

&lt;p&gt;It is not practical to compute a hash, especially a &lt;em&gt;secure&lt;/em&gt;
hash, of every formula we reduce in Nock - or even of every
battery.  We also do not want to make this match heuristically.
Finally, we do not want to give the developer - who may well be
creating the battery and the jet at the same time - the job of
computing hashes by hand.&lt;/p&gt;

&lt;p&gt;Battery matching is still a difficult and potentially ugly
problem.  Worst of all, it seems potentially slow.  Some things
that save us:&lt;/p&gt;

&lt;p&gt;One, at least unless co-developing core and jet, it is generally 
not common for new batteries to be created.  Therefore, caching
is very worthwhile and pointer equality is often useful.&lt;/p&gt;

&lt;p&gt;Two, we do not have room for a full secure hash on every noun,
and we do not want to distinguish batteries from ordinary nouns
when it comes to storage.  However, every indirect noun does have
a 31-bit slot for a conventional FNV hash, &lt;code&gt;++mug&lt;/code&gt;.  This is
computed lazily, relying on the fact that &lt;code&gt;0&lt;/code&gt; is not in its
range.  (The mug slot is very useful for jet dispatch - but not
used only for jet dispatch.)&lt;/p&gt;

&lt;p&gt;Broadly speaking, while &lt;code&gt;++mug&lt;/code&gt; is by no means infallible, it
reduces the associative process enough for linear search to be
perfectly practical.&lt;/p&gt;

&lt;p&gt;We then need to check the payload.  Broadly speaking, the payload
consists of some mosaic of code, static data, and dynamic data.&lt;/p&gt;

&lt;p&gt;Consider a giant reef, like the one &lt;code&gt;hoon.hoon&lt;/code&gt; constructs.  A
reef is a stack of books, in which each book is the payload of
the one above it.  To make sure our jet matches an arm in any of
these books, we need to check &lt;em&gt;every battery in the stack&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The trick to checking a payload is to simplify the payload into a
single &lt;em&gt;parent core&lt;/em&gt; and a surrounding bundle of data.  To
recognize its core, it is sufficient to (a) recognize its parent
- matching, once again, by the battery - and (b) validate all
other data in the core.&lt;/p&gt;

&lt;p&gt;The most common structure of this form is, of course, the tray
&lt;code&gt;[battery [sample context]]&lt;/code&gt;.  (Again, iff &lt;code&gt;battery&lt;/code&gt; is a single 
formula which implements an arm &lt;code&gt;%$&lt;/code&gt;, our tray is a gate.)  Trays
and other core conventions are simply design patterns, which may
be violated with complete impunity.  And there of course may be
multiple cores within the payload.  One must be selected and
treated as the parent; the rest are static data.&lt;/p&gt;

&lt;p&gt;As for the sample and/or other dynamic data, it may or may not
prove useful and/or efficient for a jet dispatch mechanism to
enforce basic structure constraints on it.  Remember that, at the
Nock level, we have no guarantee that this core was constructed
in accordance with Hoon type rules.  &lt;/p&gt;

&lt;p&gt;However, we can ask the programmer to at least do us the favor of
declaring &lt;em&gt;logical&lt;/em&gt; cores.  Every time we construct a core -
which, for a core defined by an arm in a book, ie, a typical
library function, is every time we use it - we identify, using
the three legs of the &lt;code&gt;%sgcn&lt;/code&gt; hint, three aspects of this core:&lt;/p&gt;

&lt;p&gt;(p) the axis to its parent core
(q) the logical version of the algorithm implemented
(r) a list of bound arms, as [name axis] pairs&lt;/p&gt;

&lt;p&gt;Thus there are two sources of information for a match: the
Hoon programmer, who specifies the logical name of her core;
and the jet programmer, whose declaration matches that logical
name, verifies the match by computing an actual hash, and also
describes any other constraints on the core her jet requires for
it to accurately simulate Nock.  &lt;/p&gt;

&lt;p&gt;In addition, it is very advisable for a jet framework to include
tools that let the jet programmer bail out trivially with a
refusal to handle any given case of the function, returning
control to the pure Nock interpreter.&lt;/p&gt;

&lt;p&gt;Another advantage of this model is that interpreters which
receive a match for jets for they don&amp;#39;t have, still have a
declaration from the programmer&amp;#39;s hand of the set of inner loops
that need to be optimized.  This completely eliminates any excuse
for a complex tracing JIT.  We know exactly where to JIT:
wherever we don&amp;#39;t find a jet.&lt;/p&gt;

&lt;h2&gt;Gonads&lt;/h2&gt;

&lt;p&gt;It&amp;#39;s common in functional programming to create pipelines of
functions which accept and produce the same type.  If we have
two, three, or 47 gates which both accept and produce an atom,
it&amp;#39;s easy to string them together into one gate with two, three,
or 47 pipeline steps.&lt;/p&gt;

&lt;p&gt;Suppose we think of one of these homogeneous parts as a block:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   ----
  |    |
-&amp;gt;| F  |-&amp;gt;
  |    |
   ----

one little function
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It&amp;#39;s clear that these blocks fit neatly together into a pipeline:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   ----  ----  ----  ----
  |    ||    ||    ||    |
-&amp;gt;| F  || G  || H  || I  |-&amp;gt;
  |    ||    ||    ||    |
   ----  ----  ----  ----

one big function
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But suppose we have a function whose product isn&amp;#39;t the same type
as its sample?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   ----
  |    \
-&amp;gt;| F   )-&amp;gt;
  |    /
   ----

one funky function
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It would seem difficult to use this as a building block.  But in
fact, all we need is a little piece of glue that accepts the
product type of F, and produces its sample type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;  ----
 \    |
-&amp;gt;) U |-&amp;gt;
 /    |
  ----

one gluey function
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this, we can construct pipelines using U as the &amp;quot;mortar&amp;quot;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   ----  ----  ----  ----  ----  ----  ---- 
  |    \\    ||    \\    ||    \\    ||    \
-&amp;gt;| F   )) U || G   )) U || H   )) U || I   )-&amp;gt;
  |    //    ||    //    ||    //    ||    /
   ----  ----  ----  ----  ----  ----  ---- 

one big funky, gluey function
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that just as FGHI in the simple model has the same interface
as F, G, H or I, FUGUHUI in the complex model has the same
interface as F, G, H, or I.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s say the sample of F, the straight line, is X, and the
product of F, the bump, is Y.  So FUGUHUI turns an X into a Y,
just the way F does.&lt;/p&gt;

&lt;p&gt;We can make this system even more powerful if, instead of using
the simple tool U, a gate whose sample is Y and whose product X, 
we use a more complex tool V.  V is a gate whose sample is a cell
&lt;code&gt;[m n]&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is a Y and &lt;code&gt;n&lt;/code&gt; is another gate matching F.
V&amp;#39;s product remains a Y.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s what this looks like in ASCII art:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   ----  ---- 
  |    \\    \
-&amp;gt;| F   )m V  )-&amp;gt;
  |    //    /
   ----  ---- 
          |n
         ----  ----  
        |    \\    \
      -&amp;gt;| G   )m V  )-&amp;gt;
        |    //    /
         ----  ---- 
                |n
               ----  ----  
              |    \\    \
            -&amp;gt;| H   )m V  )-&amp;gt;
              |    //    /
               ----  ---- 
                      |n
                     ----  ----  
                    |    \\    \
                  -&amp;gt;| I   )m V  )-&amp;gt;
                    |    //    /
                     ----  ---- 

one big funky, gluey, complicated function
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What&amp;#39;s the advantage?  A V-function is more powerful than a
U-function, because the U-function has no choice but to turn its
X into a Y and use &lt;code&gt;n&lt;/code&gt;, the rest of the pipeline, on it.  The V
function can do anything with its input - it could even ignore
the rest of the pipeline and just produce the &lt;code&gt;m&lt;/code&gt; it got in.&lt;/p&gt;

&lt;p&gt;In Hoon, we call one of these funky, gluey, complicated pipelines
a &lt;code&gt;gonad&lt;/code&gt;.  The gonad rune is &lt;code&gt;;~&lt;/code&gt;, &lt;code&gt;[%smsg p q]&lt;/code&gt;.  A gonad has
one &lt;code&gt;go&lt;/code&gt;, the V part - &lt;code&gt;p&lt;/code&gt; in &lt;code&gt;[%smsg p q]&lt;/code&gt; - and one or more
&lt;code&gt;nads&lt;/code&gt;, the F, G, H or I parts (&lt;code&gt;q&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;There&amp;#39;s one other complicated trick we play to make our gonads
work better.&lt;/p&gt;

&lt;p&gt;If you look at the expansion, you&amp;#39;ll see that before we pass &lt;code&gt;n&lt;/code&gt;
to V, the go, we reset its sample to the sample of the gate that
&lt;code&gt;%smsg&lt;/code&gt; produces.  Since neither the go nor &lt;code&gt;n&lt;/code&gt; would otherwise
see this value, it allows for more hackery.&lt;/p&gt;

&lt;p&gt;For instance, gonads are often used for parsing.  A common go for
parsing is &lt;code&gt;++pose&lt;/code&gt;, whose nads are parsing rules tried in order -
the first to parse succeeds.  Because of this trick, when the
first nad returns a parsing failure, the second nad is sent to
the go pre-configured with the original problem.&lt;/p&gt;

&lt;p&gt;The go doesn&amp;#39;t have to do a proper slam on &lt;code&gt;n&lt;/code&gt;, replacing its 
sample.  It can just use &lt;code&gt;n&lt;/code&gt; as a trap, leaving the sample
default - in the case of &lt;code&gt;++pose&lt;/code&gt;, the original parsing problem.
Which is exactly what we want.&lt;/p&gt;

&lt;h2&gt;On debugging your urbits&lt;/h2&gt;

&lt;p&gt;Okay so you tried to do something and it didn&amp;#39;t work.&lt;/p&gt;

&lt;p&gt;What happened?  Hopefully, nothing bad.  But coding is a vale of
tears.  Here are some bad things that can happen to you in Hoon.&lt;/p&gt;

&lt;h3&gt;Parse error&lt;/h3&gt;

&lt;p&gt;You could be &amp;#39;avin a parse error.  The Hoon parser reports
the location - line and column - of errors quite accurately.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s generate an erroneous file.  Open up &lt;code&gt;try/bin/foo.hoon&lt;/code&gt;,
an empty file, and put a &lt;code&gt;#&lt;/code&gt; at line 8, column 4.  Then type&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :foo
! /~waclux-tomwyc/try/~2014.2.9..06.58.40..e352/bin/foo/hoon
! {8 4}
! &amp;#39;syntax-error&amp;#39;
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That means you got a syntax error at line 8, column 4, when
trying to load &lt;code&gt;/~waclux-tomwyc/try=/bin/foo/hoon&lt;/code&gt;.  (You may
also see traces for &lt;code&gt;/~waclux-tomwyc/arvo=/batz/hoon&lt;/code&gt;, which
simply means Arvo was compiled with debugging.)  &lt;/p&gt;

&lt;p&gt;This is always exactly right, for certain values of &amp;quot;right.&amp;quot;
As always, you have to understand what Hoon is thinking.&lt;/p&gt;

&lt;p&gt;The position of the error is the position at which the parser
&lt;em&gt;stopped being able to parse&lt;/em&gt; - it has no way to interpret the 
byte at this line and column.  Often this is actually where you
screwed up.  It is at least no &lt;em&gt;later&lt;/em&gt; than you screwed up.&lt;/p&gt;

&lt;p&gt;But one of the prices we pay for for a tall form without
terminators is that the parser relies on knowing that after a
&lt;code&gt;:+&lt;/code&gt;, for instance, it expects to parse exactly three twigs.  If
you accidentally leave one of these three out, the parser at &lt;code&gt;:+&lt;/code&gt;
will steal whatever twig should come next.&lt;/p&gt;

&lt;p&gt;Generally at some point the parser will collide with reality and
reality will win.  At this position, you&amp;#39;ll see a syntax error.
But bad luck can move this point some distance from the mistake.&lt;/p&gt;

&lt;p&gt;This is never a serious problem once you get used to Hoon, but it
can be a pain in the butt while you&amp;#39;re learning.  To attack any
mysterious syntax error (in any language, not just Hoon), work by
binary search reduction - pull out giant chunks of code to see if
the error is there, or elsewhere.&lt;/p&gt;

&lt;h3&gt;Type failure&lt;/h3&gt;

&lt;p&gt;Okay, you parsed.  But you&amp;#39;re still failing.  Plenty of fail.&lt;/p&gt;

&lt;p&gt;By far the most common semantic failure from the Hoon compiler is
the cryptic &lt;code&gt;type-fail&lt;/code&gt;.  What failed exactly?  We have a lot
more information, but we&amp;#39;d rather not give it to you up front.&lt;/p&gt;

&lt;p&gt;The second most common error is &lt;code&gt;missing limb&lt;/code&gt;.  Here we actually
tell you the name of the limb.  But look, if you write &lt;code&gt;b.a&lt;/code&gt;,
you&amp;#39;d better have a &lt;code&gt;b&lt;/code&gt; in your &lt;code&gt;a&lt;/code&gt;.  You probably have the wrong
idea of what type an &lt;code&gt;a&lt;/code&gt; is.  So it comes back to type again.&lt;/p&gt;

&lt;p&gt;Essentially all Hoon compiler errors are in a sense type failure.
Generally, the compiler wants to shield you from the direct
details, because most ways of presenting the direct details
automatically would, at least in certain cases, just belch all
over the screen.&lt;/p&gt;

&lt;p&gt;Instead, the most important information about any Hoon error is
the &lt;em&gt;location stack&lt;/em&gt;.  Where did this happen?  The general
process of troubleshooting disregards the error details
completely, and starts from the &lt;em&gt;place&lt;/em&gt; your program failed.&lt;/p&gt;

&lt;p&gt;Unlike the parser location, the type location trace is &lt;em&gt;always&lt;/em&gt;
correct.  But you still have to know how to interpret it.  And
first, you need to know how to &lt;em&gt;generate&lt;/em&gt; it. &lt;/p&gt;

&lt;h3&gt;Generate your trace&lt;/h3&gt;

&lt;p&gt;Every twig within a &lt;code&gt;!:&lt;/code&gt; generates trace information, both at
compile time and runtime.  Normally you will see &lt;code&gt;!:&lt;/code&gt; at the
start of a file, and when writing simple programs it is a good
habit just to put it in at the start.&lt;/p&gt;

&lt;p&gt;Why wouldn&amp;#39;t you always use &lt;code&gt;!:&lt;/code&gt;?  Because runtime tracing isn&amp;#39;t
free, and especially because it kills tail-call optimization.
Also, because sometimes code just works.  For all these reasons,
there is no &lt;code&gt;!:&lt;/code&gt; on &lt;code&gt;hoon.hoon&lt;/code&gt; or &lt;code&gt;zuse.hoon&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To experiment with tracing, copy &lt;code&gt;try/bin/goodbye.hoon&lt;/code&gt; into
&lt;code&gt;try/bin/error.hoon&lt;/code&gt;.`:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;  + /~waclux-tomwyc/try/4/bin/error/hoon
  ~waclux-tomwyc/try=&amp;gt; :error &amp;quot;world&amp;quot;
  &amp;quot;hasta la vista, world.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The simplest kind of error is on the command line itself:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;  ~waclux-tomwyc/try=&amp;gt; :error
  ! type-fail
  ! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But this only happens if the file actually compiles.  Let&amp;#39;s make
it not compile, by changing it from&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  *
|=  [planet=tape ~]
^-  bowl
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hasta la vista, {planet}.&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  *
|=  [planet=tape ~]
=+  foo=(add 2)
^-  bowl
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hasta la vista, {planet}.&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#39;ve introduced a subtle semantic error into our Folger&amp;#39;s
coffee.  How might the discerning compiler respond?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :error &amp;quot;world&amp;quot;
! type-fail
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It&amp;#39;s mischieviously identical to the argument error.  But if we
add &lt;code&gt;!:&lt;/code&gt; to the start of the file, we get:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [planet=tape ~]
=+  foo=(add 2)
^-  bowl
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hasta la vista, {planet}.&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and running it:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;! /~waclux-tomwyc/try/~2014.2.9..22.36.30..2052/bin/error:&amp;lt;[2 1].[7 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.9..22.36.30..2052/bin/error:&amp;lt;[3 1].[7 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.9..22.36.30..2052/bin/error:&amp;lt;[4 1].[7 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.9..22.36.30..2052/bin/error:&amp;lt;[5 1].[7 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.9..22.36.30..2052/bin/error:&amp;lt;[5 5].[5 16]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.9..22.36.30..2052/bin/error:&amp;lt;[5 9].[5 16]&amp;gt;
! type-fail
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that the problem is on line 5 between columns 9 and 16.
Ie, &lt;code&gt;(add 2)&lt;/code&gt;.  Well, duh.&lt;/p&gt;

&lt;p&gt;But suppose we can&amp;#39;t see what&amp;#39;s wrong with &lt;code&gt;(add 2)&lt;/code&gt;.  Then, it&amp;#39;s
time for us to print some types, which we do with &lt;code&gt;~!&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [planet=tape ~]
^-  bowl
~!  2
~!  +&amp;lt;:add
=+  foo=(add 2)
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hasta la vista, {planet}.&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/10/bin/error/hoon
~waclux-tomwyc/try=&amp;gt; :error &amp;quot;world&amp;quot;
! /~waclux-tomwyc/try/~2014.2.9..22.41.38..5b4d/bin/error:&amp;lt;[2 1].[9 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.9..22.41.38..5b4d/bin/error:&amp;lt;[3 1].[9 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.9..22.41.38..5b4d/bin/error:&amp;lt;[4 1].[9 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.9..22.41.38..5b4d/bin/error:&amp;lt;[5 1].[9 37]&amp;gt;
! @ud
! /~waclux-tomwyc/try/~2014.2.9..22.41.38..5b4d/bin/error:&amp;lt;[6 1].[9 37]&amp;gt;
! [a=@ b=@]
! /~waclux-tomwyc/try/~2014.2.9..22.41.38..5b4d/bin/error:&amp;lt;[7 1].[9 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.9..22.41.38..5b4d/bin/error:&amp;lt;[7 5].[7 16]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.9..22.41.38..5b4d/bin/error:&amp;lt;[7 9].[7 16]&amp;gt;
! type-fail
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In other words: our sample, &lt;code&gt;2&lt;/code&gt;, is a &lt;code&gt;@ud&lt;/code&gt;; and the default
sample of &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;+&amp;lt;:add&lt;/code&gt;, is a &lt;code&gt;[a=@ b=@]&lt;/code&gt;.  So we&amp;#39;d expect some
problems here.&lt;/p&gt;

&lt;p&gt;Hoon believes strongly in modifying the program itself, not some
external metadata, to debug it.  While a &lt;code&gt;~!&lt;/code&gt; has no runtime cost
and negligible compile-time cost, take it out when you&amp;#39;re done.&lt;/p&gt;

&lt;h3&gt;Printf, %sgpm&lt;/h3&gt;

&lt;p&gt;It&amp;#39;s well known that real programmers don&amp;#39;t use debuggers.  Real
programmers use printf.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~&amp;amp;&lt;/code&gt;, informally &amp;quot;printf,&amp;quot; is a true printf that sends its
operand, printed by its type (a bit of biblical magic), directly
and magically to the console whenever it executes.  It&amp;#39;s okay to
have side effects if they are write-only.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s try a &lt;code&gt;~&amp;amp;&lt;/code&gt; in a working program:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [planet=tape ~]
^-  bowl
~&amp;amp;  [%planet planet]
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hasta la vista, {planet}.&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It&amp;#39;s as easy as this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/11/bin/error/hoon
~waclux-tomwyc/try=&amp;gt; :error &amp;quot;world&amp;quot;
[%planet &amp;quot;world&amp;quot;]
&amp;quot;hasta la vista, world.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Please note the very important difference between these outputs.
Both result in a line of text on the console - but &lt;code&gt;&amp;quot;hasta la
vista, world.&amp;quot;&lt;/code&gt; is the legitimate product of the application
bowl, whereas &lt;code&gt;[%planet &amp;quot;world&amp;quot;]&lt;/code&gt; went into the interpreter as a
hint and came out as a Unix printf.&lt;/p&gt;

&lt;h3&gt;Trace&lt;/h3&gt;

&lt;p&gt;We also can crash, and get a reasonably useful and accurate trace.
With a very misconceived assert:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [planet=tape ~]
^-  bowl
~&amp;amp;  [%planet planet]
?&amp;gt;  =(5 (add 2 2))
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hasta la vista, {planet}.&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we get:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/12/bin/error/hoon
~waclux-tomwyc/try=&amp;gt; :error &amp;quot;world&amp;quot;
[%planet &amp;quot;world&amp;quot;]
! /~waclux-tomwyc/try/~2014.2.10..00.18.08..16ea/bin/error/:&amp;lt;[4 1].[8 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.10..00.18.08..16ea/bin/error/:&amp;lt;[5 1].[8 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.10..00.18.08..16ea/bin/error/:&amp;lt;[6 1].[8 37]&amp;gt;
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the printf is delivered as soon as it executes.  Note
also that we accurately report the location of the failing twig.
And note finally that without &lt;code&gt;!:&lt;/code&gt;, we get none of this info.&lt;/p&gt;

&lt;h3&gt;Stackf, %sgbr&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;~|&lt;/code&gt; has the same form as &lt;code&gt;~&amp;amp;&lt;/code&gt;, but it computes at all only if
there is actually a runtime crash within the body of the &lt;code&gt;~|&lt;/code&gt;.
In that case, it prints its data as part of the stack trace.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s important to note that &lt;code&gt;~|&lt;/code&gt; does no work except at crash
time - its hint is not a tank, but a trap producing a tank.
Let&amp;#39;s try it:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/12/bin/error/hoon
~waclux-tomwyc/try=&amp;gt; :error &amp;quot;world&amp;quot;
[%planet &amp;quot;world&amp;quot;]
! /~waclux-tomwyc/try/~2014.2.10..00.34.28..8f89/bin/error/:&amp;lt;[4 1].[9 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.10..00.34.28..8f89/bin/error/:&amp;lt;[5 1].[9 37]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.10..00.34.28..8f89/bin/error/:&amp;lt;[6 1].[9 37]&amp;gt;
! [%asteroid &amp;quot;world&amp;quot;]
! /~waclux-tomwyc/try/~2014.2.10..00.34.28..8f89/bin/error/:&amp;lt;[7 1].[9 37]&amp;gt;
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And if there&amp;#39;s no crash, &lt;code&gt;~|&lt;/code&gt; doesn&amp;#39;t run:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [planet=tape ~]
^-  bowl
~|  [%asteroid planet]
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hasta la vista, {planet}.&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;just gives us:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/15/bin/error/hoon
~waclux-tomwyc/try=&amp;gt; :error &amp;quot;world&amp;quot;
&amp;quot;hasta la vista, world.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Probably someone invented this before, but I haven&amp;#39;t seen it.&lt;/p&gt;

&lt;p&gt;Finally, if you want to do &lt;code&gt;~|&lt;/code&gt; but your problem is important
enough that you have to write your own custom tank trap, &lt;code&gt;~_&lt;/code&gt;
is the rune for you.&lt;/p&gt;

&lt;h2&gt;The urban bull&lt;/h2&gt;

&lt;p&gt;There is actually another &lt;code&gt;%type&lt;/code&gt; stem we forgot to mention.
Finally, the full and final &lt;code&gt;%type&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  type  $|  ?(%noun %void)
          $%  [%atom p=term]
              [%bull p=twin q=type]
              [%cell p=type q=type]
              [%core p=type q=coil]
              [%cube p=* q=type]
              [%face p=term q=type]
              [%fork p=type q=type]
              [%hold p=(list ,[p=type q=twig])]
          ==
++  twin  ,[p=term q=wing r=axis s=type]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What is this &lt;code&gt;%bull&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%bull&lt;/code&gt; is a feature of &amp;quot;middle Hoon&amp;quot; (164K), created by the new
hoon &lt;code&gt;=*&lt;/code&gt;.  Most of Urbit is written in the older &amp;quot;classic Hoon&amp;quot; 
(191K), and does not use &lt;code&gt;=*&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A common complaint in classic Hoon is that we have to use long,
opaque paths, like &lt;code&gt;p.i.t.p.q.u.q&lt;/code&gt;, when pulling deep wings from
a large, complex subject.  Of course, we could use &lt;code&gt;=+&lt;/code&gt; to push a
copy.  But that would be inelegant.&lt;/p&gt;

&lt;p&gt;After studying this problem, our engineers invented %bull, the
alias.  Let&amp;#39;s copy &lt;code&gt;goodbye.hoon&lt;/code&gt; into &lt;code&gt;bull.hoon&lt;/code&gt;, and add a
&lt;code&gt;=*&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [planet=tape ~]
^-  bowl
=*  mars  planet
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hasta la vista, {mars}.&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;=*&lt;/code&gt; just makes a synonym.  We can use this synonym anywhere we
used the original wing, and the compiler will produce the same
code as if we used the original wing:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :bull &amp;quot;world&amp;quot;
&amp;quot;hasta la vista, world.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s make this slightly fancier:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [planet=tape ~]
^-  bowl
?&amp;gt;  ?=(^ planet)
=*  mars  t.planet
:_  ~  :_  ~
[%$ !&amp;gt;(&amp;quot;hasta la vista, {mars}.&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What would you expect to see here?  Do you know already?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :bull &amp;quot;world&amp;quot;
&amp;quot;hasta la vista, orld.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and, of course:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :bull &amp;quot;&amp;quot;
! /~waclux-tomwyc/try/~2014.2.11..18.29.54..4a1a/bin/bull/:&amp;lt;[4 1].[8 35]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.11..18.29.54..4a1a/bin/bull/:&amp;lt;[5 1].[8 35]&amp;gt;
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;&amp;lt;[5 1].[8 35]&amp;gt;&lt;/code&gt; is exactly the span of line and column
that contains the assertion twig &lt;code&gt;?&amp;gt;&lt;/code&gt;.  Don&amp;#39;t be frightened by
broad error ranges - they are normal, as are big twigs.&lt;/p&gt;

&lt;p&gt;And finally, there is no difficulty in both reading and writing
through &lt;code&gt;%bull&lt;/code&gt;.  For example, purely to amuse ourselves, we can
bullify decrement:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [a=@ ~]
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
=+  b=0
=*  c  b
|-  ^-  @
?:  =(a +(c))
  c
$(c +(b))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Too much information&lt;/h2&gt;

&lt;p&gt;It would be vain to deny that Hoon is not a perfect language.
Especially at this early stage, it has its quirks and rough
spots, and some oddities will probably always remain.  Every
language has some.&lt;/p&gt;

&lt;p&gt;One of the worst is the infamous TMI.  What is TMI?  Let&amp;#39;s make
&lt;code&gt;tmi.hoon&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  *
|=  nos=(list ,@)
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
(snag 2 nos)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s see what this does:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :tmi 56 71 12 19
12
~waclux-tomwyc/try=&amp;gt; :tmi 56 71 12 19 22
12
~waclux-tomwyc/try=&amp;gt; :tmi 56 71
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Tracing is not needed to figure out why.  But suppose, for no
good reason at all, we get some TMI:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  *
|=  nos=(list ,@)
?&amp;gt;  ?=(^ nos)
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
(snag 2 nos)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we have problem:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :tmi 56 71 12 19 22
! type-fail
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Why this happen?  Let&amp;#39;s look at ++snag:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  snag
  ~/  %snag
  |*  [a=@ b=(list)]
  |-
  ?~  b
    ~|(&amp;#39;snag-fail&amp;#39; !!)
  ?:  =(0 a)
    i.b
  $(b t.b, a (dec a))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Obviously, &lt;code&gt;++snag&lt;/code&gt; produces entry &lt;code&gt;a&lt;/code&gt; of list &lt;code&gt;b&lt;/code&gt;.  Less than
obviously, &lt;code&gt;++snag&lt;/code&gt; &lt;em&gt;only works for homogeneous lists&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;You might think &lt;code&gt;b&lt;/code&gt;, being (in this instance) a &lt;code&gt;(list ,@)&lt;/code&gt;, is a
homogeneous list.   But actually, we got &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;nos&lt;/code&gt;, and we
refined &lt;code&gt;nos&lt;/code&gt; with &lt;code&gt;?=&lt;/code&gt;.  It&amp;#39;s now not a mere &lt;code&gt;(list ,@)&lt;/code&gt;.  It&amp;#39;s
actually a &lt;code&gt;[i=@ t=(list ,@)]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So when we recurse in &lt;code&gt;++snag&lt;/code&gt;, we are pulling &lt;code&gt;$&lt;/code&gt; from the trap
produced by &lt;code&gt;|-&lt;/code&gt;; and when we mutate this core with &lt;code&gt;b=t.b&lt;/code&gt;, we
are replacing &lt;code&gt;[i=@ t=(list ,@)]&lt;/code&gt; (ie, a list we know is
non-empty) with a mere &lt;code&gt;(list ,@)&lt;/code&gt; (which could be empty).  So,
the compiler gets mad and has every right to.&lt;/p&gt;

&lt;p&gt;Of course, you could say: the compiler should be smarter.  No, it
shouldn&amp;#39;t be smarter.  The right way of understanding a
compiler&amp;#39;s semantics is to understand what it does.  If Hoon were
smart enough to figure out that breaking a local rule here was,
in some sense, globally ok, it would need a kind of mammalian
global forebrain sitting on top of its reptilian walnut brain.
Then you, the programmer, would need to grok this global
forebrain as well.  And for what?  So you don&amp;#39;t have to cast?&lt;/p&gt;

&lt;h3&gt;Mitigating TMI&lt;/h3&gt;

&lt;p&gt;Fortunately, there are an endless number of ways to hack around
TMI - in this case, both on the caller and callee side.  &lt;/p&gt;

&lt;p&gt;In &lt;code&gt;++snag&lt;/code&gt;, if we instead recurse with &lt;code&gt;(snag (dec a) t.b)&lt;/code&gt; in
classic 20th-century style (normally a real solecism in Hoon),
&lt;code&gt;++snag&lt;/code&gt; does not have a problem with &lt;code&gt;nos&lt;/code&gt;.  (This hack will
probably be committed at some point, but &lt;code&gt;++snag&lt;/code&gt; is such a good
example.)&lt;/p&gt;

&lt;p&gt;You probably don&amp;#39;t have commit rights on &lt;code&gt;hoon.hoon&lt;/code&gt;, so you have
to do your hacking on the caller side.&lt;/p&gt;

&lt;p&gt;One thing you can do is:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  *
|=  nos=(list ,@)
?&amp;gt;  ?=(^ nos)
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
(snag 2 `(list ,@)`nos)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This fix has zero cost in runtime and if anything makes your code
compile faster.  On the other hand, it is slightly ugly and it
needs to be done every time you use the value.  You can also cast
it back in place:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  *
|=  nos=(list ,@)
?&amp;gt;  ?=(^ nos)
=&amp;gt;  .(nos `(list ,@)`nos)
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
(snag 2 nos)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Even a very weak optimizer will optimize this to zero-cost.  It
is even uglier, however.&lt;/p&gt;

&lt;p&gt;You can also cleverly avoid refining the subject at all.  For
instance:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  *
|=  nos=(list ,@)
?&amp;gt;  !=(~ nos)
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
(snag 2 nos)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Equality testing does not produce type information.  This is a
feature, not a bug.  If you want to refine the subject, you
really do have to use &lt;code&gt;?=&lt;/code&gt; or some synthetic hoon that resolves
to it.&lt;/p&gt;

&lt;h3&gt;TMI and other bulls&lt;/h3&gt;

&lt;p&gt;Middle Hoon, however, added bulls not just because long terse
wings are ugly, but also because they help with TMI.&lt;/p&gt;

&lt;p&gt;When we &lt;code&gt;?=&lt;/code&gt; through a bull, the type refinement sticks to the
bull.  That is, we can write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  *
|=  nos=(list ,@)
=*  cud  nos
?&amp;gt;  ?=(^ cud)
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
(snag 2 nos)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and it works just fine, because &lt;code&gt;nos&lt;/code&gt; remains &lt;code&gt;(list ,@)&lt;/code&gt;.
However, we are back to &lt;code&gt;type-fail&lt;/code&gt; with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  *
|=  nos=(list ,@)
=*  cud  nos
?&amp;gt;  ?=(^ cud)
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
(snag 2 cud)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In many complex computations, because the type system isn&amp;#39;t
perfect, we often want access to both original and refined types.
By interrogating a &lt;code&gt;%bull&lt;/code&gt;, we get exactly that.  It&amp;#39;s
straightforward to make the alias carry the refined type, and the
underlying wing the original type - another subtle design touch
that chimes smoothly with Hoon&amp;#39;s rich Corinthian leather.&lt;/p&gt;

&lt;h2&gt;Another convenient convenience&lt;/h2&gt;

&lt;p&gt;Another common complaint about classic Hoon is that you very
often want to fish in something that isn&amp;#39;t a wing.  For instance,
put this in as &lt;code&gt;try/bin/fish.hoon&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [x=@ ~]
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
=+  foo=(mod x 2)
?+  foo  !!
  0  &amp;quot;even&amp;quot;
  1  &amp;quot;odd&amp;quot;
==

~waclux-tomwyc/try=&amp;gt; :fish 3
&amp;quot;odd&amp;quot;
~waclux-tomwyc/try=&amp;gt; :fish 4
&amp;quot;even&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We need the &lt;code&gt;?+&lt;/code&gt; and &lt;code&gt;!!&lt;/code&gt; because the type system, not being
infinitely smart or anywhere close, cannot show that &lt;code&gt;foo&lt;/code&gt; is
limited to &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.  Try it with &lt;code&gt;?-&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [x=@ ~]
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
=+  foo=(mod x 2)
?-  foo
  0  &amp;quot;even&amp;quot;
  1  &amp;quot;odd&amp;quot;
==

! /~waclux-tomwyc/try/~2014.2.12..00.06.42..8e4a/bin/fish:&amp;lt;[2 1].[9 3]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.12..00.06.42..8e4a/bin/fish:&amp;lt;[3 1].[9 3]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.12..00.06.42..8e4a/bin/fish:&amp;lt;[4 1].[9 3]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.12..00.06.42..8e4a/bin/fish:&amp;lt;[4 11].[9 3]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.12..00.06.42..8e4a/bin/fish:&amp;lt;[4 18].[9 3]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.12..00.06.42..8e4a/bin/fish:&amp;lt;[4 25].[9 3]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.12..00.06.42..8e4a/bin/fish:&amp;lt;[4 33].[9 3]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.12..00.06.42..8e4a/bin/fish:&amp;lt;[5 1].[9 3]&amp;gt;
! /~waclux-tomwyc/try/~2014.2.12..00.06.42..8e4a/bin/fish:&amp;lt;[6 1].[9 3]&amp;gt;
! -lost.@
! mint-lost
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The compiler is telling us that the rest of &lt;code&gt;@&lt;/code&gt; is unhandled in
our &lt;code&gt;?-&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But what we can&amp;#39;t do is what we&amp;#39;d actually like to do:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [x=@ ~]
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
?+  (mod x 2)  !!
  0  &amp;quot;even&amp;quot;
  1  &amp;quot;odd&amp;quot;
==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We know that we can&amp;#39;t do this, becase we see the type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  twig  $%  [%wtls p=wing q=twig r=tine]
          ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and, obviously, &lt;code&gt;(mod x 2)&lt;/code&gt; is a &lt;code&gt;twig&lt;/code&gt;, not a &lt;code&gt;wing&lt;/code&gt;.  But let&amp;#39;s
try it anyway:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [x=@ ~]
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
?+  (mod x 2)  !!
  0  &amp;quot;even&amp;quot;
  1  &amp;quot;odd&amp;quot;
==

~zod/try=&amp;gt; :fish 4
&amp;quot;even&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WTF?  It works?&lt;/p&gt;

&lt;p&gt;It turns out that when we parse &lt;code&gt;?+&lt;/code&gt; - and &lt;code&gt;?-&lt;/code&gt;, &lt;code&gt;?@&lt;/code&gt;, &lt;code&gt;?^&lt;/code&gt;
and &lt;code&gt;?~&lt;/code&gt; - we produce not an ordinary twig matching the hoon, but
a bizarre precursor:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  twig  $%  [%wthp p=wing q=tine]
              [%wthz p=tiki q=tine]
              [%wtkt p=wing q=twig r=twig]
              [%wtkz p=tiki q=twig r=twig]
              [%wtls p=wing q=twig r=tine]
              [%wtlz p=tiki q=twig r=tine]
              [%wtpt p=wing q=twig r=twig]
              [%wtpz p=tiki q=twig r=twig]
              [%wtsg p=wing q=twig r=twig]
              [%wtsz p=tiki q=twig r=twig]
          ==
++  tiki  $%  [&amp;amp; p=(unit term) q=wing]
              [| p=(unit term) q=twig]
          ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the uncommon power of &lt;code&gt;++tiki&lt;/code&gt;, our parser figures out if
you&amp;#39;re using these pattern tests to fish for (a) a nameless wing,&lt;br&gt;
(b) a named wing, (c) a nameless twig, (d) a named twig.  &lt;/p&gt;

&lt;p&gt;For (a), &lt;code&gt;wtlz&lt;/code&gt; is equivalent to &lt;code&gt;wtls&lt;/code&gt;.  For (b), we automagically
insert a &lt;code&gt;=*&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [x=@ ~]
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
=+  moo=(mod x 2)
?+  foo=moo  !!
  0  [&amp;quot;even&amp;quot; foo]
  1  [&amp;quot;odd&amp;quot; foo]
==

~zod/try=&amp;gt; :fish 4 
[&amp;quot;even&amp;quot; %0]
~zod/try=&amp;gt; :fish 5
[&amp;quot;odd&amp;quot; %1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(c) we&amp;#39;ve seen already; and (d) inserts a &lt;code&gt;=+&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:
|=  *
|=  [x=@ ~]
^-  bowl  :_  ~  :_  ~  :-  %$  !&amp;gt;
?+  foo=(mod x 2)  !!
  0  [&amp;quot;even&amp;quot; foo]
  1  [&amp;quot;odd&amp;quot; foo]
==

~zod/try=&amp;gt; :fish 5
[&amp;quot;odd&amp;quot; %1]
~zod/try=&amp;gt; :fish 4
[&amp;quot;even&amp;quot; %0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To call this feature essential would be going too far.  But it&amp;#39;s
often quite convenient.&lt;/p&gt;

&lt;h2&gt;Vulcanization&lt;/h2&gt;

&lt;p&gt;As you&amp;#39;re probably aware by now, generic polymorphism is funky.
It spares us from having a whole monstrous abstraction layer in
typeclasses.  That&amp;#39;s cool.  But still, it&amp;#39;s funky.&lt;/p&gt;

&lt;p&gt;One of the funky questions that&amp;#39;s perhaps occurred to you is: how
do argument names work in a wet (generic) gate?&lt;/p&gt;

&lt;p&gt;Consider a normal dry gate, like &lt;code&gt;|=([a=* b=*] [b a])&lt;/code&gt;.  When
you slam this gate, &lt;code&gt;%.([%foo %bar] |=([a=* b=*] [b a]))&lt;/code&gt;, you
know what the compiler does - it replaces &lt;code&gt;[a=* b=*]&lt;/code&gt; with 
&lt;code&gt;[%foo %bar]&lt;/code&gt;, checks that &lt;code&gt;[%foo %bar]&lt;/code&gt; nests inside &lt;code&gt;[a=*
b=*]&lt;/code&gt;, and executes the formula compiled against &lt;code&gt;[a=* b=*]&lt;/code&gt;.
Losing all your type information:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~zod/try=&amp;gt; %.([%foo %bar] |=([a=* b=*] [b a]))
[7.496.034 7.303.014]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But with &lt;code&gt;|*([a=* b=*] [b a])&lt;/code&gt;, we get:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~zod/try=&amp;gt; %.([%foo %bar] |*([a=* b=*] [b a]))
[%bar %foo]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The types persist.  Okay, we know that.  We also know that, to
put it crudely, &lt;code&gt;|*&lt;/code&gt; works by recompiling the twig with the
default sample replaced by the caller&amp;#39;s sample, then checking
that this produces the same code as originally compiled.&lt;/p&gt;

&lt;p&gt;But - this leaves us compiling&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|*([%foo %bar] [b a])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;How do the limbs &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; get pulled?  The default sample had
these names, but the caller&amp;#39;s sample doesn&amp;#39;t.  &lt;/p&gt;

&lt;p&gt;The answer is simple - &lt;code&gt;|*&lt;/code&gt; doesn&amp;#39;t work the way you think it
does.  &lt;code&gt;|*&lt;/code&gt; is synthetic, of course; and you might think it
resolved to&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  [a=* b=*]
|%
+-  %$
  [b a]
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;just as &lt;code&gt;|=([a=* b=*] [b a])&lt;/code&gt; is &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  [a=* b=*]
|%
++  %$
  [b a]
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But no!  If you try the top twig as a replacement for &lt;code&gt;|*&lt;/code&gt;,
you&amp;#39;ll find it doesn&amp;#39;t work at all, unless you slam it not with
&lt;code&gt;[%foo %bar]&lt;/code&gt;, but rather with &lt;code&gt;[a=%foo b=%bar]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The solution is vulcanization.  &lt;code&gt;|*&lt;/code&gt; becomes &lt;code&gt;|\&lt;/code&gt;, which gets a
funky little thing done to it:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  open
  ^-  twig
  ?-    gen
      [%brfs *]  =+  lyg=~(cloq al p.gen)
                 :+  %brcb  q.lyg
                 %-  ~(run by q.gen)
                 |=  a=foot  ^-  foot
                 ?.  ?=(%elm -.a)  a
                 :-  -.a
                 :+  %tsgl  p.a
                 :+  %cnts  ~
                 :~  [[[%&amp;amp; 6] ~] [%ktts p.lyg [~ 6]]]
                 ==
  == 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Huh?  The long and the short of it is that, thanks to this little
piece of wizardry, &lt;code&gt;|*&lt;/code&gt; in our example instead generates:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  [* *]
|%
+-  %$
  =&amp;gt;  .(+&amp;lt; [a b]=+&amp;lt;)
  [b a]
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ie, we pull the names out of the default sample and reimpose them
in the actual arm.  This is vulcanization.  If you don&amp;#39;t like it,
don&amp;#39;t use &lt;code&gt;|*&lt;/code&gt; or &lt;code&gt;|\&lt;/code&gt;, and feel free to roll your own!&lt;/p&gt;

&lt;h2&gt;Naming conventions&lt;/h2&gt;

&lt;p&gt;There are three tasks in translating an algorithm into Hoon.&lt;/p&gt;

&lt;p&gt;First, catch your algorithm.  &lt;/p&gt;

&lt;p&gt;Second, arrange it as a Hoon twig, in a way that looks good on
the page.  Hoon arrangement, because it requires adjusting both
the runes and the formatting, becomes a sort of minor art form in
a pleasant way, perhaps at the level of knitting.  Perhaps an
editor could be taught to do it, but not necessarily do it well.
And do we really need more robots taking jobs from programmers?&lt;/p&gt;

&lt;p&gt;Third, decide what to name things.  We actually have three styles
of naming, corresponding to durability of code.&lt;/p&gt;

&lt;p&gt;Hoon&amp;#39;s theory is that durability of code should correspond to
austerity of naming.  The more austere and impersonal its names,
the more like a specification your twig looks.  It seems written
in stone - and indeed it is in another sense.  The more austere
your names are, the harder it is to change them.  As you know, if
you&amp;#39;ve ever tried to change a one-letter variable name.&lt;/p&gt;

&lt;p&gt;The ideal of austere code is that anyone who tried to rewrite it,
in the same austere style, would produce exactly the same bytes.
There is nothing in the code but what it does.  But an austere
style, applied to code not itself austere, is a disaster.&lt;/p&gt;

&lt;p&gt;There are three naming conventions: &lt;em&gt;hyperlapidary&lt;/em&gt;, &lt;em&gt;lapidary&lt;/em&gt;, and
&lt;em&gt;freehand&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In hyperlapidary naming (H-Hoon), variables and arguments are
named alphabetically with one letter, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; etc, in
strict order of appearance in the text.  This scheme is only
useful in the case of extremely regular and straightforward
namespaces: very short functions, for instance.&lt;/p&gt;

&lt;p&gt;Hyperlapidary arms must be gates or trays.  Gate arms are three
letters and try to carry some mnemonic significance - for
instance, &lt;code&gt;++dec&lt;/code&gt;.  Tray arms are two letters and try to resemble
pronouns - for instance, &lt;code&gt;++by&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;Hyperlapidary structures must be short tuples, no wider than 5.
The legs are named &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; and/or &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Conventional recursive structures use other standard names.  The
head of a list is always &lt;code&gt;i&lt;/code&gt;, the tail is always &lt;code&gt;t&lt;/code&gt;.  In a
binary tree of nodes, the node is &lt;code&gt;n&lt;/code&gt;, the children &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When in doubt, do not use H-mode.  In an ordinary context - not
least because hyperlapidary gates are easily mistaken for
lapidary variables - there should be as few hyperlapidary arms as
possible.  And always remind yourself that H-mode makes it as
hard as possible to refactor your code.&lt;/p&gt;

&lt;p&gt;Lapidary mode (L-Hoon) is the ordinary style of most of Hoon and
Arvo.  In lapidary mode, variables, arguments, attributes, etc,
are three-letter strings, usually consonant-vowel-consonant,
generally meaningless.  If the same string is used more than once
in the same file, it should be used for the same concept in some
sense, as often happens spontaneously in cutting and pasting.  It
would be nice to have an editor with a macro that generated
random unique TLV strings automatically.&lt;/p&gt;

&lt;p&gt;Lapidary arms are always four letters.  They may or may not be
English words, which may or may not mean anything relevant.&lt;/p&gt;

&lt;p&gt;In freehand mode (F-Hoon), do whatever the heck you want.  Note
that while uppercase is not permitted in a symbol, &lt;code&gt;-&lt;/code&gt; is,
suggesting a generally Lisp-like state of gross hyphenated
disorder.  F-mode is best used for top-layer software which
nothing else is based on; prototyping and casual coding; etc.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/doc/2013/11/19/ch10&quot;&gt;* &lt;em&gt;Prev&lt;/em&gt;*: Type Inference&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Chapter X (Type Inference)</title>
   <link href="http://urbit.org/doc/2013/11/19/ch10/"/>
   <updated>2013-11-19T00:00:00-08:00</updated>
   <id>http://urbit.org/doc/2013/11/19/ch10</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch9&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Tiles&lt;/a&gt; &lt;a href=&quot;/doc/2013/11/19/ch11&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Odds, Ends&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ever, as before, does Madness remain a mysterious-terrific, altogether infernal boiling-up of the Nether Chaotic Deep, through this fair-painted Vision of Creation, which swims thereon, which we name the Real.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(Carlyle)&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;On type inference algorithms&lt;/h2&gt;

&lt;p&gt;Hoon is a higher-order typed functional language.  Most languages
in this class, Haskell and ML being prominent examples, use
something called the Hindley-Milner unification algorithm.  Hoon
uses its own special sauce instead.&lt;/p&gt;

&lt;p&gt;Why?  There are two obvious problems with H-M as a functional
type system, the main one being the wall of heavy-ass mathematics
that greets you instantly when you google it.  We have heard some
claims that H-M is actually quite simple.  We urge all such
claimants to hie themselves to its Wikipedia page, which they&amp;#39;ll
surely be able to relieve of its present alarming resemblance to
some string-theory paper in Physics Review D.&lt;/p&gt;

&lt;p&gt;(Nor is this in any way an an anti-academic stance.  Quite the
contrary.  Frankly, OS guys really quite seldom find themselves
in the math-department lounge, cadging stray grants by
shamelessly misrepresenting the CAP theorem as a result in
mathematics.  It doesn&amp;#39;t seem too much to expect the
mathematicians to reciprocate this basic academic courtesy - how
about it, old chaps?)&lt;/p&gt;

&lt;p&gt;Furthermore, besides the drawback that it reeks of math and
programmers who love math are about as common as cats who love a
bath - a problem, but really only a marketing problem - H-M has a
genuine product problem as well.  It&amp;#39;s too powerful.  &lt;/p&gt;

&lt;p&gt;Specifically, H-M reasons both forward with evaluation, and
backward from constraints.  Pretty unavoidable in any sort of
unification algorithm, obviously.  But since the compiler has to
think both forward and backward, and the programmer has to
predict what the compiler will do, the programmer has to think
backward as well.&lt;/p&gt;

&lt;p&gt;Hoon&amp;#39;s philosophy is that a language is a UI for programmers, and
the basic test of a UI is to be, ya know, easy.  It is impossible
(for most programmers) to learn a language properly unless they
know what the compiler is doing, which in practice means mentally
stepping through the algorithms it uses (with the exception of
semantically neutral optimizations).  Haskell is a hard language
to learn (for most programmers) because it&amp;#39;s hard (for most
programmers) to follow what the Haskell compiler is thinking.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s true that some programmers have an effective mathematical
intuition that let them &amp;quot;see&amp;quot; algorithms without working through
them step by step.  But this is a rare talent, we feel.  And
even those who have a talent don&amp;#39;t always enjoy exercising it.&lt;/p&gt;

&lt;p&gt;If a thorough understanding of any language demands high-grade
mathematical intuition in its programmers, the language as a UI
is like a doorway that makes you duck if you&amp;#39;re over 6 feet tall.
The only reason to build such a doorway in your castle is if you
and all your friends are short, and only your enemies are tall.
Is this really the case here?&lt;/p&gt;

&lt;p&gt;Although an inference algorithm that reasons only forward must
and does require a few more annotations from the programmer, the
small extra burden on her fingers is more than offset by the
lighter load on her hippocampus.  Furthermore, programs also
exist to be read.  The modern code monkey is above all things a
replaceable part, and some of these annotations (which a smarter
algorithm might infer by steam) may annoy the actual author of
the code but be a lifesaver for her replacement.&lt;/p&gt;

&lt;h2&gt;Low-powered type inference&lt;/h2&gt;

&lt;p&gt;Broadly speaking, type inference in Hoon has three general
limitations as compared to H-M inference.  &lt;/p&gt;

&lt;p&gt;&lt;em&gt;One&lt;/em&gt;, Hoon really does not think backwards. For instance, it
cannot infer a function&amp;#39;s argument type (or to use Hoonese, a
gate&amp;#39;s sample type) from its body.  &lt;/p&gt;

&lt;p&gt;&lt;em&gt;Two&lt;/em&gt;, Hoon can infer through tail recursion, but not head
recursion.  It can &lt;em&gt;check&lt;/em&gt; head recursion, however, given an
annotation.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Three&lt;/em&gt;, the compiler catches most but not all divergent
inference problems - ie, if you really screw up, you can put the
compiler into an infinite loop or exponential equivalent.  That&amp;#39;s
ok, because an interrupt will still show you your error location.
Also, this never happens once you know what you&amp;#39;re doing.&lt;/p&gt;

&lt;p&gt;Our experience is that these limitations are minor annoyances at
worst and prudent restrictions at best.  Your mileage may vary.&lt;/p&gt;

&lt;p&gt;A good basic test for the power of a type inference algorithm is
whether, given a grammar for a complex AST, it can verify
statically that the noun produced by an LL combinator parser for
the grammar actually fits in the AST type.  (It would be quite
surprising to see any language solve this for an LR parser.)&lt;/p&gt;

&lt;p&gt;Hoon indeed checks its own LL parser.  Moreover, the core of
the Hoon compiler - &lt;code&gt;++ut&lt;/code&gt;, which handles both type inference and 
Nock generation, is less than 2000 lines (and feels a bit bloated
at that, since for obvious reasons it is relatively old code).
Hoon is pretty expressive, but not &lt;code&gt;that&lt;/code&gt; expressive.  &lt;/p&gt;

&lt;p&gt;So we feel Hoon&amp;#39;s approach to type inference offers, beneath its
rich Corinthian leather, an unrivalled balance of simplicity and
power.  Still, don&amp;#39;t take it out on the freeway till you&amp;#39;re
pretty sure you know how to drive it.&lt;/p&gt;

&lt;h2&gt;Facts to keep in mind&lt;/h2&gt;

&lt;p&gt;Type inference is a frightening problem, especially if you&amp;#39;ve
been exposed to the wall of math.  Your only real problem in
learning Hoon is to learn not to fear it.  Once you work past
this reasonable but entirely unfounded fear of inference, your
Hoon experience will be simple, refreshing and delightful.  So
first, let&amp;#39;s talk through a few reassuring facts:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;One&lt;/em&gt;, it&amp;#39;s important to remember - having just read about tiles - 
that type inference in Hoon &lt;em&gt;never sees a tile&lt;/em&gt;.  It operates
exclusively on twigs.  All tiles and synthetic twigs are reduced
to natural twigs for the inference engine&amp;#39;s benefit.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Two&lt;/em&gt;, the semantics of Hoon are in &lt;code&gt;++ut&lt;/code&gt; in &lt;code&gt;hoon.hoon&lt;/code&gt;, and 
nowhere else.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Three&lt;/em&gt;, within &lt;code&gt;++ut&lt;/code&gt;, all the semantics of Hoon are in the call
graph of one arm - &lt;code&gt;++mint&lt;/code&gt;.  &lt;code&gt;++mint&lt;/code&gt; has a case for every
natural hoon.  So do &lt;code&gt;++play&lt;/code&gt; and &lt;code&gt;++mull&lt;/code&gt;, but their semantics
are redundant with &lt;code&gt;++mint&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Four&lt;/em&gt;, one leg in the sample of &lt;code&gt;++mint&lt;/code&gt; - &lt;code&gt;gol&lt;/code&gt; - which looks
for all the world like a mechanism for backward inference, is
not.  It is semantically irrelevant and only exists to get better
localization on error reports.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Five&lt;/em&gt;, we&amp;#39;ve already explained what &lt;code&gt;++mint&lt;/code&gt; does, but let&amp;#39;s
repeat it one more time:&lt;/p&gt;

&lt;p&gt;When we have a type that describes the subject for the formula
we&amp;#39;re trying to generate, as we generate that formula we want to
also generate a type for the product of that formula on that
subject.  So our compiler computes:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[subject-type twig] =&amp;gt; [product-type formula]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As long as &lt;code&gt;subject-type&lt;/code&gt; is a correct description of some
subject, you can take any twig and compile it against
&lt;code&gt;subject-type&lt;/code&gt;, producing a &lt;code&gt;formula&lt;/code&gt; such that &lt;code&gt;*(subject
formula)&lt;/code&gt; is a product correctly described by &lt;code&gt;product-type&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;++mint&lt;/code&gt; is the gate that maps &lt;code&gt;[type twig]&lt;/code&gt; to &lt;code&gt;[type nock]&lt;/code&gt;.
So, if you know &lt;code&gt;++mint&lt;/code&gt;, you know Hoon.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Six&lt;/em&gt;, most of the things &lt;code&gt;++mint&lt;/code&gt; does are obvious.  For
instance, let&amp;#39;s quickly run through how &lt;code&gt;++mint&lt;/code&gt; handles a
&lt;code&gt;=+&lt;/code&gt; (&lt;code&gt;tislus&lt;/code&gt;) twig, &lt;code&gt;[%tsls p=twig q=twig]&lt;/code&gt;.  This is a 
synthetic twig:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  open
  ^-  twig
  ?-  gen
    [%tsls *]  [%tsgr [p.gen [~ 1]] q.gen]
  ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ie, &lt;code&gt;=+(a b)&lt;/code&gt; is &lt;code&gt;=&amp;gt;([a .] b)&lt;/code&gt;.  We thus turn to the &lt;code&gt;%tsgr&lt;/code&gt;
twig in &lt;code&gt;++mint&lt;/code&gt;.  Simplifying broadly:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  mint
  |=  [sut=type gen=twig]
  ^-  [p=type q=nock]
  ?-    gen
      [%tsgr *]
    =+  fid=$(gen p.gen)
    =+  dov=$(sut p.fid, gen q.gen)
    [p.dov (comb q.fid q.dov)]
  ==
++  comb
  |=  [mal=nock buz=nock]
  ^-  nock
  ?:  &amp;amp;(?=([0 *] mal) !=(0 p.mal))
    ?:  &amp;amp;(?=([0 *] buz) !=(0 p.buz))
      [%0 (peg p.mal p.buz)]
    ?:  ?=([2 [0 *] [0 *]] buz)
      [%2 [%0 (peg p.mal p.p.buz)] [%0 (peg p.mal p.q.buz)]]
    [%7 mal buz]
  ?:  ?=([^ [0 1]] mal)
    [%8 p.mal buz]
  ?:  =([0 1] buz)
    mal
  [%7 mal buz]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It may not be obvious what &lt;code&gt;++comb&lt;/code&gt; is doing, but we can guess
that it&amp;#39;s composing two Nock formulas, and in particular doing
its best to get back the &lt;code&gt;%8&lt;/code&gt; shorthand that we might have
otherwise thrown away by making &lt;code&gt;=+&lt;/code&gt; a synthetic hoon.&lt;/p&gt;

&lt;p&gt;If you understand this, you understand the general problem that
&lt;code&gt;++mint&lt;/code&gt; is solving.  Now, let&amp;#39;s dive into the details.&lt;/p&gt;

&lt;h2&gt;Pseudolazy evaluation: %hold&lt;/h2&gt;

&lt;p&gt;We&amp;#39;ll start by introducing a new type stem, &lt;code&gt;%hold&lt;/code&gt; (yes, we are
bringing them in one by one like Gandalf&amp;#39;s dwarves):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  type  $|  ?(%noun %void)
          $%  [%atom p=term]
              [%cell p=type q=type]
              [%core p=type q=coil]
              [%cube p=* q=type]
              [%face p=term q=type]
              [%fork p=type q=type]
              [%hold p=(list ,[p=type q=twig])]
          ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(There is now only one type stem that&amp;#39;s missing - and a
relatively frivolous and unimportant stem at that.)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%hold&lt;/code&gt; looks a little bit funky there.  Let&amp;#39;s indulge in a
little more unlicensed simplifying, and pretend it was instead&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[%hold p=type q=twig]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(The actual &lt;code&gt;%hold&lt;/code&gt;, with its list, is just a big &lt;code&gt;%fork&lt;/code&gt;; and can
be adequately represented, at least semantically, by a nested
&lt;code&gt;%fork&lt;/code&gt; of simple holds like this one.  The reasons it doesn&amp;#39;t
work this way are unimportant and we can forget them for now.)&lt;/p&gt;

&lt;p&gt;What are the semantics of a &lt;code&gt;%hold&lt;/code&gt;?  Simple - this type
delegates to the value, also of course a type, &lt;code&gt;p:(mint p q)&lt;/code&gt;.
(Once again, in the real &lt;code&gt;hoon.hoon&lt;/code&gt;, the &lt;code&gt;++mint&lt;/code&gt; interface
is also slightly different from our caricature here.)&lt;/p&gt;

&lt;p&gt;Here we see how infinite types, such as a linked list, can be
constructed.  Hoon, of course, is a strict language (ie, one
without lazy evaluation, like Haskell) and cannot construct an
infinitely long linked list.  We certainly can describe, as a
&lt;code&gt;++type&lt;/code&gt;, the infinite set which contains all linked lists - or
all lists of a given item type, eg, &lt;code&gt;[p=type q=twig]&lt;/code&gt;.  But this
infinite set must be defined in a very finite noun.&lt;/p&gt;

&lt;p&gt;When we traverse this finite noun by expanding &lt;code&gt;%hold&lt;/code&gt; stems, we
implicitly produce the illusion of an infinite type - for
instance, one that in the case of a linked list of @tas, was&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ %fork
  [%cube 0 %atom %n]
  [ %cell
    [%atom %tas]
    [ %fork
      [%cube 0 %atom %n]
      [ %cell
        [%atom %tas]
        [ %fork
          [%cube 0 %atom %n]
          ... 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and it&amp;#39;s turtles all the way down.  (&lt;code&gt;[%cube 0 %atom %n]&lt;/code&gt; is of
course the null terminator, &lt;code&gt;~&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Infinite state is not required to produce this sequence ad
infinitum.  In any language, this is essentially what an infinite
list &lt;em&gt;is&lt;/em&gt; - an indefinite pattern generated from finite state..
But in Hoon, the illusion is produced at the user level, not
hidden in the language semantics.&lt;/p&gt;

&lt;p&gt;Perhaps it&amp;#39;s not clear why this is superior...&lt;/p&gt;

&lt;p&gt;Again, you want to define an infinite list.   But your physical
computer is finite.  So, your infinite list must consist of some
kind of generated pattern.  Lots of ways to do this.&lt;/p&gt;

&lt;p&gt;What is the right way to manage this finite state?  State of this
kind can be expressed in three forms: (a) the actual data
structure that the pattern contains; (b) a core, which takes this
payload and wraps a pattern generator around it; (c) an
abstraction, which makes the generator indistinguishable from
simple list data.&lt;/p&gt;

&lt;p&gt;It seems clear that since (a) can be converted into (b), and (b)
into (c), the best representation is (a).  For instance, (a) is
easy to send over a network, (b) is clunky at best (we really try
to never send nock over the network), (c) is a research project.
In short, lazy evaluation is inherently a leaky abstraction.&lt;/p&gt;

&lt;h2&gt;How we use %hold&lt;/h2&gt;

&lt;p&gt;There is one advantage of explicit over implicit laziness which
would leave us no choice but to use explicit laziness in &lt;code&gt;++ut&lt;/code&gt;, 
even if we expressed the same semantics in a language with
built-in implicit laziness (like Haskell).&lt;/p&gt;

&lt;p&gt;The advantage is that the explicit pattern state makes a good
search key for an associative array, ie, &lt;code&gt;++map&lt;/code&gt; in Hoon.  The
problem of using an infinite expansion as a search key in a lazy
language is one I&amp;#39;d be surprised to see solved, and even more
surprised to see solved well. &lt;/p&gt;

&lt;p&gt;Consider the function computed by &lt;code&gt;++nest&lt;/code&gt;.  Again simplifying
the interesting core structure of &lt;code&gt;++ut&lt;/code&gt;, &lt;code&gt;(nest sut ref)&lt;/code&gt; is yes
if &lt;em&gt;it can verify that&lt;/em&gt; every noun which is a member of type
&lt;code&gt;ref&lt;/code&gt; is also a member of type &lt;code&gt;sut&lt;/code&gt;.  In other words, &lt;code&gt;++nest&lt;/code&gt;
is a conservative algorithm - it sometimes busts the innocent,
it always nails the guilty.&lt;/p&gt;

&lt;p&gt;(&lt;code&gt;++nest&lt;/code&gt; and everything else in the Hoon type system practice a
policy of pure &amp;quot;structural equivalence.&amp;quot;  Even %face is ignored
for compatibility purposes; only noun geometry is considered.  If
it walks like a duck, etc.)&lt;/p&gt;

&lt;p&gt;(You can look at &lt;code&gt;++nest&lt;/code&gt; yourself.  It is a big function for
Hoon: 150 lines, though arranged quite loosely (it should be 
more like 120) with a complex internal core.)&lt;/p&gt;

&lt;p&gt;If you look again at &lt;code&gt;++type&lt;/code&gt; above and forget about &lt;code&gt;%hold&lt;/code&gt;, 
it is probably not hard to imagine building a &lt;code&gt;++nest&lt;/code&gt; for 
&lt;em&gt;finite&lt;/em&gt; type nouns.  (The problem is not even equivalent to SAT,
because there is a unification stem but no intersection stem.)&lt;/p&gt;

&lt;p&gt;But for (logically) infinite types?  Yes - actually, the problem
is straightforward.  But the solution requires us to use &lt;code&gt;%hold&lt;/code&gt;
types as search keys.&lt;/p&gt;

&lt;p&gt;Essentially, &lt;code&gt;++nest&lt;/code&gt; can begin by assuming that every &lt;code&gt;ref&lt;/code&gt; is a
&lt;code&gt;sut&lt;/code&gt;, then traverse the parallel trees searching for any case
of a &lt;code&gt;ref&lt;/code&gt; that might conceal a non-&lt;code&gt;sut&lt;/code&gt;.  In this traverse, we
can simply keep a set of the &lt;code&gt;[sut ref]&lt;/code&gt; problems we are solving:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  gil=*(set ,[p=type q=type])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again, &lt;code&gt;gil&lt;/code&gt; is just the &lt;code&gt;++nest&lt;/code&gt; stack as a live problem set.&lt;/p&gt;

&lt;p&gt;If we descend into another instance of the search tree we&amp;#39;re
actually in, ie, currently searching for exceptions to the
compatibility assumption, there is no reason to restart our
search.  So, we can prune and ignore these recurrences.  And
so, we can write a decent &lt;code&gt;++nest&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Every nontrivial algorithm that traverses types keeps one of
these recurrence sets to detect repeating patterns.&lt;/p&gt;

&lt;p&gt;This leaves the onus on the programmer to design types that recur
regularly.  An infinite type &lt;em&gt;cannot&lt;/em&gt; be traversed if the actual
&lt;code&gt;[%hold p=type q=twig]&lt;/code&gt; in it does not recur, &lt;em&gt;with the exact
same type and twig nouns&lt;/em&gt;.  Indeed, doing anything significant
with this type will cause the compiler to hang (requiring an
interrupt, which will tell you where you made this mistake).&lt;/p&gt;

&lt;p&gt;Fortunately, doing the right thing here is much easier than doing
the wrong thing.  Why would you roll your own &lt;code&gt;list&lt;/code&gt;, anyway?
Use the standard tools and everything will work.&lt;/p&gt;

&lt;h2&gt;Where we use %hold&lt;/h2&gt;

&lt;p&gt;Everywhere.  But more specifically, every time a wing resolves to
an arm, we don&amp;#39;t trace into the callee; we make a &lt;code&gt;%hold&lt;/code&gt;.
Hence, in practice the type in a &lt;code&gt;%hold&lt;/code&gt; is always a &lt;code&gt;%core&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When other typed functional languages construct or define a gate,
lambda, closure, function, etc, they generally compute a &amp;quot;type
signature&amp;quot; for the function.  Ie, it accepts &lt;em&gt;this&lt;/em&gt; and produces
&lt;em&gt;that&lt;/em&gt;.  You will see things in Hoon gates that look to all the
world like type signatures.  They aren&amp;#39;t type signatures.&lt;/p&gt;

&lt;p&gt;In Hoon, if the compiler wants to traverse the type a gate
produces, it simply iterates a subject through the AST - the
twig.  In doing so, we start with the subject&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[%hold gate-type gate-twig]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and iterate into it, reducing as needed, and checking wherever
possible for logic loops, until we find what we want.&lt;/p&gt;

&lt;p&gt;Logically this iteration is always the same as &lt;code&gt;q:(mint p q)&lt;/code&gt;,
but in actual practice &lt;code&gt;++mint&lt;/code&gt; is making a formula we don&amp;#39;t
need.  Also, we only need to actually verify correctness when we
generate a formula - not when we traverse pseudolazy types.
Hence, we have the lighter &lt;code&gt;++play&lt;/code&gt; gate for traversal.&lt;/p&gt;

&lt;h2&gt;Head and tail recursion&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;^-&lt;/code&gt; (&lt;code&gt;kethep&lt;/code&gt;, &lt;code&gt;%kthp&lt;/code&gt;) twig, &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[%kthp p=tile q=twig]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;produces the type &lt;code&gt;p:(mint sub ~(bunt al p.gen))&lt;/code&gt; and the formula
&lt;code&gt;q:(mint sub q.gen)&lt;/code&gt;, checking that &lt;code&gt;p:(mint sub q.gen)&lt;/code&gt; nests in
&lt;code&gt;p:(mint sub ~(bunt al p.gen))&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;It is difficult to avoid the word &amp;quot;cast&amp;quot; when talking about
&lt;code&gt;%kthp&lt;/code&gt;, so we relent and use it.  Essentially we are casting the
product of twig &lt;code&gt;q&lt;/code&gt; to the icon of tile &lt;code&gt;p&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(Casting should not be confused with fishing.  &lt;code&gt;%kthp&lt;/code&gt; is a purely
static operation with no runtime effect whatsoever.)&lt;/p&gt;

&lt;p&gt;It&amp;#39;s a good general principle to cast the product of every arm.
First, because &lt;code&gt;%face&lt;/code&gt; is ignored by &lt;code&gt;++nest&lt;/code&gt;, the cast is an
opportunity to get the names right - for example, your arm can
produce &lt;code&gt;[foo bar]&lt;/code&gt; and cast it at the end to &lt;code&gt;[p=foo q=bar]&lt;/code&gt;.
The type produced by mere inference on practical code may be
funky, duplicative, poorly named, etc, etc.  Even if it&amp;#39;s not,
it&amp;#39;s often good to remind the reader what just got made.&lt;/p&gt;

&lt;p&gt;Furthermore, when an arm is used in head recursion, casting its
product becomes essential.  Our simplistic inference algorithm
cannot follow head recursion; but it can check that every step in
head recursion is correct, leaving no loophole.  &lt;/p&gt;

&lt;p&gt;A key point is that since &lt;code&gt;++play&lt;/code&gt; does not verify, it does not
need to descend into twig &lt;code&gt;q&lt;/code&gt; at all.  Thus when we type-check
head recursion, we check that any step is correct, assuming any
further steps are correct - a positive answer is dispositive.&lt;/p&gt;

&lt;p&gt;If you don&amp;#39;t completely understand (or believe) this, or if you are
not quite sure on the difference between head and tail recursion,
just cast the product of every arm.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%kthp&lt;/code&gt; also has an irregular wide form.  &lt;code&gt;^-(@tas foo)&lt;/code&gt; can also
be written&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;`@tas`foo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For example, although Hoon is perfectly capable of inferring that
decrement produces an atom, the decrement in &lt;code&gt;hoon.hoon&lt;/code&gt; casts
the product of the loop step anyway:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  b=0
|-  ^-  @
?:  =(a +(b))
  b
$(b +(b))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that this is just a fancy modern arrangement of the classic Hoon &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  b=0
|-  
^-  @
?:  =(a +(b))
  b
$(b +(b))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ie, it is only by casting &lt;em&gt;within&lt;/em&gt; the loop that we can infer
either head or tail recursion.&lt;/p&gt;

&lt;p&gt;The idiom of &amp;quot;barhep kethep tile&amp;quot; is common enough that you
should rarely see a &lt;code&gt;|-&lt;/code&gt; without a &lt;code&gt;^-&lt;/code&gt;.  Especially while
still a beginning Hoon programmer - when in doubt, cast.&lt;/p&gt;

&lt;h2&gt;Branch analysis&lt;/h2&gt;

&lt;p&gt;Type inference wouldn&amp;#39;t be very useful or interesting if we
couldn&amp;#39;t learn things about our nouns at runtime.  Actually,
we can&amp;#39;t even really &lt;em&gt;use&lt;/em&gt; most nouns without type inference.&lt;/p&gt;

&lt;p&gt;For instance, let&amp;#39;s make a list:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =foo `(list ,@)`[1 2 3 4 ~]
~waclux-tomwyc/try=&amp;gt; foo
~[1 2 3 4]
~waclux-tomwyc/try=&amp;gt; :type; foo
~[1 2 3 4]
it(@)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Looks good.  (Our prettyprinter has traversed the &lt;code&gt;list&lt;/code&gt; type and
matched it to its own list detection heuristic - which is the
only way we can print a list as such, since &lt;code&gt;++list&lt;/code&gt; is just a
gate and no trace of the word &lt;code&gt;list&lt;/code&gt; remains in the type.)&lt;/p&gt;

&lt;p&gt;So let&amp;#39;s try to use it.  What&amp;#39;s the first item?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; i.foo
! -type.it(@)
! -find-limb.i
! find-fork
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Doh!  We got a &lt;code&gt;find-fork&lt;/code&gt; because, with the cast, we threw away
our knowledge that we had &lt;code&gt;[1 2 3 4 ~]&lt;/code&gt; and replaced it with a
repeating structure that is either &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;[i=@ t=(list ,@)]&lt;/code&gt;.
We cannot pull &lt;code&gt;i&lt;/code&gt; from &lt;code&gt;foo&lt;/code&gt;, because we don&amp;#39;t know that &lt;code&gt;foo&lt;/code&gt;
is not &lt;code&gt;~&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since we&amp;#39;ve lost that information, we need a way to test for it
dynamically, and change the type of &lt;code&gt;foo&lt;/code&gt; on either side of the
branch.  To wit:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; ?~(foo 42 i.foo)
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What is &lt;code&gt;?~&lt;/code&gt; - &lt;code&gt;wutsig&lt;/code&gt;, &lt;code&gt;%wtsg&lt;/code&gt;?  A simple synthetic that
use our fishing hoon, &lt;code&gt;?=&lt;/code&gt; (&lt;code&gt;wuttis&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; ?:(?=(~ foo) 42 i.foo)
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On the &lt;code&gt;|&lt;/code&gt; side of the &lt;code&gt;?:&lt;/code&gt;, we know that &lt;code&gt;foo&lt;/code&gt; is not &lt;code&gt;~&lt;/code&gt; -
and because it&amp;#39;s not &lt;code&gt;~&lt;/code&gt;, it has to be a cell.  We can see the
type system learning this: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :type; ?~(foo !! foo)
[i=1 t=~[2 3 4]]
[i=@ t=it(@)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice also the use of &lt;code&gt;!!&lt;/code&gt;.  &lt;code&gt;!!&lt;/code&gt; always crashes - so it
produces the type &lt;code&gt;%void&lt;/code&gt;.  We&amp;#39;re essentially asserting that
&lt;code&gt;foo&lt;/code&gt; is a non-empty list.   A branch that produces &lt;code&gt;%void&lt;/code&gt; will
never return a value (if taken, it will always crash), so its
product can be ignored.  If we changed that:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :type; ?~(foo %foobar foo)
[i=1 t=~[2 3 4]]
{ %foobar [i=@ t=it(@)] }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It&amp;#39;s important to note that the &lt;em&gt;only&lt;/em&gt; hoons recognized in branch
analysis are &lt;code&gt;?=&lt;/code&gt; (&lt;code&gt;wuttis&lt;/code&gt;, &lt;code&gt;%wtts&lt;/code&gt;, fish), &lt;code&gt;?&amp;amp;&lt;/code&gt; (&lt;code&gt;wutpam&lt;/code&gt;,
&lt;code&gt;%wtpm&lt;/code&gt;, logical and), and &lt;code&gt;?|&lt;/code&gt; (&lt;code&gt;wutbar&lt;/code&gt;, &lt;code&gt;%wtbr&lt;/code&gt;, logical or).
(Boolean logic is fully understood within the test itself, so the
second twig in a &lt;code&gt;?&amp;amp;&lt;/code&gt; can depend on the result of the first.)&lt;/p&gt;

&lt;p&gt;Of course, synthetic hoons that reduce to these work as well.
However, we don&amp;#39;t learn from any other test, even if we could:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; ?:(?=(~ foo) 42 i.foo)
1
~waclux-tomwyc/try=&amp;gt; ?:(=(~ foo) 42 i.foo)
! -type.it(@)
! -find-limb.i
! find-fork
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Type inference in Hoon is anything but magic.  It&amp;#39;s a relatively
simple algorithm, which you nonetheless need to understand if
you&amp;#39;re going to make it as a Hoon programmer.  &amp;quot;It just works&amp;quot;
and &amp;quot;do what I mean&amp;quot; are not in the building.&lt;/p&gt;

&lt;p&gt;All branches (such as &lt;code&gt;?~&lt;/code&gt;) reduce to &lt;code&gt;?:&lt;/code&gt;.  It would appear, for
instance, that Hoon has (like many other functional languages)
pattern-matching primitives, &lt;code&gt;?-&lt;/code&gt; (and &lt;code&gt;?+&lt;/code&gt;, which takes a
default).  Au contraire - these are just synthesized from &lt;code&gt;?:&lt;/code&gt;
and &lt;code&gt;?=&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, another thing that branch analysis can do is statically
detect that branches aren&amp;#39;t taken.  For instance, with our little
&lt;code&gt;foo&lt;/code&gt; list, we cannot know &lt;em&gt;statically&lt;/em&gt; whether or not it&amp;#39;s null,
but we can test it &lt;em&gt;dynamically&lt;/em&gt;.  Statically, however, we know
one thing - &lt;code&gt;foo&lt;/code&gt; cannot have the value &lt;code&gt;%foobar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So what happens if we fish for it?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~zod/try=&amp;gt; ?:(?=(%foobar foo) 42 i.foo)
! mint-vain
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For lo, we fish in vain.  We get this error whenever a branch is
not taken.  This is tremendously useful when, for example, &lt;code&gt;?-&lt;/code&gt;
switches on a kelp - if we write a case for a stem that doesn&amp;#39;t
exist, or miss a stem that must be handled, the compiler knows.&lt;/p&gt;

&lt;h2&gt;Geometric and generic polymorphism&lt;/h2&gt;

&lt;p&gt;One interesting question in any language is what happens when you
pass a function an argument more specialized than its declaration.&lt;/p&gt;

&lt;p&gt;Consider a function that takes a pair &lt;code&gt;[a b]&lt;/code&gt; and produces [b a].
Any noun will obviously do for &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;.  So the sample tile
is &lt;code&gt;[a=* b=*]&lt;/code&gt;.  But suppose the caller knows something more
about &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.  What happens?  Let&amp;#39;s give it a try:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~zod/try=&amp;gt; :type; (|=([a=* b=*] [b a]) %foo %bar)
[7.496.034 7.303.014]
[* *]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;|=&lt;/code&gt; (&lt;code&gt;bartis&lt;/code&gt;, &lt;code&gt;%brts&lt;/code&gt;), the normal way of building a gate,
we lost all our type information.  Sometimes this is fine.
Sometimes it&amp;#39;s exactly what we want.  But here&amp;#39;s something else
we can do:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~zod/try=&amp;gt; :type; (|*([a=* b=*] [b a]) %foo %bar)
[%bar %foo]
[%bar %foo]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By using &lt;code&gt;|*&lt;/code&gt; (&lt;code&gt;bartar&lt;/code&gt;, &lt;code&gt;%brtr&lt;/code&gt;), we seem to have produced the
same noun, but not lost any type information.  Interesting!&lt;/p&gt;

&lt;p&gt;The difference is that while both &lt;code&gt;|=&lt;/code&gt; and &lt;code&gt;|*&lt;/code&gt; are polymorphic,
&lt;code&gt;|=&lt;/code&gt; uses &lt;em&gt;geometric&lt;/em&gt; polymorphism and &lt;code&gt;|*&lt;/code&gt; uses &lt;em&gt;generic&lt;/em&gt;.
Which should you choose?&lt;/p&gt;

&lt;p&gt;There&amp;#39;s a simple rule for this, which is that unless you are a
wizard doing wizardly things, you should use &lt;code&gt;|=&lt;/code&gt;.  Generic
polymorphism is a way to build and use tools like containers
(lists, etc), which in other, inferior languages might simply be
built in to the language semantics.  Especially as a new Hoon
programmer, you are probably not building heavy machinery of this
kind, and should probably make do with the standard components.&lt;/p&gt;

&lt;p&gt;But you will be &lt;em&gt;using&lt;/em&gt; containers, etc.  So there&amp;#39;s no shortcut
for understanding both systems.&lt;/p&gt;

&lt;h3&gt;Geometric polymorphism&lt;/h3&gt;

&lt;p&gt;We&amp;#39;ve already met the fundamental function of geometric
polymorphism, &lt;code&gt;++nest&lt;/code&gt;.  The question &lt;code&gt;(nest sut ref)&lt;/code&gt; asks is:
can I take any noun in type &lt;code&gt;ref&lt;/code&gt;, and use it as if it was within
&lt;code&gt;sut&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Consider the trivial example above - the question is, can we use
our noun [%foo %bar] as if it was a &lt;code&gt;[a=* b=*]&lt;/code&gt;?  &lt;/p&gt;

&lt;p&gt;When we use &lt;code&gt;%=&lt;/code&gt; (&lt;code&gt;centis&lt;/code&gt;, &lt;code&gt;%cnts&lt;/code&gt;) to modify the sample in a
core, we actually change the type of the core.  (Of course we are
not &lt;em&gt;modifying&lt;/em&gt; the core per se, but creating a new one with the
given changes.)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ %core
  [ %cell 
    [%cell [%face %a %noun] [%face %b %noun]]
    context
  ]
  (map term twig)
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ %core
  [ %cell 
    [%cell [%cube %foo [%atom %tas]] [%cube %bar [%atom %tas]]]
    context
  ]
  (map term twig)
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This poses a couple of problems.  First, remember, when we infer
into a gate call or any other use of a core arm, we infer lazily
by creating a &lt;code&gt;[%hold type twig]&lt;/code&gt; with the subject core and the
arm body.  When we want to find out what type the arm produces,
we simply step through it.&lt;/p&gt;

&lt;p&gt;But among other possible problems here, we&amp;#39;ve actually &lt;em&gt;destroyed
our argument names&lt;/em&gt;.  If we try to step through the body of the
function with this modified core, we can&amp;#39;t possibly play &lt;code&gt;[b a]&lt;/code&gt;.
The names &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; simply won&amp;#39;t resolve.&lt;/p&gt;

&lt;p&gt;This is why a core is actually more complicated than our original
explanation would suggest.  The &lt;code&gt;%core&lt;/code&gt; frond is actually:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  type  $%  [%core p=type q=coil]
          ==
++  coil  $:  p=?(%gold %iron %lead %zinc)
              q=type
              r=[p=?(~ ^) q=(map term foot)]
          ==
++  foot  $%  [%ash p=twig]
              [%elm p=twig]
          ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Geeze, man, what is all this nonsense?  Okay, fine.  Let&amp;#39;s
explain the real &lt;code&gt;%core&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First, &lt;code&gt;q&lt;/code&gt; in the &lt;code&gt;coil&lt;/code&gt; is the original payload type for use in
a &lt;code&gt;%hold&lt;/code&gt;.  Hence geometric polymorphism.  The question we have
to answer whenever we use an arm is: is this core corrupt?  As
in: is the payload that&amp;#39;s in it now geometrically compatible with
the payload that its formulas were compiled with?  Can we use the
present payload as if it was the original, default payload?&lt;/p&gt;

&lt;p&gt;It is actually not a type error of any kind to produce a modified
core with the payload set to any kind of garbage at all.  It&amp;#39;s
just a type error to &lt;em&gt;use&lt;/em&gt; it - unless the payload is compatible.
And when we use a geometric arm, we test this compatibility and
then treat the present sample as if it was the original.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;q.r&lt;/code&gt; in the coil is the map of arms.  The polymorphism model is
not an attribute of the core, but of the arm - &lt;code&gt;%ash&lt;/code&gt; means
geometric, &lt;code&gt;%elm&lt;/code&gt; means generic.  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;p.r&lt;/code&gt;, if not null, is the actual generated battery of Nock
formulas.  Why do we need this at compile time?  Remember
&lt;code&gt;%ktsg&lt;/code&gt;, which folds constants.  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;p.r&lt;/code&gt; is null while we are compiling the core&amp;#39;s own arms, for
obvious reasons (though we could get a little smarter about
circularities), but once we complete this task we can put the
battery in the type.  The result is that, if we are building a
reef of cores, we can fold arms of this core in the next one
down.  &lt;/p&gt;

&lt;p&gt;For example, one of the main uses of &lt;code&gt;%ktsg&lt;/code&gt; is simply to make
default samples constant, so that we don&amp;#39;t have to perform some
simple but unnecessary computation every time we use a gate.
Because we can only fold an arm in a completed core, a good
general practice in building applications is to use a reef of at
least two cores - inner for the tiles, outer for the functions.&lt;/p&gt;

&lt;p&gt;All that remains is this mysterious &lt;code&gt;p&lt;/code&gt; field.  If you are an OO
geek of a certain flavor who was once busted with a Sharpie for
writing &amp;quot;BERTRAND MEYER IS GOD&amp;quot; on a Muni bus, you may be
familiar with the broad language concept of &lt;em&gt;variance&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Polymorphism in Hoon supports four kinds of variance: &lt;code&gt;%gold&lt;/code&gt;
(invariant), &lt;code&gt;%lead&lt;/code&gt; (bivariant), &lt;code&gt;%zinc&lt;/code&gt; (covariant), and
&lt;code&gt;%iron&lt;/code&gt; (contravariant).&lt;/p&gt;

&lt;p&gt;The question of variance arises when we want to test whether one
core is compatible with another.  Hoon is a functional language,
for example, so it would be nice to pass functions around.  Gosh,
even C can pass functions around.&lt;/p&gt;

&lt;p&gt;For core A to nest within core B (any A can be used as a B), it
seems clear that A should have the same set of arms as B (with
formulas at exactly the same axes in the battery), and that any
product of an A arm should nest within the product of the
corresponding B arm.&lt;/p&gt;

&lt;p&gt;But what about the payloads?  Worse - what about the &lt;em&gt;contexts&lt;/em&gt;?
A simple rule might be that the payload of A must also nest
within the payload of B.  Unfortunately, this doesn&amp;#39;t work.&lt;/p&gt;

&lt;p&gt;Suppose, for instance, that I write a sort gate, one of whose
arguments is a comparison gate producing a loobean.  (This is
generally a problem calling for generic polymorphism, but let&amp;#39;s
assume we&amp;#39;re sorting lists of a fixed type.)  Okay, great.  We
know the &lt;em&gt;sample&lt;/em&gt; type of the comparator - but what about the
&lt;em&gt;context&lt;/em&gt;?  The sort library cannot possibly have the same
context as the application which is using the sort library.  So,
the cores will be incompatible and the invocation will fail.&lt;/p&gt;

&lt;p&gt;This rule, which doesn&amp;#39;t work in this case, is the rule for
&lt;code&gt;%gold&lt;/code&gt; (invariant) cores.  Every core is created &lt;code&gt;%gold&lt;/code&gt;, and
remains &lt;code&gt;%gold&lt;/code&gt; from the perspective of its own arms.&lt;/p&gt;

&lt;p&gt;But the type of some arbitrary comparator, which is an argument
to our sort function, cannot possibly be &lt;code&gt;%gold&lt;/code&gt;.  Rather, we
need an &lt;code&gt;%iron&lt;/code&gt; (contravariant) core.  You can turn any &lt;code&gt;%gold&lt;/code&gt;
core into an &lt;code&gt;%iron&lt;/code&gt; one with &lt;code&gt;^|&lt;/code&gt; (&lt;code&gt;ketbar&lt;/code&gt;, &lt;code&gt;%ktbr&lt;/code&gt;), but the
transformation is not reversible.&lt;/p&gt;

&lt;p&gt;The rules for using an &lt;code&gt;%iron&lt;/code&gt; core are that (a) the context is
opaque (can neither be read nor written), and (b) the sample is
write-only.  Why?  Because it&amp;#39;s absolutely okay to use as your
comparator a gate which accepts a more general sample than you&amp;#39;ll
actually call it with.  You can write a more specialized noun
into this sample - but if you read the default value and treat it
as more specialized, you have a type loophole.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;%zinc&lt;/code&gt; (covariant) core is the opposite - the context remains
opaque, the sample is read-only.  We don&amp;#39;t use any &lt;code&gt;%zinc&lt;/code&gt; at
present, but this is only because we haven&amp;#39;t yet gotten into
inheritance and other fancy OO patterns.  (Hoon 191 had
inheritance, but it was removed as incompletely baked.) You make
a &lt;code&gt;%gold&lt;/code&gt; core &lt;code&gt;%zinc&lt;/code&gt; with &lt;code&gt;^&amp;amp;&lt;/code&gt; (&lt;code&gt;ketpam&lt;/code&gt;, &lt;code&gt;%ktpm&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Finally, the entire payload of a &lt;code&gt;%lead&lt;/code&gt; (bivariant) core is
immune to reading or writing.  So all that matters is the product
of the arms.  You make a lead core with &lt;code&gt;^?&lt;/code&gt; (&lt;code&gt;ketwut&lt;/code&gt;, &lt;code&gt;%ktwt&lt;/code&gt;).&lt;/p&gt;

&lt;h3&gt;Generic polymorphism&lt;/h3&gt;

&lt;p&gt;When the arm we&amp;#39;re executing is &lt;code&gt;%elm&lt;/code&gt;, not &lt;code&gt;%ash&lt;/code&gt;, there is
actually &lt;em&gt;no&lt;/em&gt; check that the payload in the actual core, type
&lt;code&gt;p&lt;/code&gt;, nests in the original payload &lt;code&gt;q.q&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Moreover, &lt;code&gt;%elm&lt;/code&gt; arms (defined not with &lt;code&gt;++&lt;/code&gt; or &lt;code&gt;slus&lt;/code&gt;, which
means &lt;code&gt;%ash&lt;/code&gt;, but &lt;code&gt;+-&lt;/code&gt; or &lt;code&gt;shep&lt;/code&gt;) are actually &lt;em&gt;not even
type-checked when compiled&lt;/em&gt;.  They have to generate valid nock,
but all verification is disabled.&lt;/p&gt;

&lt;p&gt;Why?  How?  Because there&amp;#39;s another way of dealing with a core
whose payload has been modified.  In a sense, it&amp;#39;s incredibly
crude and hacky.  But it&amp;#39;s perfectly valid, and it lets Hoon
provide the same basic feature set provided by generic features
in other languages, such as Haskell&amp;#39;s typeclasses.&lt;/p&gt;

&lt;p&gt;Logically, when we use an &lt;code&gt;%elm&lt;/code&gt;, generic or &amp;quot;wet&amp;quot; arm, we simply
&lt;em&gt;recompile the entire twig&lt;/em&gt; with the changed payload.  If this
recompilation, which &lt;em&gt;is&lt;/em&gt; typechecked, succeeds - and if it
&lt;em&gt;produces exactly the same Nock formula&lt;/em&gt; - we know that we can
use the modified core as if it was the original, without of
course changing the static formula we generated once.&lt;/p&gt;

&lt;p&gt;Why does this work out to the same thing as a typeclass?  Because
with a wet core, we are essentially just using the source code of
the core as a giant macro in a sense.  Our only restriction is
that because the Nock formula that actually executes the code
must be the same formula we generated statically for the battery.&lt;/p&gt;

&lt;p&gt;In a sense this defines an implicit typeclass: the class of types
that can be passed through the arm, emerging intact and with an
identical formula.  But no declaration of any sort is required.
You could call it &amp;quot;duck typeclassing.&amp;quot;&lt;/p&gt;

&lt;p&gt;Of course, a lot of caching is required to make this compile with
reasonable efficiency.  But computers these days are pretty fast.&lt;/p&gt;

&lt;p&gt;This description of how wet arms work is not quite correct,
though it&amp;#39;s the way ancient versions of Hoon worked.  The problem
is that there are some cases in which it&amp;#39;s okay if the modified
core generates a different battery - for example, if the original
battery takes branches that are not taken in this specific call.&lt;/p&gt;

&lt;p&gt;So we have a function &lt;code&gt;++mull&lt;/code&gt; which tests whether a twig
compiled with one subject will work with another.  But still,
thinking of the wet call check as a simple comparison of the
compiled code is the best intuitive test.&lt;/p&gt;

&lt;p&gt;Again, your best bet as a novice Hoon programmer is to understand
that this is how things like &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; work, that someone
else who knows Hoon better than you wrote these tools, and that
in general if you want to use generic polymorphism you&amp;#39;re
probably making a mistake.  But if you wonder how &lt;code&gt;list&lt;/code&gt; works -
this is how it works.&lt;/p&gt;

&lt;h3&gt;Generic polymorphism action sequences&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s deploy this boy!  Here is &lt;code&gt;++list&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  list  |*(a=_,* $|(~ [i=a t=(list a)]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Don&amp;#39;t worry.  This is just grievously badass hardcore Hoon - as
irregular as Marseilles street slang.  As a novice Hoon monkey,
you won&amp;#39;t be writing &lt;code&gt;++list&lt;/code&gt; or anything like it, and you can
stick to French as she is spoke in Paris. &lt;/p&gt;

&lt;p&gt;On the other hand, at least this grizzled old baboon has no
trouble parsing the apparent line noise above.  Why so funky?
Why, oh why, &lt;code&gt;_,*&lt;/code&gt;?  Because for various irrelevant reasons,
the &lt;code&gt;++list&lt;/code&gt; here is trying as hard as possible to build itself
out of tiles.&lt;/p&gt;

&lt;p&gt;For instance, in general in Hoon it is gauche for a gate to use
its core&amp;#39;s namespace to recurse back into itself, but tiles do
not expose their own internals to the twigs they contain
(otherwise, obviously, they could not be hygienic).&lt;/p&gt;

&lt;p&gt;Tiles manipulate the subject such that it&amp;#39;s not possible to loop
properly.  So in fact there is no alternative but to use &lt;code&gt;(list
a)&lt;/code&gt; within &lt;code&gt;++list&lt;/code&gt; - a normal usage in complex tiles, but only
in complex tiles.&lt;/p&gt;

&lt;p&gt;But a normal person wouldn&amp;#39;t use tiles to prove a point.  They&amp;#39;d
do it like this - let&amp;#39;s use the REPL to build a &lt;code&gt;list&lt;/code&gt; replacement, 
without one single &amp;quot;obfuscated Hoon trick.&amp;quot;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~zod/try=&amp;gt; =lust |*(a=$+(* *) |=(b=* ?@(b ~ [i=(a -.b) t=$(b +.b)])))
~zod/try=&amp;gt; ((lust ,@) 1 2 ~)
~[1 2]
~zod/try=&amp;gt; ((list ,@) 1 2 ~)
~[1 2]
~zod/try=&amp;gt; `(list ,@)``(lust ,@)`[1 2 ~]
~[1 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;lust&lt;/code&gt; do the same thing and are perfectly
compatible.  But sadly, &lt;code&gt;lust&lt;/code&gt; still looks like line noise.
Let&amp;#39;s slip into something more comfortable:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|*  a=$+(* *)
|=  b=*
?@  b  ~
[i=(a -.b) t=$(b +.b)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We haven&amp;#39;t met &lt;code&gt;$+&lt;/code&gt; (&lt;code&gt;buclus&lt;/code&gt;) yet.  &lt;code&gt;$+(p q)&lt;/code&gt; is a tile for a
gate which accepts &lt;code&gt;p&lt;/code&gt; and produces &lt;code&gt;q&lt;/code&gt;.  The spectre of function
signatures once again rears its ugly head - but &lt;code&gt;$+(p q)&lt;/code&gt; is no
different from &lt;code&gt;$_(|+(p _q))&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Otherwise, when we think of a wet gate (&lt;code&gt;|*&lt;/code&gt;) as a macro, we see
(list ,@) producing&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  b=*
?@  b  ~
[i=(,@ -.b) t=$(b +.b)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function is easily recognized as a gate accepting a noun and
producing a list of atoms - in short, perfectly formed for an
herbaceous tile.  Pass it some random noun off the Internet, and
it will give you a list of atoms.  In fact, we could define it
on its own as:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  atls
  |=  b=*
  ?@  b  ~
  [i=(,@ -.b) t=$(b +.b)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and everywhere you write &lt;code&gt;(list ,@)&lt;/code&gt;, you could write &lt;code&gt;atls&lt;/code&gt;.
Which would work perfectly despite its self-evident lameness.
Note &lt;em&gt;in particular&lt;/em&gt; that the inner &lt;code&gt;b&lt;/code&gt; gate is &lt;em&gt;not&lt;/em&gt; wet, but
rather dry - once we have done our substitution, there is no need
to get funky.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s do some little fun thing with &lt;code&gt;list&lt;/code&gt; - eg, gluing two lists
together:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  weld
  ~/  %weld
  |*  [a=(list) b=(list)]
  =&amp;gt;  .(a ^.(homo a), b ^.(homo b))
  |-  ^+  b
  ?~  a  b
  [i.a $(a t.a)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What is this &lt;code&gt;homo&lt;/code&gt; thing (meaning &amp;quot;homogenize&amp;quot;, of course)?
Exactly that - it homogenizes the type of a list, producing its
sample noun unchanged:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    ++  homo
      |*  a=(list)
      ^+  =&amp;lt;  $
        |%  +-  $  ?:(_? ~ [i=(snag 0 a) t=$])
        --
      a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here is more dark magic that should clearly be ignored.  But
essentially, to homogenize a list &lt;code&gt;a&lt;/code&gt;, we are casting &lt;code&gt;a&lt;/code&gt; to a
deranged pseudo-loop that produces an infinite stream of the
first item in &lt;code&gt;a&lt;/code&gt;, selected via the &lt;code&gt;++snag&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  snag
  ~/  %snag
  |*  [a=@ b=(list)]
  |-
  ?~  b
    ~|(&amp;#39;snag-fail&amp;#39; !!)
  ?:  =(0 a)
    i.b
  $(b t.b, a (dec a))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;++snag&lt;/code&gt; of course selects any item in the list; but if &lt;code&gt;b&lt;/code&gt; has a
type more complex than a homogeneous list (eg, the type system
might well know the number of items, etc, etc), Hoon is nowhere
near enough to see that the counter is always 0.  So the type
produced by &lt;code&gt;++snag&lt;/code&gt; is the union of all list elements, which is
precisely the type we want for our homogenized list.&lt;/p&gt;

&lt;p&gt;As for &lt;code&gt;^.&lt;/code&gt; (&lt;code&gt;ketdot&lt;/code&gt;, &lt;code&gt;%ktdt&lt;/code&gt;), we can see it in &lt;code&gt;++open&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;  ++  open
    ^-  twig
    ?-  gen
      [%ktdt *]  [%ktls [%cnhp p.gen q.gen ~] q.gen]
    ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ie, &lt;code&gt;^.(a b)&lt;/code&gt; is &lt;code&gt;^+((a b) b)&lt;/code&gt; is &lt;code&gt;^-(_(a b) b)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;++weld&lt;/code&gt; prudently casts its product to the type of the base list
&lt;code&gt;b&lt;/code&gt;.  In future this &lt;code&gt;^+&lt;/code&gt;  will probably be removed, since we are
perfectly capable of inferring that when you weld &lt;code&gt;(list a)&lt;/code&gt; and
&lt;code&gt;(list b)&lt;/code&gt;, you get a &lt;code&gt;(list ?(a b))&lt;/code&gt;.  But there&amp;#39;s old code this
change might confuse.&lt;/p&gt;

&lt;p&gt;In short: generic polymorphism is cool but wacky.  Leave it to
the experts, please!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch9&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Tiles&lt;/a&gt; &lt;a href=&quot;/doc/2013/11/19/ch11&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Odds, Ends&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Chapter IX (Tiles)</title>
   <link href="http://urbit.org/doc/2013/11/18/ch9/"/>
   <updated>2013-11-18T00:00:00-08:00</updated>
   <id>http://urbit.org/doc/2013/11/18/ch9</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch8&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Gates&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/19/ch10&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Type Inference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;quot;Not to get knowledge, but to save yourself from having
ignorance foisted upon you.&amp;quot;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(Carlyle)&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;Tiles&lt;/h2&gt;

&lt;p&gt;We actually told a little white lie when we said that a Hoon file
turns into a twig.  Well, sort of.  It does turn into a twig.
But parts of it often start out as something else - a &lt;code&gt;tile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What is a tile?  First, concretely, a tile is an AST subtree
that&amp;#39;s reduced statically into a twig.  It can be reduced in four
ways - cryptically called &lt;code&gt;bunt&lt;/code&gt;, &lt;code&gt;clam&lt;/code&gt;, &lt;code&gt;fish&lt;/code&gt;, and &lt;code&gt;whip&lt;/code&gt;.  A
tile is always some leg of a twig, and that twig defines how the
tile is reduced.  (Don&amp;#39;t worry, we&amp;#39;ll see plenty of examples.)&lt;/p&gt;

&lt;p&gt;Abstractly, though, when we see tiles in Hoon peer at them
through our rapidly fading 20th-century programming spectacles,
what we see looks a heck of a lot like a &lt;em&gt;type declaration&lt;/em&gt;.  &lt;/p&gt;

&lt;p&gt;But no.  Just as a gate is not a lambda, a tile is not a type.
And worse - we&amp;#39;ve already used the word &lt;code&gt;type&lt;/code&gt; for something
else.  And worst of all - each tile corresponds to a well-defined
type, called its &lt;em&gt;icon&lt;/em&gt;.  But tile and icon are not in any way
the same noun.  You can see the potential confusion...&lt;/p&gt;

&lt;p&gt;A tile is actually two steps away from being a type, in the
strict sense of &lt;code&gt;++type&lt;/code&gt;.  The tile is converted statically
into a twig, which in turn may (depending on the conversion)
produce the icon, test for it, etc.  And always, the icon is 
some function of the tile and its subject.&lt;/p&gt;

&lt;p&gt;Nonetheless, even the most experienced Hoon programmers can be
heard saying &amp;quot;type&amp;quot; when they mean &amp;quot;tile.&amp;quot;  Apparently you can
take the boy out of the &amp;#39;90s but not the &amp;#39;90s out of the boy.
In fact, it&amp;#39;s tempting to suggest that if there&amp;#39;s one problem
with 20th-century programming in general, it&amp;#39;s that it doesn&amp;#39;t
know the difference between a tile and its icon.&lt;/p&gt;

&lt;p&gt;Imagine, for instance, a C++ in which the class definition and
the constructor are the same thing.  And the latter can also
validate untrusted data off the Internets, acting much as for
instance an XML DTD.  Why would you have a type system and
not be able to do this?&lt;/p&gt;

&lt;h2&gt;Reductions&lt;/h2&gt;

&lt;p&gt;Broadly speaking, a tile is a &lt;em&gt;convenient way of making a
well-typed noun&lt;/em&gt;.  &lt;/p&gt;

&lt;p&gt;It&amp;#39;s important to note that tiles are really pure sugar.  It is
possible to build a language like Hoon, but with only twigs and
no tiles.  However, certain common tasks in this language will
always be unnecessarily cumbersome.  &lt;/p&gt;

&lt;p&gt;A tile is not a type declaration, but it has roughly the same job
to do - and this is by no means a trivial job.  So tiles aren&amp;#39;t
trivial.  Sorry, we wish they were.  (Actually we wish they
didn&amp;#39;t exist at all, but couldn&amp;#39;t figure out how to swing it.)&lt;/p&gt;

&lt;p&gt;We use tiles by converting them to twigs, which produce or
identify nouns of a type easily predictable from the tile.
Again, there are four such reductions: &lt;code&gt;bunt&lt;/code&gt;, &lt;code&gt;clam&lt;/code&gt;, &lt;code&gt;fish&lt;/code&gt;, 
and &lt;code&gt;whip&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Bunting&lt;/h3&gt;

&lt;p&gt;Bunting a tile - if &lt;code&gt;sec&lt;/code&gt; is a tile, &lt;code&gt;~(bunt al sec)&lt;/code&gt; produces
its bunt - makes a twig that &lt;em&gt;creates a blank default example&lt;/em&gt;
of the tile&amp;#39;s icon. &lt;/p&gt;

&lt;p&gt;Bunting is actually the most common use of a tile.  Consider the
gates we&amp;#39;ve just been defining - how do we build a gate?   With&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  deq
  =+  x=0
  |.  
  =+  y=0
  |-  
  ?:  =(x +(y))
    y
  $(y +(y))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The value &lt;code&gt;x=0&lt;/code&gt; is a useless default.  It&amp;#39;s in our gate only
because the gate is built first, then modified with the real
sample.  Accordingly, in practice to build a gate we use the
synthetic hoon &lt;code&gt;|=&lt;/code&gt; (&lt;code&gt;bartis&lt;/code&gt;, &lt;code&gt;%brts&lt;/code&gt;), which is defined as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  twig  $%  [%brts p=tile q=hoon]
          ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  open
  ^-  twig
  ?-    gen
    [%bctr *]  [%ktsg ~(bunt al p.gen)]
    [%brcb *]  [%tsls [%bctr p.gen] [%brcn q.gen]]
    [%brts *]  [%brcb p.gen (~(put by *(map term foot)) %$ [%ash q.gen])]
  ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(The only hoon we haven&amp;#39;t met here is &lt;code&gt;^~&lt;/code&gt; (&lt;code&gt;ketsig&lt;/code&gt;, &lt;code&gt;%ktsg&lt;/code&gt;),
which tells the compiler to compute a constant expression at
compile time.  Obviously, the default sample in a gate should
under almost every circumstance be a constant.)&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;|=&lt;/code&gt; we have:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  deq
  |=  x=@
  =+  y=0
  |-  
  ?:  =(x +(y))
    y
  $(y +(y))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or if we prefer&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  deq  |=(x=@ =+(y=0 |-(?:(=(x +(y)) y $(y +(y))))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What is &lt;code&gt;x=@&lt;/code&gt;?  A tile.  And the tile in &lt;code&gt;|=&lt;/code&gt; is always bunted to
create the default sample.  &lt;/p&gt;

&lt;p&gt;Furthermore, it&amp;#39;s wrong to say that the default sample is
useless.  It generates a corresponding &lt;em&gt;default product&lt;/em&gt;.  It is
perfectly legitimate to simply apply a gate, even a previously
unviolated gate, without changing the sample at all.&lt;/p&gt;

&lt;p&gt;For example, one type of tile is simply a gate.  When we bunt
such a gate, we have no choice but to produce the default
product.  Thus any gate arm that wants to be used as a tile
has the responsibility to produce a useful default product.&lt;/p&gt;

&lt;h3&gt;Clamming&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;clam&lt;/code&gt; reduction generates a gate which accepts an arbitrary
noun and produces a member of the tile&amp;#39;s icon.  Ie, &lt;code&gt;clam&lt;/code&gt;
generates a validator function for the icon.  Perhaps you
can see how this might be useful, at least, on the Internets.&lt;/p&gt;

&lt;p&gt;Moreover, a clam for any tile, if passed a member of the type, is
guaranteed to produce its sample.  If passed a noun outside
the type, it will normalize and/or default.  It won&amp;#39;t crash -
except for the custom cases of &lt;code&gt;%herb&lt;/code&gt; and &lt;code&gt;%weed&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Fishing&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;fish&lt;/code&gt; reduction lets us test if a noun matches the tile,
with the &lt;code&gt;?=&lt;/code&gt; (&lt;code&gt;wuttis&lt;/code&gt;, &lt;code&gt;%wtts&lt;/code&gt;) natural hoon:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  twig  $%  [%wtts p=tile q=wing]
          ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;?=&lt;/code&gt; only works on a wing and more specifically leg -
that is, it has to be testing a fragment of the subject.&lt;/p&gt;

&lt;p&gt;Moreover - we&amp;#39;ll discuss this in more detail when we get to type
inference - when we use &lt;code&gt;?=&lt;/code&gt; in a &lt;code&gt;?:&lt;/code&gt; test, the compiler sees
the test and uses it to refine the subject type on either side
of the branch.  Hence:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?:  ?=(@ a)             ::  test if a is an atom
  XX                    ::  code assuming a is an atom
XX                      ::  code assuming a is a cell
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some languages call fishing &amp;quot;pattern matching.&amp;quot; &lt;/p&gt;

&lt;h3&gt;Whipping&lt;/h3&gt;

&lt;p&gt;Besides fishing on a leg, we can normalize any leg to any tile
using the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;bucpat&lt;/code&gt;, &lt;code&gt;%bcpt&lt;/code&gt;) hoon - aka, &lt;code&gt;whip&lt;/code&gt;.  Not only
is &lt;code&gt;whip&lt;/code&gt; the same thing as &lt;code&gt;clam&lt;/code&gt;, it&amp;#39;s what &lt;code&gt;clam&lt;/code&gt; uses
internally. All &lt;code&gt;clam&lt;/code&gt; does is make a gate whose sample, an 
arbitrary noun &lt;code&gt;+&amp;lt;&lt;/code&gt; (&lt;code&gt;glus&lt;/code&gt;, &lt;code&gt;.6&lt;/code&gt;), it whips into its tile.&lt;/p&gt;

&lt;h2&gt;Tile syntax and abuse&lt;/h2&gt;

&lt;p&gt;A wide variety of twigs contain tiles, but the basic tiling twigs
are worth listing in one place, along with their regular and
irregular syntax:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  twig  $%  [%bccb p=tile]
              [%bccm p=tile]
              [%bcpt p=wing q=tile]
              [%bctr p=tile]
              [%wtts p=tile q=wing]
          ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;$_&lt;/code&gt; (&lt;code&gt;buccab&lt;/code&gt;, &lt;code&gt;%bccb&lt;/code&gt;) bunts tile &lt;code&gt;p&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$*&lt;/code&gt; (&lt;code&gt;buctar&lt;/code&gt;, &lt;code&gt;%bctr&lt;/code&gt;) bunts tile &lt;code&gt;p&lt;/code&gt; and folds it statically
to a constant with &lt;code&gt;%ktsg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$,&lt;/code&gt; (&lt;code&gt;buccom&lt;/code&gt;, &lt;code&gt;%bccm&lt;/code&gt;) makes a clam for tile &lt;code&gt;p&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;bucpat&lt;/code&gt;, &lt;code&gt;%bcpt&lt;/code&gt;) whips the leg at wing &lt;code&gt;p&lt;/code&gt;, filtering it
with tile &lt;code&gt;q&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;?=&lt;/code&gt; (&lt;code&gt;wuttis&lt;/code&gt;, &lt;code&gt;%wtts&lt;/code&gt;) fishes the leg at wing &lt;code&gt;q&lt;/code&gt; for tile &lt;code&gt;p&lt;/code&gt;,
producing &amp;amp; (yes) if and only if leg &lt;code&gt;q&lt;/code&gt; is in tile &lt;code&gt;p&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(&lt;code&gt;%wtts&lt;/code&gt; looks different because it produces a boolean, not a
noun in the tile.)&lt;/p&gt;

&lt;p&gt;One thing we&amp;#39;ll see quite frequently is the irregular wide forms
of these hoons (in fact, the regular forms of many are rare).
Consider the base tiles &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; - ie, noun and atom.  (And
note that tiles, too, have tall, wide, and irregular wide forms.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;_&lt;/code&gt; prefix before a wide tile is &lt;code&gt;%bccb&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~zod/try=&amp;gt; _*
0

~zod/try=&amp;gt; :type; _*
0
*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;*&lt;/code&gt; prefix on a tile is &lt;code&gt;%bctr&lt;/code&gt;, the same thing folded to a
constant (obviously a no-op here)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~zod/try=&amp;gt; **
0
~zod/try=&amp;gt; :type; **
0
*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;,&lt;/code&gt; prefix on a tile is &lt;code&gt;%bccm&lt;/code&gt;, ie, generate a function
producing the tile.  Let&amp;#39;s save one of our nouns and make it an
atom, using a clam.  Let&amp;#39;s try the clam on different things:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~zod/try=&amp;gt; =foo _*
~zod/try=&amp;gt; (,@ foo)
0
~zod/try=&amp;gt; :type; (,@ foo)
0
@
~zod/try=&amp;gt; :type; (,@ [5 5])
0
@
~zod/try=&amp;gt; :type; (,@ %foo)
7.303.014
@
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Alternately, we could check if our &lt;code&gt;*&lt;/code&gt; is a &lt;code&gt;@&lt;/code&gt; with &lt;code&gt;?=&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~zod/try=&amp;gt; ?=(@ foo)
%.y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Why is all this true?  Because the bunt of &lt;code&gt;*&lt;/code&gt; is the atom &lt;code&gt;0&lt;/code&gt;
with the type &lt;code&gt;%noun&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, if a tile appears where we expect a twig, the normal
tile-to-twig conversion is always &lt;code&gt;%bccm&lt;/code&gt;.  Ie, using a tile as a
twig generates a gate producing the icon.&lt;/p&gt;

&lt;h2&gt;The tiles&lt;/h2&gt;

&lt;p&gt;With a good general understanding of what a tile is for - we&amp;#39;ll
go back into the tiles we actually have:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  tile  
  $&amp;amp;  [p=tile q=tile]                     ::  ordered pair
  $%  [%axil p=base]                      ::  base type
      [%bark p=term q=tile]               ::  name
      [%bush p=tile q=tile]               ::  pair/tag
      [%fern p=[i=tile t=(list tile)]]    ::  plain selection
      [%herb p=twig]                      ::  function
      [%kelp p=[i=line t=(list line)]]    ::  tag selection
      [%leaf p=term q=@]                  ::  constant atom
      [%reed p=tile q=tile]               ::  atom/cell
      [%weed p=twig]                      ::  example
  ==                                      ::
++  line  ,[p=[%leaf p=odor q=@] q=tile]
++  base  ?([%atom p=odor] %noun %cell %bean %null)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Observe that the tile stems are no longer rune digraphs.  Rather,
a gardening metaphor appears to pertain.  Let&amp;#39;s work through
these one by one, showing both (regular) syntax and semantics.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;[%axil p=base]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;An &lt;code&gt;%axil&lt;/code&gt; is a simple built-in mechanism for a few basic
icons: an atom of any odor (&lt;code&gt;@odor&lt;/code&gt;, or just &lt;code&gt;@&lt;/code&gt; for the
odorless base atom); a noun (&lt;code&gt;*&lt;/code&gt;); a cell of nouns (&lt;code&gt;^&lt;/code&gt;); a
loobean &lt;code&gt;?&lt;/code&gt;; and null &lt;code&gt;~&lt;/code&gt;. &lt;/p&gt;

&lt;h3&gt;&lt;code&gt;[%leaf p=term q=@]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;%leaf&lt;/code&gt; is an atomic constant of value &lt;code&gt;q&lt;/code&gt; and odor &lt;code&gt;p&lt;/code&gt;.
Obviously its icon is a &lt;code&gt;%cube&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The syntax for a leaf is the same as the twig syntax, except that
&lt;code&gt;%&lt;/code&gt; is never required to generate a cube.  For instance, as a
twig, &lt;code&gt;7&lt;/code&gt; has a type of [%atom %ud]; &lt;code&gt;%7&lt;/code&gt; has a type of 
&lt;code&gt;[%cube 7 [%atom %ud]]&lt;/code&gt;.  But the icon of the leaf &lt;code&gt;7&lt;/code&gt; is,
again, &lt;code&gt;[%cube 7 [%atom %ud]]&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;[p=tile q=tile]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Tiles autocons, just like twigs - a cell of tiles is a tile of
a cell.  But we shouldn&amp;#39;t skip the differences too lightly.&lt;/p&gt;

&lt;p&gt;A cell of twigs is also a twig of a cell.  But in the cell of
twigs, the subject of either leg is the original subject.
Whereas when applying a tile in a whip or clam, the subject is
split in half for equally obvious reasons.  &lt;/p&gt;

&lt;p&gt;(Otherwise, how would &lt;code&gt;(,[@ @] [4 5])&lt;/code&gt; be &lt;code&gt;[4 5]&lt;/code&gt;?  Clearly, this
should be the same as &lt;code&gt;[(,@ 4) (,@ 5)]&lt;/code&gt;.  Clearly, it should not
be the same as &lt;code&gt;[(,@ [4 5]) (,@ [4 5])]&lt;/code&gt; - which would produce
merely &lt;code&gt;[0 0]&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;The irregular wide syntax for tile autocons is the same as the
syntax for twig autocons - eg, &lt;code&gt;[@ @]&lt;/code&gt;, a cell of atoms.  But
there is also a regular tall/wide tuple syntax, with &lt;code&gt;$:&lt;/code&gt;
(&lt;code&gt;buccol&lt;/code&gt;, &lt;code&gt;%bccl&lt;/code&gt;).  Thus instead of &lt;code&gt;[@ @]&lt;/code&gt; we could write:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$:  @
    @
==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;code&gt;[%bark p=term q=tile]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Wrap a name round a tile.  &lt;code&gt;a=*&lt;/code&gt; parses as &lt;code&gt;[%bark %a %noun]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is another case where the tile syntax matches the twig
syntax, but only in the irregular form.  The twig equivalent of
&lt;code&gt;%bark&lt;/code&gt; is of course &lt;code&gt;^=&lt;/code&gt; (&lt;code&gt;kettis&lt;/code&gt;, &lt;code&gt;%ktts&lt;/code&gt;).  But the tile is
&lt;code&gt;$=&lt;/code&gt; (&lt;code&gt;buctis&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$=  a
*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Obviously a silly syntactic arrangement.  But you can need it if
&lt;code&gt;q&lt;/code&gt; is really big.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;[%reed p=tile q=tile]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;%reed&lt;/code&gt; is a tile whose icon contains two kinds of nouns: atoms
of tile &lt;code&gt;p&lt;/code&gt; and cells of tile &lt;code&gt;q&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There is no irregular form of &lt;code&gt;%reed&lt;/code&gt;.  The regular form is:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$|  ~
    [@ @]
==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or in wide mode, of course, &lt;code&gt;$|(~ [@ @])&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;[%kelp p=[i=line t=(list line)]]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;kelp&lt;/code&gt; is the workhorse of tiles - it provides the most common
data structure in any language, the discriminated union.  &lt;/p&gt;

&lt;p&gt;In Hoon, the head (which must be a &lt;code&gt;leaf&lt;/code&gt;) is called the &lt;code&gt;stem&lt;/code&gt;.
The tail (which can be anything) is the &lt;code&gt;bulb&lt;/code&gt;.  Cases of a kelp
are known inevitably as &lt;code&gt;fronds&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;(Yes.  We&amp;#39;re aware that &amp;quot;kelp&amp;quot; is not properly a singular noun.
In Hoon - it is properly a singular noun.  And that&amp;#39;s that.  And 
oddly, it&amp;#39;s not that hard to run out of four-letter plants.)&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;[%bush p=tile q=tile]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;%bush&lt;/code&gt; is a tile in which there are two kinds of nouns: cells
whose head is a cell (tile &lt;code&gt;p&lt;/code&gt;) and cells whose head is an atom
(tile &lt;code&gt;q&lt;/code&gt;).  Its default value is the value of &lt;code&gt;q&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We don&amp;#39;t have to look very far to find a bush - &lt;code&gt;++tile&lt;/code&gt; is one,
as is &lt;code&gt;++twig&lt;/code&gt; and &lt;code&gt;++nock&lt;/code&gt;.  The rune is &lt;code&gt;$&amp;amp;&lt;/code&gt; (&lt;code&gt;bucpam&lt;/code&gt;).  See
&lt;code&gt;++tile&lt;/code&gt; above - &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;[p=tile q=tile]&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt; is the &lt;code&gt;$%&lt;/code&gt;.
There is no irregular form.&lt;/p&gt;

&lt;p&gt;What&amp;#39;s the use of a bush?  Often in a variety of data structures
we have something like autocons, in which forming a cell of two
instances has an obvious default semantics.  &lt;/p&gt;

&lt;p&gt;Sure, we could attach these semantics to an atom, and just use a
&lt;code&gt;%kelp&lt;/code&gt;.  In twigs, tiles, or nock formulas, we could have an
explicit &lt;em&gt;cons&lt;/em&gt; stem of some sort.  But it would be a bulky and
annoying pain in the butt as compared to autocons.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;[%fern p=[i=tile t=(list tile)]]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;fern&lt;/code&gt; is a non-empty list of cases; its icon is naturally
a &lt;code&gt;%fork&lt;/code&gt;.  The programmer is responsible for ensuring that the
cases are actually orthogonal (unlike with the structured forks,
&lt;code&gt;%bush&lt;/code&gt;, &lt;code&gt;%kelp&lt;/code&gt; and &lt;code&gt;%reed&lt;/code&gt;).  A good general practice is to use
ferns only with leaves (see below).&lt;/p&gt;

&lt;p&gt;For example, a fern that could be &lt;code&gt;%foo&lt;/code&gt; or &lt;code&gt;%bar&lt;/code&gt; has the
irregular form &lt;code&gt;?(%foo %bar)&lt;/code&gt;, or the regular form&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$?  %foo
    %bar
==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The default value is the first - in this case, &lt;code&gt;%foo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But wait. Why do we need these other selection tiles, &lt;code&gt;%bush&lt;/code&gt; and
&lt;code&gt;%reed&lt;/code&gt; and &lt;code&gt;%kelp&lt;/code&gt;, if we have &lt;code&gt;%fern&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;The answer is that tiles aren&amp;#39;t magic.  They are really just ways
of generating specific twigs that do useful things with nouns.
Suppose, for instance, you use a &lt;code&gt;%fern&lt;/code&gt; as a &lt;code&gt;%kelp&lt;/code&gt;.  You can
do this - but we may well generate more effective validation code
for a &lt;code&gt;%kelp&lt;/code&gt;, whose structure we understand how to search for.&lt;/p&gt;

&lt;p&gt;And even if were this not the case, anyone creating complex tiles
and icons should use one of these standard structures - simply
because it is never really worth varying from this set of
patterns, even if small structural efficiencies can be extracted.
Therefore, it&amp;#39;s worth telling both the compiler and the reader
exactly what the programmer is trying to do in each case.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;[%herb p=twig]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;You can write your own tile which is just a gate, accepting a
sample of &lt;code&gt;*&lt;/code&gt; and normalizing it as you choose.  If you use a
twig as a tile, it&amp;#39;s treated as an herb.&lt;/p&gt;

&lt;p&gt;For example, when we define a gate like &lt;code&gt;++base&lt;/code&gt;, as defined
above (remember that when we use a tile as a twig, we get the
clam, ie, the normalizing gate) &lt;code&gt;base&lt;/code&gt; is just an arm which
produces a gate.  Nothing has any idea that this gate is built
from a tile of its own.&lt;/p&gt;

&lt;p&gt;So when we parse &lt;code&gt;[p=base q=base]&lt;/code&gt; as a tile, the parser builds
the noun:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[[%bark %p %herb %cnzy %base] [%bark %q %herb %cnzy %base]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In other words, &lt;code&gt;base&lt;/code&gt; in &lt;code&gt;p=base&lt;/code&gt; is actually a &lt;em&gt;twig&lt;/em&gt;, but this
twig happens to produce a normalizing gate generated by clamming
a tile.  In time this will come to seem totally straightforward,
but don&amp;#39;t be surprised if it confuses you now.&lt;/p&gt;

&lt;p&gt;The important thing to remember about &lt;code&gt;%herb&lt;/code&gt; is that the actual
twig we provide will be applied when we whip or clam.  Hence,
arbitrary normalization and/or verification procedures may be
part of the herbaceous custom tile.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;[%weed p=twig]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;%weed&lt;/code&gt; is the lamest kind of tile - tile by example.  A &lt;code&gt;%weed&lt;/code&gt;
is defined by its example twig &lt;code&gt;p&lt;/code&gt;, which produces the icon.&lt;/p&gt;

&lt;p&gt;One limitation is obvious - it is essentially useless to whip or
clam for a &lt;code&gt;%weed&lt;/code&gt;.  Whipping or clamming on a &lt;code&gt;%weed&lt;/code&gt; simply
ignores the sample and reproduces the example - as does bunting,
of course.  However, &lt;code&gt;%weed&lt;/code&gt; remains quite useful.&lt;/p&gt;

&lt;p&gt;The irregular syntax for a &lt;code&gt;%weed&lt;/code&gt; is a &lt;code&gt;_&lt;/code&gt; prefix - for example,
to use a twig &lt;code&gt;foo&lt;/code&gt; as a &lt;code&gt;%weed&lt;/code&gt;, we write &lt;code&gt;_foo&lt;/code&gt;.  The regular
form is &lt;code&gt;$_&lt;/code&gt; (&lt;code&gt;buccab&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$_  foo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch8&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Gates&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/19/ch10&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Type Inference&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Chapter VIII (Gates)</title>
   <link href="http://urbit.org/doc/2013/11/18/ch8/"/>
   <updated>2013-11-18T00:00:00-08:00</updated>
   <id>http://urbit.org/doc/2013/11/18/ch8</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch7&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Hoon Computes&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch9&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Tiles&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;quot;Anyone who thinks he&amp;#39;s original is merely ignorant.&amp;quot;&lt;/em&gt;
&lt;strong&gt;(Nicolás Gómez Dávila)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It&amp;#39;s nice that we got decrement working in the last chapter.  But
we didn&amp;#39;t actually produce a decrement &lt;em&gt;function&lt;/em&gt;.  So, let&amp;#39;s do
that now.&lt;/p&gt;

&lt;h2&gt;Gates and &amp;quot;lambda&amp;quot;&lt;/h2&gt;

&lt;p&gt;While we can hardly stop you from saying &amp;quot;function,&amp;quot; the proper
Urbit terminology is &lt;code&gt;gate&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;A gate is a kind of core - you might remember our discussion in
chapter 4.  A core is&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[battery payload]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The battery is one or more formulas; the payload is any noun.  &lt;/p&gt;

&lt;p&gt;In a gate, there is exactly one arm - whose name is &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;buc&lt;/code&gt; or
&lt;code&gt;blip&lt;/code&gt; - ie, nothing.  One arm, one twig, one formula.  Moreover,
the payload is always a cell, arbitrarily labeled &lt;code&gt;sample&lt;/code&gt; and
&lt;code&gt;context&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;So - to combine several ways of deconstructing a noun - a gate
looks like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;           glus   gras
          lusgal lusgar
            +&amp;lt;     +&amp;gt;
[formula [sample context]]
    -          +
   hep        lus
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Does this remind you of anything?  I hope not!  Unfortunately
some readers may be previously familiar with legacy functional
languages from the late 20th century.  Legacy?  Perhaps this is a
little sharp - let&amp;#39;s say &amp;quot;classical.&amp;quot;&lt;/p&gt;

&lt;p&gt;In classical FP, something quite like a Hoon gate is known as a
&amp;quot;lambda.&amp;quot; We try not to use this term, really.  Hoon is obviously
not based on the lambda calculus, and it&amp;#39;s not nice to define
other people&amp;#39;s words for them.  (This is also why we don&amp;#39;t say
&amp;quot;monad.&amp;quot;)  But we may slip up sometimes and that&amp;#39;s okay.  (We may
also get caught with &amp;quot;closure&amp;quot; or even &amp;quot;continuation.&amp;quot;) &lt;/p&gt;

&lt;p&gt;But there is a big difference: in classical FP, &amp;quot;lambda&amp;quot; is a
fundamental semantic primitive.  Since these are &lt;em&gt;functional&lt;/em&gt;
languages after all, it makes sense that defining and calling
functions would be fundamental primitives.  &lt;/p&gt;

&lt;p&gt;But gates - Hoon&amp;#39;s equivalent of functions - are no more than a
design pattern: a convention, and a relatively funky convention
at that.  Plus some sugary macros that make things convenient.&lt;/p&gt;

&lt;p&gt;Since Hoon&amp;#39;s primitives are actually primitive (it doesn&amp;#39;t get
much more primitive than Nock), we can combine them to produce
not only classic, function-oriented FP, but also a broader garden
of funky patterns at the same complexity level as function
calling.  But different from function calling.  What?  We&amp;#39;ll see
some of these patterns in a bit.&lt;/p&gt;

&lt;h3&gt;We make a gate&lt;/h3&gt;

&lt;p&gt;Our goal this time is not just to build decrement - it&amp;#39;s to build
decrement &lt;em&gt;right&lt;/em&gt;.  That is, as a decrement function - a gate.
If this is called &lt;code&gt;deq&lt;/code&gt; (there already being a perfectly usable 
&lt;code&gt;dec&lt;/code&gt;) and we want decrementing &lt;code&gt;a&lt;/code&gt; to look like Lisp:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;(deq a)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then we can expect our program to look something like &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:             ::  To write a trivial Hoon program
|=  *          ::
|=  [a=@ ~]    ::  For educational purposes only
:_  ~  :_  ~   ::
:-  %$         ::  Preserve this mysterious boilerplate square
!&amp;gt;             ::
:::::::::::::::::  Produce a value below
=&amp;gt;  XXXXX      ::  some twig or other
(deq a)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This XXXXX twig, whatever it is, must extend the subject to
contain a core which includes an arm which produces our gate.&lt;/p&gt;

&lt;p&gt;Extend the subject to contain a core which includes an arm which
produces our gate?  Sure:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;gt;  |%
    ++  deq
      =+  x=0
      |.  =+  y=0
          |-  ?:  =(x +(y))
                y
              $(y +(y))
    --
(deq a)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or more conveniently:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;lt;  (deq a)
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Does this work?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~zod/try/25/bin/hec/hoon
~zod/try=&amp;gt; :hec 42
41
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But this doesn&amp;#39;t mean we understand it.  &lt;/p&gt;

&lt;p&gt;Sure, we read the last chapter.  So we understand how and why
&lt;code&gt;|%&lt;/code&gt; turned into &lt;code&gt;|.&lt;/code&gt;, which then turned into &lt;code&gt;|-&lt;/code&gt;.  The loop.
But this strange beast seems to contain... &lt;em&gt;three&lt;/em&gt; cores? &lt;/p&gt;

&lt;h3&gt;We understand a gate&lt;/h3&gt;

&lt;p&gt;Of course we need three nested cores.  Actually, we have a lot
more than three nested cores, because the subject we are getting
for the application contains all of &lt;code&gt;zuse.hoon&lt;/code&gt; and &lt;code&gt;hoon.hoon&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A stack of cores in which the core below is the context of the
one above, all the way down to the innermost core whose payload
is a simple constant (for &lt;code&gt;hoon.hoon&lt;/code&gt;, always the Kelvin version)
is called, for obvious reasons, a &lt;code&gt;reef&lt;/code&gt;.  With our three cores,
we are adding no more than a few decorative polyps to our reef.&lt;/p&gt;

&lt;p&gt;For example, we can just as well use the standard decrement,
&lt;code&gt;dec&lt;/code&gt; - it&amp;#39;s in there too:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;lt;  (dec a)
|%
++  deq
  =+  x=0
  |.  
  =+  y=0
  |-  
  ?:  =(x +(y))
    y
  $(y +(y))
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(We&amp;#39;ve used a more conservative indentation here - uglier and
less compact, but arguably clearer.)&lt;/p&gt;

&lt;p&gt;We define &lt;code&gt;deq&lt;/code&gt;, but we seem to be able to just call &lt;code&gt;dec&lt;/code&gt;.  Why?
Because we read past cores which don&amp;#39;t bind the arm we&amp;#39;re looking
for, we can read all the way to the deepest layer in the Hoon 164
reef - which contains the official, original &lt;code&gt;dec&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(It remains important not to profoundly abuse this magic power.
Every layer of core you add, of course, puts you farther from
some of the gates you want to use.  A smart interpreter can
smooth over this issue a little, but smart isn&amp;#39;t free either.)&lt;/p&gt;

&lt;p&gt;Thus, it should be perfectly clear what the three &lt;code&gt;bar&lt;/code&gt; runes -
implying three cores - mean.  First, we have the &lt;code&gt;|%&lt;/code&gt; which
contains &lt;code&gt;++deq&lt;/code&gt;.  (When referring to an arm in informal text,
we use this syntax, though the actual language of course requires
a double space - when searching in a file, &lt;code&gt;++&amp;ensp;&amp;ensp;arm&lt;/code&gt; will always
find the definition of &lt;code&gt;arm&lt;/code&gt; and nothing else.)&lt;/p&gt;

&lt;p&gt;This outer core defines &lt;em&gt;the library our decrement gate is in&lt;/em&gt;.
Actually, &amp;quot;library&amp;quot; (or &lt;code&gt;book&lt;/code&gt; - defined as a core which
contains only code and constant data) is not quite the right
terminology here.  Even though we don&amp;#39;t use it and it shouldn&amp;#39;t
in fact be there, the payload of this core contains dynamic
information such as &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In actual fact our nascent integer math library  is really an
&amp;quot;object&amp;quot; or &lt;code&gt;cart&lt;/code&gt; - ie, a core containing dynamic state.  This
is just wrong and we&amp;#39;ll see later on how to do it right.&lt;/p&gt;

&lt;p&gt;As in every core, the subject of every arm is the core itself.
Naturally, the &lt;code&gt;|%&lt;/code&gt; twig uses its own subject as the payload,
creating the familiar reef effect as the stack of cores piles up.&lt;/p&gt;

&lt;p&gt;And this library is the &lt;code&gt;context&lt;/code&gt; (or &lt;code&gt;+&amp;gt;&lt;/code&gt;, &lt;code&gt;gras&lt;/code&gt;) of our gate.
Thus, the twig in the gate can use anything in the library - of
course as needed.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;sample&lt;/code&gt; (or &lt;code&gt;+&amp;lt;&lt;/code&gt;, &lt;code&gt;glus&lt;/code&gt;) of our gate is simply any default
noun for the type we want to compute on.  Remember, of course,
that the whole point of gates is that we change the sample, then
compute the formula.  Hoon is a typed language, so the sample can
be safely replaced by any noun in the same type.&lt;/p&gt;

&lt;p&gt;Within &lt;code&gt;=+&lt;/code&gt;, &lt;code&gt;tislus&lt;/code&gt;, the old subject becomes the context, and
the new subject adds the sample &lt;code&gt;^=(b 0)&lt;/code&gt;.  This pair of sample
and context then becomes the payload within &lt;code&gt;|.&lt;/code&gt;  Hence, we build
a gate.&lt;/p&gt;

&lt;p&gt;And then, within this gate - the third core is the decrement loop
itself, as we built it in the last chapter.  Note that if
decrement did not need a counter variable or other incremental
state, we would need only two cores - we could recurse through
the decrement gate itself.  We&amp;#39;ll see this in a little bit.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s eschew synthetic runes and show the three cores as they
really are:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;lt;  (deq a)
|%
++  deq
  =+  x=0
  |%  
  ++  $
    =+  y=0
    =&amp;lt;  $
    |%  
    ++  $
      ?:  =(x +(y))
        y
      $(y +(y))
    --
  --
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On the other hand, if we don&amp;#39;t mind synthetics and lots of
parentheses, our decrement gate can also be a one-liner.  This is
perfectly legitimate Hoon style:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|%  ++  deq  =+(x=0 |.(=+(y=0 |-(?:(=(x +(y)) y $(y +(y)))))))
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;We call a gate&lt;/h3&gt;

&lt;p&gt;Note that we&amp;#39;ve still totally failed to explain &lt;code&gt;(deq a)&lt;/code&gt;.  This
is obviously an irregular form.  Let&amp;#39;s try to turn it back into
natural hoons, and figure out what it&amp;#39;s doing.&lt;/p&gt;

&lt;p&gt;We know that &lt;code&gt;deq&lt;/code&gt; builds a gate.  We already know how to change
the sample, &lt;code&gt;+&amp;lt;&lt;/code&gt; or &lt;code&gt;glus&lt;/code&gt;, in that gate.  So let&amp;#39;s drag it out 
and do it the ugly way:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;lt;  =+  foo=deq             ::  create the gate
    =+  bar=foo(+&amp;lt; a)       ::  replace its sample
    $.bar                   ::  invoke the gate
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Does this work?  It&amp;#39;s always nice to check...&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~zod/try/28/bin/hec/hoon
~zod/try=&amp;gt; :hec 42
41
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We don&amp;#39;t actually need a separate &lt;code&gt;bar&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;lt;  =+  foo=deq             ::  create the gate
    $.foo(+&amp;lt; a)             ::  replace the sample and invoke
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But what we&amp;#39;d actually like to be able to get away with is...
something that &lt;em&gt;won&amp;#39;t&lt;/em&gt; work - but that looks like it might:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;lt;  $.deq(+&amp;lt; a)             ::  create, replace and invoke
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We try it and - doh!&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~zod/try/31/bin/hec/hoon
~zod/try=&amp;gt; :hec 42
! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:&amp;lt;[2 1].[23 3]&amp;gt;
! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:&amp;lt;[3 1].[23 3]&amp;gt;
! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:&amp;lt;[4 1].[23 3]&amp;gt;
! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:&amp;lt;[4 8].[23 3]&amp;gt;
! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:&amp;lt;[5 1].[23 3]&amp;gt;
! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:&amp;lt;[6 1].[23 3]&amp;gt;
! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:&amp;lt;[8 1].[23 3]&amp;gt;
! /~zod/hec/bin/~2014.1.13..22.55.29..8975/try:&amp;lt;[8 5].[8 16]&amp;gt;
! type-fail
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(This means we had a type failure between columns 5 and 16 of line
8, by the way.  More on troubleshooting errors later.)&lt;/p&gt;

&lt;p&gt;Because when we wrote &lt;code&gt;deq(+&amp;lt; a)&lt;/code&gt;, we didn&amp;#39;t mean: compute &lt;code&gt;deq&lt;/code&gt;,
then modify the &lt;code&gt;+&amp;lt;&lt;/code&gt; of its result to be &lt;code&gt;a&lt;/code&gt;.  We meant: compute
&lt;code&gt;deq&lt;/code&gt;, with the &lt;code&gt;+&amp;lt;&lt;/code&gt; of the core that contains &lt;code&gt;deq&lt;/code&gt; - ie, with
the &lt;code&gt;+&amp;lt;&lt;/code&gt; of the &lt;em&gt;library&lt;/em&gt; - changed to &lt;code&gt;a&lt;/code&gt;.  Needless to say,
that&amp;#39;s not what we want at all.&lt;/p&gt;

&lt;p&gt;The change in &lt;code&gt;%=&lt;/code&gt; - remember that &lt;code&gt;deq(+&amp;lt; a)&lt;/code&gt; is a short form
for &lt;code&gt;%=(deq +&amp;lt; a)&lt;/code&gt; - is always &lt;em&gt;before&lt;/em&gt; the invocation.
So we can&amp;#39;t do this as easily as it looks like we should be able
to do it - because we can&amp;#39;t edit the gate until we build it.&lt;/p&gt;

&lt;p&gt;Fortunately, we have a synthetic hoon to do this.  What hoon is
(deq a), anyway?  It&amp;#39;s &lt;code&gt;%-&lt;/code&gt;, &lt;code&gt;cenhep&lt;/code&gt;, &lt;code&gt;%cnhp&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;lt;  %-  deq
    a
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s look at the definition of &lt;code&gt;%cnhp&lt;/code&gt;, our function caller.
Here are the relevant clips from &lt;code&gt;hoon.hoon&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  twig
  |%  [%cnhp p=twig q=tusk]
  ==

++  tusk  (list twig)

++  open
  ^-  twig
  ?-    gen
      [%cnhp *]
    ?~(q.gen [%tsgr p.gen [%cnzy %$]] [%cncl p.gen [%cltr q.gen]])
  ::
      [%cncl *]  
    [%cnsg [%$ ~] p.gen q.gen]
  ::
      [%cnsg *]  
    [%cntr p.gen q.gen [[[[%&amp;amp; 6] ~] r.gen] ~]]
  ::
      [%cntr *]
    :+  %tsls
      q.gen
    :+  %cnts
      (weld p.gen `wing`[[~ 2] ~])
    (turn r.gen |=([p=wing q=twig] [p [%tsgr [~ 3] q]]))
  ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You&amp;#39;re not expected to understand this.  At least, not yet.  But
we see that &lt;code&gt;%-&lt;/code&gt;, so far from being a primitive, actually is a
special case of &lt;code&gt;%:&lt;/code&gt;, which is a special case of &lt;code&gt;%~&lt;/code&gt;, which is a
special case of &lt;code&gt;%*&lt;/code&gt;, which seems to do... something.&lt;/p&gt;

&lt;p&gt;Which probably makes you think &lt;code&gt;%cnhp&lt;/code&gt; is insanely complicated.
Actually it just shows what an interesting family of things
which are like function calls, but which are not function calls,
we have here in Hoon.  Defining &lt;code&gt;%cnhp&lt;/code&gt; this way saves code, but
it doesn&amp;#39;t help us understand the humble function call.&lt;/p&gt;

&lt;p&gt;If we just wanted %cnhp to be simple, we&amp;#39;d define it this way:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  twig
  |%  [%cnhp p=twig q=twig]
  ==

++  open
  ^-  twig
  ?-    gen
      [%cnhp *]
    :+  %tsls  q.gen
    :+  %tsgl  [%cnzy %$]
    [%cnhp [[%&amp;amp; 2] ~] [[[%&amp;amp; 6] ~] [%tsgl [~ 3] p.gen]] ~]
  ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This also is not terribly readable.  Let&amp;#39;s translate it into the
code that we&amp;#39;d write if we were writing this macro out by hand:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;lt;  =+  deq               ::  create the gate
    $.-(+&amp;lt; =&amp;gt;(+ a))       ::  replace the sample and invoke
|%
++  deq
  =+  x=0
  |.  =+  y=0
      |-  ?:  =(x +(y))
            y
          $(y +(y))
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Compare this to the working example above.  The main difference
is that this is what a Lisp fan would call a &amp;quot;hygienic macro.&amp;quot;
It does not create private symbols of its own, or if it does they
are not visible to the programmer.  For instance, when we write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  deq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;instead of&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  foo=deq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we see how wrong it is to think of the latter as &amp;quot;declaring a
variable &lt;code&gt;foo&lt;/code&gt; and assigning it to &lt;code&gt;deq&lt;/code&gt;.&amp;quot;  Actually, we have no
need within a synthetic hoon to bind a name.  After the &lt;code&gt;=+&lt;/code&gt;, we
can reach the gate with just &lt;code&gt;-&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;But we cannot simply replace the sample with &lt;code&gt;a&lt;/code&gt; - because the
programmer who wrote &lt;code&gt;a&lt;/code&gt; meant to write a twig against the
original subject, not against the cell of gate and subject.&lt;/p&gt;

&lt;p&gt;Fortunately, &lt;code&gt;=&amp;gt;(+ a)&lt;/code&gt; gets us our original subject back - and
&lt;code&gt;%-&lt;/code&gt; works exactly as if it was a natural hoon.  That&amp;#39;s hygiene.&lt;/p&gt;

&lt;h3&gt;Sequel hook&lt;/h3&gt;

&lt;p&gt;So is this the right way to write decrement (assuming we didn&amp;#39;t
already have decrement)?  No - there is actually a hoon designed
specifically for building gates.  &lt;/p&gt;

&lt;p&gt;The right code (which we saw earlier) is:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;lt;  (deq a)
|%
++  deq
  |=  x=@
  =|  y=@
  |-  ?:  =(x +(y))
        y
      $(y +(y))
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But this requires us to understand &lt;code&gt;x=@&lt;/code&gt; - which &lt;em&gt;isn&amp;#39;t even a
twig&lt;/em&gt;.  Rather, it&amp;#39;s something else, called a &lt;code&gt;tile&lt;/code&gt;.  We&amp;#39;ll make
friends with the tiles in the next chapter.&lt;/p&gt;

&lt;p&gt;For those with classic FP experience, it&amp;#39;s very tempting to read
&lt;code&gt;|=&lt;/code&gt; (&lt;code&gt;bartis&lt;/code&gt;, &lt;code&gt;%brts&lt;/code&gt;) as &amp;quot;lambda.&amp;quot;  I hope it&amp;#39;s clear by now
that the difference between Hoon and classic FP languages is like
the difference between a bat and a bird.  Both have wings and use
them to fly, but below that level everything is different.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch7&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Hoon Computes&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch9&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Tiles&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Chapter VII (Hoon Computes)</title>
   <link href="http://urbit.org/doc/2013/11/18/ch7/"/>
   <updated>2013-11-18T00:00:00-08:00</updated>
   <id>http://urbit.org/doc/2013/11/18/ch7</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch6&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Moar Hoon Types&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch8&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Gates&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;quot;I&amp;#39;ve only been in love with a beer bottle and a mirror.&amp;quot;&lt;/em&gt;
&lt;strong&gt;(Sid Vicious)&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;Syntax&lt;/h2&gt;

&lt;p&gt;Is Hoon actually an improvement on Nock?  The jury holds out.
Here is our old decrement function, from the Nock battery:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8
  [1 0]
  [ 8
    [ 1
      [ 6
        [5 [4 0 6] [0 30]]
        [0 6]
        [9 2 [0 2] [4 0 6] [0 7]]
      ]
    ]
    [9 2 0 1]
  ]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This clearly it is not for the little boys and girls.  But wait -
is Hoon any less formidable?  The equivalent Hoon twig:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  a=@
=|  b=@
|-  ?:  =(a +(b))
      b
    $(b +(b))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Whaa?  We can also write the exact same decrement as:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=(a=@ =|(b=@ |-(?:(=(a +(b)) b $(b +(b))))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;for instance:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; (|=(a=@ =|(b=@ |-(?:(=(a +(b)) b $(b +(b)))))) 42)
41
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or even more cryptically, &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; %.(42 |=(a=@ =|(b=@ |-(?:(=(a +(b)) b $(b +(b)))))))
41
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And I showed this to my daughter, who ran away in tears.  Dear
reader, I hope you&amp;#39;re not tempted to do the same.&lt;/p&gt;

&lt;p&gt;Hoon actually is easy!  It&amp;#39;s much easier than Nock.  Nock really
isn&amp;#39;t that hard itself, unless you want to do something useful
with it.  But to learn Hoon, you just have to accept that it&amp;#39;s
really quite orthogonal to any or all of those &lt;em&gt;20th-century&lt;/em&gt;
languages you knew already.  Even the functional ones, mostly.
If anything, this knowledge makes it harder to learn Hoon.&lt;/p&gt;

&lt;p&gt;Our mutual hope is that by the time you do know Hoon, you will
simply be able to &lt;em&gt;see&lt;/em&gt; a twig like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  a=@
=|  b=@
|-  ?:  =(a +(b))
      b
    $(b +(b))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and, far from merely able to follow this code, &lt;em&gt;actually observe
in your mind&amp;#39;s eye the function itself&lt;/em&gt; - not unlike Keanu with
kung fu.  You will simply look at this strange collection of
squiggles and &lt;em&gt;see decrement&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;(Our feeling is that the use of reserved words in most languages,
by instead activating the verbal lobes, disrupts this sense of
directly, or at least visually, perceiving the program itself.
If you object that this sounds too much like Science, Science
implies testing hypotheses whereas we generally just wing it.)&lt;/p&gt;

&lt;p&gt;Think of learning Hoon as learning to program all over again.  If
nothing else, it&amp;#39;s a sort of eccentric adventure sport.  Or even
a mystery - can a language be esoteric, yet useful?  Click here
to find out more.&lt;/p&gt;

&lt;h3&gt;Glyphs&lt;/h3&gt;

&lt;p&gt;It&amp;#39;s actually worse than that - learning Hoon is learning to
&lt;em&gt;read&lt;/em&gt; all over again.  Again, Hoon is a reserved-word-free
language - any text in the program is part of the program.&lt;/p&gt;

&lt;p&gt;We use so many of these ASCII glyphs that we like to be able
to read them out loud.  A language is meant to be &lt;em&gt;said&lt;/em&gt;.  The
squiggles have conventional names, sort of, some of them easy to
say, others not so much.  So we&amp;#39;ve renamed them:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ace  space      gal  &amp;lt;          per  )
bar  |          gar  &amp;gt;          sel  [
bas  \          hax  #          sem  ;
buc  $          hep  -          ser  ]
cab  _          kel  {          sig  ~
cen  %          ker  }          soq  &amp;#39;
col  :          ket  ^          tar  *
com  ,          lus  +          tec  `
doq  &amp;quot;          pam  &amp;amp;          tis  =
dot  .          pat  @          wut  ?
fas  /          pel  (          zap  !
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You just have to memorize these names.  Sorry.  We accept
that they are vile, barbaric and loathsome.  So is life.&lt;/p&gt;

&lt;h3&gt;Runes&lt;/h3&gt;

&lt;p&gt;But is this at least enough symbols?  Alas, nowhere near.
ASCII&amp;#39;s glyph supply is not the greatest, but we can make all the
squiggles we need by forming digraphs, or &lt;em&gt;runes&lt;/em&gt;.  For example:
&lt;code&gt;bartis&lt;/code&gt;, ie, &lt;code&gt;|=&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;To pronounce a rune, concatenate the glyph names, stressing the
first syllable and softening the second vowel into a &amp;quot;schwa.&amp;quot;
Hence, to say &lt;code&gt;~.&lt;/code&gt;, say &amp;quot;sigdot.&amp;quot;  To say &lt;code&gt;|=&lt;/code&gt;, say &amp;quot;bartis.&amp;quot;
Which has an inevitable tendency to turn into &amp;quot;barts&amp;quot; - a sin
to be encouraged.  In any language actually spoken by actual
humans, benign indolence soon rounds off any rough edges.&lt;/p&gt;

&lt;p&gt;There are a few runes with irregular special pronunciations:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;--    hephep    phep    
+-    lushep    slep
++    luslus    slus
==    tistis    stet
+&amp;lt;    lusgal    glus
+&amp;gt;    lusgar    gras
-&amp;lt;    hepgal    gelp
-&amp;gt;    hepgar    garp     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s look at that decrement twig again:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  a=@
=|  b=@
|-  ?:  =(a +(b))
      b
    $(b +(b))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we had to read this twig, omitting the spaces (which only a
real purist would pronounce), we&amp;#39;d say: &amp;quot;bartis A is pat tisbar B
is pat barhep wutcol tis pel A lus pel B perper B bucpel B luspel B
perper.&amp;quot; The authorities would then arrive, and drag us out in a
big net. Definitely don&amp;#39;t do this at the airport.&lt;/p&gt;

&lt;p&gt;Hoon has almost 90 digraphic runes.  Worse, &amp;quot;Hoon runes&amp;quot; are
inevitably shortened to &amp;quot;hoons&amp;quot; - a ridiculous non-English word
due originally to Wallace Stevens, which also has the unique
property of reducing Australians to convulsions.&lt;/p&gt;

&lt;p&gt;None of this should scare you.  First, 90 symbols is not a lot
compared to, say, Chinese.  Second, hoons are easier than you&amp;#39;d
expect to organize in your head, because the choice of glyph is
not random.  Third, no one lives in Australia and nobody cares.&lt;/p&gt;

&lt;p&gt;The second glyph in a hoon means little or nothing, but the first
defines a rough semantic category.   These categories are:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|  bar    core construction
$  buc    tiles and tiling
%  cen    invocations
:  col    tuples
.  dot    nock operators
^  ket    type conversions
;  sem    miscellaneous macros
~  sig    hints
=  tis    compositions
?  wut    conditionals, booleans, tests
!  zap    special operations
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Regular forms&lt;/h3&gt;

&lt;p&gt;Like natural languages, Hoon wraps a blanket of funky, irregular,
easy-to-type abbreviations around a comforting but verbose
regular core.  Let&amp;#39;s explain the regular core first.&lt;/p&gt;

&lt;p&gt;Consider a very simple twig in completely regular form:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?:  &amp;amp;
  47
52
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We observe the rune &lt;code&gt;?:&lt;/code&gt;, which happens to mean the same thing it
means in C.  In C, though, we don&amp;#39;t call it &lt;code&gt;wutcol&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(In case you don&amp;#39;t remember from chapter 5, &lt;code&gt;&amp;amp;&lt;/code&gt; just means &lt;code&gt;yes&lt;/code&gt;, 
ie, &lt;code&gt;@f&lt;/code&gt;0 in our loobean logic.  (&lt;code&gt;|&lt;/code&gt; is 1.)  So this twig just
produces &lt;code&gt;47&lt;/code&gt;, not that it matters.)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%wutcol&lt;/code&gt; as a noun has a problem - it doesn&amp;#39;t fit in 32 bits.
Efficiency is important to us, so we disemvowel: &lt;code&gt;%wtcl&lt;/code&gt;.  We
can find this defined in &lt;code&gt;hoon.hoon&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[%wtcl p=twig q=twig r=twig]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;?:&lt;/code&gt; has three legs: the test, the yes case, and the no
case.  Again, as in C.  But why do we write it in this strange
triangular indentation?&lt;/p&gt;

&lt;h3&gt;Tall forms&lt;/h3&gt;

&lt;p&gt;When all is said and done, the programmer is formatting a big
wall of text.  This canvas has a curious but essential property -
it is indefinitely tall, but finitely wide.  We strongly
encourage an 80-column standard.&lt;/p&gt;

&lt;p&gt;So the programmer&amp;#39;s task as a visual designer is to persuade her
code to flow &lt;em&gt;down&lt;/em&gt;, not &lt;em&gt;across&lt;/em&gt;.  The usual way to lay out a
tree which does not fit on one line is to indent the subtrees
and enclose them in parens, brackets or braces.  Which might look
like this (&lt;em&gt;not&lt;/em&gt; Hoon syntax):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?:  {
  &amp;amp;
  47
  52
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hoon, like other functional languages, has very deep expression
trees.  In this simple, classic syntax model, a functional
language develops huge piles of closing parens at the end of
large blocks, which is manageable but ugly.  Less manageably, as
each subtree is indented to the right, the width of the text
window bounds the depth of the expression tree.&lt;/p&gt;

&lt;p&gt;Other languages skip the braces and parse whitespace, using
indentation to express tree depth.  This actually is valid (but
ugly) Hoon:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?:
  &amp;amp;
  47
  52
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This gets rid of the terminator problem, but keeps the width
problem.  And parsing whitespace is horrible.  Whitespace in Hoon
is not significant, though its presence or absence is.  (Note
also that hard TAB characters are &lt;em&gt;zutiefst verboten&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Hoon notices a couple of things about this problem.  First, most
Hoon twigs have small constant fanout.  A parser shouldn&amp;#39;t need
either significant whitespace or a terminator to figure out how
many twigs follow &lt;code&gt;?:&lt;/code&gt; - the answer is always 3.&lt;/p&gt;

&lt;p&gt;Second, our goal is to descend into a deep tree without losing
right margin.  With the &lt;em&gt;backstep&lt;/em&gt; pattern&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?:  &amp;amp;
  47
52
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  a=3
b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we step two spaces backward at each subtwig, till the last one is
at the same indentation as its parent.&lt;/p&gt;

&lt;p&gt;This preserves your right margin in one and only one case - where
the bottom twig is the heaviest.  For example, if we write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?:  &amp;amp;
  47
?:  |
  52
?:  &amp;amp;
  97
=+  35
b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we see a tree that flows neatly down the screen.  It&amp;#39;s obviously
much nicer than, say (&lt;em&gt;not&lt;/em&gt; Hoon syntax):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?:  {
  &amp;amp;
  47
  ?:  {
    |
    52
    ?:  {
      &amp;amp;
      97
      =+  {
        35
        b
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or any similar abortion.  But its downward flow depends on the
coincidence of the bottom twig being the heavy one:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?:  &amp;amp;
  ?:  |
    52
  ?:  &amp;amp;
    97
  =+  35
  b
47
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To handle this, Hoon has a reasonable selection of reverse hoons,
which have the same semantics but inverse order.  For instance,
if &lt;code&gt;?:&lt;/code&gt; is &amp;quot;if,&amp;quot; &lt;code&gt;?.&lt;/code&gt; (&lt;code&gt;wutdot&lt;/code&gt;) is &amp;quot;unless&amp;quot;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?.  &amp;amp;
  47
?:  |
  52
?:  &amp;amp;
  97
=+  35
b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Wide forms&lt;/h3&gt;

&lt;p&gt;Observe that in the tall syntax, there are always at least &lt;em&gt;two&lt;/em&gt;
spaces (or one newline) between tokens.  Other than this, nothing
requires anything to be tall.  For instance, it is normal and
only slightly aggressive to write:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?.  &amp;amp;  47
?:  |  52
?:  &amp;amp;  97
=+  35
b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But we could even go so far as:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?.  &amp;amp;  47  ?:  |  52  ?:  &amp;amp;  97  =+  35  b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Few would find this readable, which is why Hoon also has a &lt;em&gt;wide&lt;/em&gt;
syntax:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;?.(&amp;amp; 47 ?:(| 52 ?:(&amp;amp; 97 =+(35 b))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On a single line, the parentheses - while a parser could get away
with skipping them - are needed to actually read the expression.
The hoon attaches directly to the left paren (&lt;code&gt;pel&lt;/code&gt;), and a
double space or a newline is a syntax error.&lt;/p&gt;

&lt;p&gt;The semantics of tall and wide syntax are identical, of course.
The choice is entirely up to the programmer.  Some languages can
be formatted automatically - turning an abstract syntax tree into
a tall, handsome Hoon file is an art form.  We won&amp;#39;t say a
program could never do it - but it&amp;#39;d be work.&lt;/p&gt;

&lt;p&gt;Wide forms are also nice because our immature and incomplete
command-line shell can&amp;#39;t process multi-line input.&lt;/p&gt;

&lt;h3&gt;Irregular forms&lt;/h3&gt;

&lt;p&gt;For a very large set of primitives, neither tall nor wide form is
tight enough.  If you go to &lt;code&gt;++scat&lt;/code&gt; in &lt;code&gt;hoon.hoon&lt;/code&gt;, you can see
them all, organized by initial character.&lt;/p&gt;

&lt;p&gt;This isn&amp;#39;t the place to go over the irregular forms directly -
we&amp;#39;ll introduce them when we talk about individual runes, or
when we run into them and we can&amp;#39;t go around.&lt;/p&gt;

&lt;h2&gt;Semantics&lt;/h2&gt;

&lt;p&gt;We&amp;#39;re finally ready to write our first Hoon program.  But...&lt;/p&gt;

&lt;h3&gt;A new testbed&lt;/h3&gt;

&lt;p&gt;Since we&amp;#39;re going to have to write multi-line Hoon programs, the
command line is no longer enough.  We&amp;#39;ll need another toy
testbed, this one in &lt;code&gt;urb/waclux-tomwyc/try/bin/toy.hoon&lt;/code&gt;.
Its text should be:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:             ::  To write a trivial Hoon program
|=  *          ::
|=  [x=@ ~]    ::  For educational purposes only
:_  ~  :_  ~   ::
:-  %$         ::  Preserve this mysterious boilerplate square
!&amp;gt;             ::
:::::::::::::::::  Produce a value below
(add 2 x)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Test that it works: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :toy 3
5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Copy it into &lt;code&gt;try/bin/hec.hoon&lt;/code&gt;, where we&amp;#39;ll write our Hoon decrement.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;+ /~waclux-tomwyc/try/7/bin/hec/hoon
~waclux-tomwyc/try=&amp;gt; :hec 3
5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Replace &lt;code&gt;(add 2 x)&lt;/code&gt; with our decrement twig:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;%.  x
|=  a=@
=|  b=@
|-  ?:  =(a +(b))
      b
    $(b +(b))

~waclux-tomwyc/try=&amp;gt; :hec 42
41
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It works.  But, why does it work?  What are these twigs, anyway?&lt;/p&gt;

&lt;h3&gt;Twigs&lt;/h3&gt;

&lt;p&gt;We have already defined the noble twig - in chapter 5.  Let&amp;#39;s
just &lt;em&gt;reprint&lt;/em&gt; that text - odds are you&amp;#39;ve forgotten it already.&lt;/p&gt;

&lt;p&gt;When we parse a Hoon expression, file, etc, we produce what we
call a &lt;code&gt;twig&lt;/code&gt;, which (if you know the CS jargon) is an AST.  A
twig is a noun that&amp;#39;s converted into a Nock formula, with
the assistance of a type which describes the subject of the
formula:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[subject-type twig] =&amp;gt; formula
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But actually this isn&amp;#39;t quite right, because Hoon does something
called &amp;quot;type inference.&amp;quot;  When we have a type that describes the
subject for the formula we&amp;#39;re trying to generate, as we generate
that formula we want to also generate a type for the product of
that formula on that subject.  So our compiler computes:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[subject-type twig] =&amp;gt; [product-type formula]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As long as &lt;code&gt;subject-type&lt;/code&gt; is a correct description of some
subject, you can take any twig and compile it against
&lt;code&gt;subject-type&lt;/code&gt;, producing a &lt;code&gt;formula&lt;/code&gt; such that &lt;code&gt;*(subject
formula)&lt;/code&gt; is a product correctly described by &lt;code&gt;product-type&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Actually, this works well enough that in Hoon there is no direct
syntax for defining or declaring a type.  There is only a syntax
for constructing twigs.  Types are exclusively formed by
inference.&lt;/p&gt;

&lt;h3&gt;Natural and synthetic hoons&lt;/h3&gt;

&lt;p&gt;Fortunately, most kinds of hoons are &lt;em&gt;synthetic&lt;/em&gt; hoons - in a word,
macros.  Synthetic hoons evaluate by reducing to other twigs,
eventually down to direct ones.  Hoon could do without all its
synthetic hoons, though it would be awfully cumbersome.&lt;/p&gt;

&lt;p&gt;For example, as we&amp;#39;ve seen with &lt;code&gt;?:&lt;/code&gt; and &lt;code&gt;?.&lt;/code&gt;, when we compile
&lt;code&gt;wutdot&lt;/code&gt; - &lt;code&gt;[%wtdt p q r]&lt;/code&gt; - we turn it into &lt;code&gt;[%wtcl p r q]&lt;/code&gt;.
It&amp;#39;s all just syntactic sugar.&lt;/p&gt;

&lt;p&gt;In fact, at the risk of scaring you further, here is the entire
Hoon type-inference function from &lt;code&gt;hoon.hoon&lt;/code&gt;.  &lt;code&gt;++play&lt;/code&gt; is a 
serviceable list of the &lt;em&gt;natural&lt;/em&gt; hoons - the axioms, as it
were.  Understand all these, and the rest are just... macros.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  play
  ~/  %play
  =&amp;gt;  .(vet |)
  |=  gen=twig
  ^-  type
  ?-  gen
    [^ *]      (cell $(gen p.gen) $(gen q.gen))
    [%bcpt *]  $(gen (~(whip al q.gen) p:(seep %read p.gen)))
    [%brcn *]  (core sut %gold sut [[%0 0] p.gen])
    [%cnts *]  =+  lar=(foil (seek %read p.gen))
               =+  mew=(snub q.gen)
               =+  rag=q.q.lar
               %-  fire
               |-  ^-  (list ,[p=type q=foot])
               ?@  mew
                 rag
               $(mew t.mew, rag q:(tock p.i.mew ^$(gen q.i.mew) rag))
    [%dtkt *]  %noun
    [%dtls *]  [%atom %$]
    [%dtzy *]  ?:(=(%f p.gen) ?&amp;gt;((lte q.gen 1) bean) [%atom p.gen])
    [%dtzz *]  [%cube q.gen ?:(.?(q.gen) %noun [%atom p.gen])]
    [%dttr *]  %noun
    [%dtts *]  bean
    [%dtwt *]  bean
    [%ktbr *]  (wrap(sut $(gen p.gen)) %iron)
    [%ktls *]  $(gen p.gen)
    [%ktpm *]  (wrap(sut $(gen p.gen)) %zinc)
    [%ktsg *]  $(gen p.gen)
    [%ktts *]  (conk(sut $(gen q.gen)) p.gen)
    [%ktwt *]  (wrap(sut $(gen p.gen)) %lead)
    [%sgzp *]  ~_(duck(sut ^$(gen p.gen)) $(gen q.gen))
    [%sggr *]  $(gen q.gen)
    [%tsgr *]  $(gen q.gen, sut $(gen p.gen))
    [%tstr *]  $(gen r.gen, sut (busk p.gen q.gen))
    [%wtcl *]  =+  [fex=(gain p.gen) wux=(lose p.gen)]
               %+  fork
                 ?:(=(%void fex) %void $(sut fex, gen q.gen))
               ?:(=(%void wux) %void $(sut wux, gen r.gen))
    [%zpcb *]  ~_((show %o p.gen) $(gen q.gen))
    [%zpcm *]  (play p.gen)
    [%zpcn ~]  p:seed
    [%zpfs *]  %void
    [%zpsm *]  (cell $(gen p.gen) $(gen q.gen))
    [%zpts *]  %noun
    [%zpzp ~]  %void
    *          =+  doz=~(open ap gen)
               ?:  =(doz gen)
                 ~_  (show [%c &amp;#39;hoon&amp;#39;] [%q gen])
                 ~|(%play-open !!)
               $(gen doz)
  ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Well, it&amp;#39;s a little intimidating.  But not bad for a whole
language, perhaps.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s start by working through the hoons we&amp;#39;ll need to make 
decrement work.&lt;/p&gt;

&lt;h3&gt;Cores&lt;/h3&gt;

&lt;p&gt;To build decrement, we&amp;#39;ll need a loop.  To write a loop, we&amp;#39;ll
need a core.  This adds another to the kinds of types we know:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  type  $|  ?(%noun %void)                            ::
          $%  [%atom p=term]                            ::
              [%cell p=type q=type]                     ::
              [%core p=type q=coil]                     ::
              [%cube p=* q=type]                        ::
              [%face p=term q=type]                     ::
              [%fork p=type q=type]                     ::
          ==                                            ::
++  coil  $:  p=?(%gold %iron %lead %zinc)              ::
              q=type                                    ::
              r=[p=?(~ ^) q=(map term foot)]            ::
          ==                                            ::
++  foot  $%  [%ash p=twig]                             ::
              [%elm p=twig]                             ::
          ==                                            ::
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Aha, you say.  I knew there had to be something complicated in
here.  Well, fact is, I&amp;#39;m just a simple country mouse and so are
you, but Hoon is a polymorphic higher-order typed functional
language with genericity and stuff, and you don&amp;#39;t get that
without a little bit of urban funk.&lt;/p&gt;

&lt;p&gt;But we want to keep it simple for now, so let&amp;#39;s imagine it said&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[%core p=type q=(map term twig)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As we recall from chapter 4, a core is a &lt;code&gt;[code data]&lt;/code&gt; cell -
&lt;code&gt;[battery payload]&lt;/code&gt;.  Essentially, an object.  The battery, at
the Nock level, is a tree of formulas, each of whose subject 
is the core itself.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s change our test file to produce a core.  The whole file:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:             ::  To write a trivial Hoon program
|=  *          ::
|=  [a=@ ~]    ::  For educational purposes only
:_  ~  :_  ~   ::
:-  %$         ::  Preserve this mysterious boilerplate square
!&amp;gt;             ::
:::::::::::::::::  Produce a value below
|%
++  hello
  &amp;quot;hello, world.&amp;quot;
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The syntax for a basic core is &lt;code&gt;|%&lt;/code&gt; (&lt;code&gt;barcen&lt;/code&gt;, or &lt;code&gt;%brcn&lt;/code&gt;),
followed by any number of arms &lt;code&gt;++&lt;/code&gt; (&lt;code&gt;luslus&lt;/code&gt;, or just &lt;code&gt;slus&lt;/code&gt;),
followed by a terminator &lt;code&gt;--&lt;/code&gt; (&lt;code&gt;hephep&lt;/code&gt;, or just &lt;code&gt;phep&lt;/code&gt;).  The arm
is a symbol and a twig.  The subject of the twig is the core.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s try this puppy out:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/9/bin/hec/hoon
~waclux-tomwyc/try=&amp;gt; :hec
! type-fail
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Whoops!  We forgot that Arvo is a &lt;em&gt;typed&lt;/em&gt; command-line.  Because
it&amp;#39;s parsed as an open-ended list, it always has the terminator
(&lt;code&gt;~&lt;/code&gt;, which is just &lt;code&gt;@n&lt;/code&gt;0) on the end.  But it needs an atom:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;|=  [a=@ ~]    ::  For educational purposes only
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hence:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :hec 42
&amp;lt; 1.ivl
  1.hfd
  [ [a=@ %~]
    &amp;lt;1.vpy [* [@p /] &amp;lt;218.tvj 18.olk 323.uvl 81.wza 1.xlc %164&amp;gt;]&amp;gt;
  ]
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That&amp;#39;s a core.  Or it&amp;#39;s how we print a core, anyway.  This is
actually a giant noun full of all kinds of formulas, and it would
be kind of lame to dump a megabyte of nock on your screen.  The
print format is:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;number-of-arms.checksum payload&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we wrapped our new &lt;code&gt;1.ivl&lt;/code&gt; core, with its &lt;code&gt;++hello&lt;/code&gt; arm,
around the &lt;code&gt;1.hfd&lt;/code&gt; core (which is the &lt;code&gt;|=  [a=@ ~]&lt;/code&gt; thingy),
around a stack of cores ultimately terminating in the giant
kernel with hundreds of arms (like &lt;code&gt;218.tvj&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Okay.  But we built a core because we wanted to use it.  So,
let&amp;#39;s do that:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;gt;  |%
    ++  hello
      &amp;quot;hello, world.&amp;quot;
    --
hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What is this &lt;code&gt;=&amp;gt;&lt;/code&gt;, &lt;code&gt;tisgar&lt;/code&gt;, &lt;code&gt;%tsgr&lt;/code&gt;?  You remember Nock 7.  &lt;code&gt;=&amp;gt;&lt;/code&gt;
is Nock 7.  &lt;code&gt;=&amp;gt;(a b)&lt;/code&gt; means &amp;quot;use a as the subject of b.&amp;quot;  So, we
are resolving the limb &lt;code&gt;hello&lt;/code&gt; against our &lt;code&gt;1.ivl&lt;/code&gt; core.&lt;/p&gt;

&lt;p&gt;So when we try it:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/11/bin/hec/hoon
~waclux-tomwyc/try=&amp;gt; :hec 42
&amp;quot;hello, world.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s observe a couple of things.  First, an arm is not a method
in the OO sense.  You don&amp;#39;t see any arguments on &lt;code&gt;++hello&lt;/code&gt;.
Rather, the arm is a computed expression - a synthetic attribute,
as it were.  (Can we build a method?  We&amp;#39;ll get to that.)&lt;/p&gt;

&lt;p&gt;Second, when we&amp;#39;re searching for a name in a core, we search the
payload if we don&amp;#39;t find an arm.  For example:
```
=&amp;gt;  |%
    ++  hello
      &amp;quot;hello, world.&amp;quot;
    --
a&lt;/p&gt;

&lt;p&gt;: /~waclux-tomwyc/try/12/bin/hec/hoon
~waclux-tomwyc/try=&amp;gt; :hec 42
42
``&lt;code&gt;
Our command-line argument,&lt;/code&gt;a`, is still in there.  We can also
use it from within the arm.  With some string-interpolation black
magic:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;gt;  |%
    ++  hello
      &amp;quot;hello, world - a is { (scow %ud a) }.&amp;quot;
    --
hello

: /~waclux-tomwyc/try/13/bin/hec/hoon
~waclux-tomwyc/try=&amp;gt; :hec 42
&amp;quot;hello, world - a is 42.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, this is a classic case in which the twig needs to be
reversed to make it flow downward.  We need the opposite of &lt;code&gt;=&amp;gt;&lt;/code&gt;:
&lt;code&gt;=&amp;lt;&lt;/code&gt;, &lt;code&gt;tisgal&lt;/code&gt;, &lt;code&gt;%tsgl&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;lt;  hello
|%
++  hello
  &amp;quot;hello, world - a is { (scow %ud a) }.&amp;quot;
--

: /~waclux-tomwyc/try/14/bin/hec/hoon
~waclux-tomwyc/try=&amp;gt; :hec 42
&amp;quot;hello, world - a is 42.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Preparing to decrement&lt;/h3&gt;

&lt;p&gt;To do some decrementing, we&amp;#39;ll need a counter.  Let&amp;#39;s continue
our pattern of using only natural hoons:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;gt;  :-  ^=  b
        0
    .
=&amp;lt;  decrement
|%
++  decrement
  b
--

: /~waclux-tomwyc/try/16/bin/hec/hoon
~waclux-tomwyc/try=&amp;gt; :hec 42
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We introduce a couple of new hoons.  First, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;kettis&lt;/code&gt;,
&lt;code&gt;%ktts&lt;/code&gt; - is a hoon we&amp;#39;ve already seen.  We&amp;#39;ve seen it only in
its irregular form - not &lt;code&gt;^=(b 0)&lt;/code&gt;, but, of course, &lt;code&gt;b=0&lt;/code&gt;.
(Pronounced not &amp;quot;b tis zero,&amp;quot; but, of course, &amp;quot;b is zero.&amp;quot;)&lt;/p&gt;

&lt;p&gt;We&amp;#39;ve also seen &lt;code&gt;:-&lt;/code&gt; in its irregular form - it just makes a
cell.  &lt;code&gt;:-(a b)&lt;/code&gt; is just &lt;code&gt;[a b]&lt;/code&gt;.  We have a set of these hoons,
which let us build cells in classic Hoon fashion:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;:-(a b)       [a b]
:+(a b c)     [a b c]
:^(a b c d)   [a b c d]
:_(a b)       [b a]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we might as well say&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;gt;  [b=0 .]
=&amp;lt;  decrement
|%
++  decrement
  b
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In other words - enter our core not with the original subject,
&lt;code&gt;.&lt;/code&gt;, but with the cell &lt;code&gt;[b=0 .]&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;You might remember this as nock &lt;code&gt;8&lt;/code&gt; - and in fact (it is a
synthetic hoon, but the compiler sees what you&amp;#39;re doing and turns
it into nock &lt;code&gt;8&lt;/code&gt; anyway) there&amp;#39;s a hoon for that: &lt;code&gt;=+&lt;/code&gt;, &lt;code&gt;tislus&lt;/code&gt;,
&lt;code&gt;%tsls&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  b=0
=&amp;lt;  decrement
|%
++  decrement
  b
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Actually decrementing&lt;/h3&gt;

&lt;p&gt;As you may remember, to decrement &lt;code&gt;a&lt;/code&gt; we need to count up to it.
The first step is incrementing, which we do with &lt;code&gt;.+&lt;/code&gt; - &lt;code&gt;dotlus&lt;/code&gt;, 
&lt;code&gt;%dtls&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  b=0
=&amp;lt;  decrement
|%
++  decrement
  .+(b)
--

: /~waclux-tomwyc/try/19/bin/hec/hoon
~waclux-tomwyc/try=&amp;gt; :hec 42
1
~waclux-tomwyc/try=&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Well, it&amp;#39;s not decrement but it&amp;#39;s a start.  What we really have
to do is see if &lt;code&gt;+(b)&lt;/code&gt; equals &lt;code&gt;a&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  b=0
=&amp;lt;  decrement
|%
++  decrement
  ?:  .=(a +(b))
    b
  99
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#39;ve met a new hoon, &lt;code&gt;.=&lt;/code&gt;, &lt;code&gt;dottis&lt;/code&gt;, &lt;code&gt;%dtts&lt;/code&gt;.  It too has an
irregular form, not surprisingly different:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  b=0
=&amp;lt;  decrement
|%
++  decrement
  ?:  =(a +(b))
    b
  99
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And &lt;code&gt;?:&lt;/code&gt; was of course one of our first examples.  We can test
this, for what it&amp;#39;s worth:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :hec 42
99
~waclux-tomwyc/try=&amp;gt; :hec 1
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Well, it works.  For one case of &amp;quot;works.&amp;quot;&lt;/p&gt;

&lt;p&gt;You know, gosh, instead of &lt;code&gt;99&lt;/code&gt; - which is obviously just wrong -
what we&amp;#39;d actually like to do is, if &lt;code&gt;+(b)&lt;/code&gt; isn&amp;#39;t equal to &lt;code&gt;a&lt;/code&gt;,
compute &lt;code&gt;decrement&lt;/code&gt; again, but with &lt;code&gt;b&lt;/code&gt; set to &lt;code&gt;+(b)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There&amp;#39;s a way to do that:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  b=0
=&amp;lt;  decrement
|%
++  decrement
  ?:  =(a +(b))
    b
  %=  decrement
      b  +(b)
  ==
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Meet &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;centis&lt;/code&gt;, &lt;code&gt;%cnts&lt;/code&gt; - the world&amp;#39;s most important hoon.
Actually, &lt;em&gt;everything&lt;/em&gt; that references a limb/wing turns into
&lt;code&gt;%=&lt;/code&gt;.  Let&amp;#39;s look at its definition:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  twig  $%  [%cnts p=wing q=tray]
          ==
++  tray  (list ,[p=wing q=twig])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;%=&lt;/code&gt; means &amp;quot;resolve with changes.&amp;quot;  If &lt;code&gt;q&lt;/code&gt; is empty, &lt;code&gt;%=&lt;/code&gt; just 
pulls wing &lt;code&gt;p&lt;/code&gt; with no changes.  Otherwise, we get &lt;code&gt;p&lt;/code&gt; with the
wings in &lt;code&gt;q&lt;/code&gt; set to the provided twigs.&lt;/p&gt;

&lt;p&gt;A wing, of course, can resolve to a leg or an arm - a fragment of
the subject, or a computed attribute like &lt;code&gt;++decrement&lt;/code&gt; above.
When &lt;code&gt;p&lt;/code&gt; resolves to an arm, we compute based on the changes
defined in &lt;code&gt;q&lt;/code&gt;.  (When one of the wings in &lt;code&gt;q&lt;/code&gt; resolves to an
arm, the change is to the core that contains the arm.)&lt;/p&gt;

&lt;p&gt;So, this should do exactly what we want - it should replace &lt;code&gt;b&lt;/code&gt;
with &lt;code&gt;+(b)&lt;/code&gt;, and recompute.  But does it?  Amazingly...&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/21/bin/hec/hoon
~waclux-tomwyc/try=&amp;gt; :hec 42
41
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Making it pretty&lt;/h3&gt;

&lt;p&gt;The first thing we notice is that &lt;code&gt;%=&lt;/code&gt; is pretty important, and
being pretty important it ought to have an irregular form:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  b=0
=&amp;lt;  decrement
|%
++  decrement
  ?:  =(a +(b))
    b
  decrement(b +(b))
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The second thing we notice is this heavy word, &lt;code&gt;decrement&lt;/code&gt;, which
we are dragging around everywhere.  Actually, we know we&amp;#39;re
writing a decrement program.  So why do we keep saying decrement,
decrement, decrement?&lt;/p&gt;

&lt;p&gt;Naming things is one of the most annoying and difficult problems
in programming.  Nobody should have to name anything, especially
if its only job is to call itself.&lt;/p&gt;

&lt;p&gt;Fortunately, a unique feature of Hoon is &lt;em&gt;the empty name&lt;/em&gt;, &lt;code&gt;$&lt;/code&gt;.
The character (the dollar sign) is pronounced &lt;code&gt;buc&lt;/code&gt;; the value;
(the empty term) is pronounced &lt;code&gt;blip&lt;/code&gt;.  So you can say either.
Or both - depends if you&amp;#39;re money.  Either way, neighbor, &lt;code&gt;$&lt;/code&gt;
has a value and it ain&amp;#39;t nothing but zero:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ux`%foo
0x6f.6f66
~waclux-tomwyc/try=&amp;gt; `@ux`%$
0x0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When we use &lt;code&gt;$&lt;/code&gt; as a name, our decrement gets cleaner - or
shorter, anyway:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  b=0
=&amp;lt;  $
|%
++  $
  ?:  =(a +(b))
    b
  $(b +(b))
--
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The third thing we notice is that this pattern of &amp;quot;have one arm
and do it again with some changes&amp;quot; is... well, it has a name.
So we might expect to see a more convenient hoon - and indeed
we do:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  b=0
=&amp;lt;  $
|.
?:  =(a +(b))
  b
$(b +(b))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What is &lt;code&gt;|.&lt;/code&gt;, &lt;code&gt;bardot&lt;/code&gt;, &lt;code&gt;%brdt&lt;/code&gt;?  It&amp;#39;s easy to see what a
synthetic hoon does - we just look at its line in &lt;code&gt;++open&lt;/code&gt;
(in &lt;code&gt;hoon.hoon&lt;/code&gt;).  For example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[%tsgl *]  [%tsgr q.gen p.gen]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and, more to the point:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[%brdt *]  [%brcn (~(put by *(map term foot)) %$ [%ash p.gen])]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Okay, this isn&amp;#39;t exactly as pellucid as it might be.  All it
means is that we create a &lt;code&gt;|%&lt;/code&gt; with one arm, our &lt;code&gt;%$&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Moreover, it seems like we might want to activate one of these
strange repeating computations automagically.  Indeed there&amp;#39;s a
hoon for that - &lt;code&gt;|-&lt;/code&gt;, &lt;code&gt;barhep&lt;/code&gt;, &lt;code&gt;%brhp&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[%brhp *]  [%tsgl [%cnzy %$] [%brdt p.gen]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that we just did that.  &lt;code&gt;%cnzy&lt;/code&gt; is an internal hoon which
doesn&amp;#39;t have a syntax, and just makes macros smaller:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[%cnzy *]  [%cnts [p.gen ~] ~]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Aha, good old &lt;code&gt;%cnts&lt;/code&gt; - aka, &lt;code&gt;%=&lt;/code&gt;.  But wait - does it work?
We get:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=+  b=0
|-
?:  =(a +(b))
  b
$(b +(b))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or, to indent this a little more aggressively, our final result.
It isn&amp;#39;t exactly what we started with - but we&amp;#39;ll get there in 
a minute:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:             ::  To write a trivial Hoon program
|=  *          ::
|=  [a=@ ~]    ::  For educational purposes only
:_  ~  :_  ~   ::
:-  %$         ::  Preserve this mysterious boilerplate square
!&amp;gt;             ::
:::::::::::::::::  Produce a value below
=+  b=0
|-  ?:  =(a +(b))
      b
    $(b +(b))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s try it...&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/22/bin/hec/hoon
~waclux-tomwyc/try=&amp;gt; :hec 42
41
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It works!&lt;/p&gt;

&lt;h2&gt;Exercises&lt;/h2&gt;

&lt;p&gt;Exercise 1: write the entire expression under the boilerplate
above, in one line as wide form.  Test it.&lt;/p&gt;

&lt;p&gt;Exercise 2: write a Hoon program :fib that instead computes the
Fibonacci number at &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch6&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Moar Hoon Types&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch8&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Gates&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Chapter VI (Moar Hoon Types)</title>
   <link href="http://urbit.org/doc/2013/11/18/ch6/"/>
   <updated>2013-11-18T00:00:00-08:00</updated>
   <id>http://urbit.org/doc/2013/11/18/ch6</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch5&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Intro To Hoon&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch7&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Hoon Computes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;quot;What good is a phone call if you&amp;#39;re unable to speak?&amp;quot;&lt;/em&gt;
&lt;strong&gt;(The Matrix)&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;More simple types&lt;/h2&gt;

&lt;p&gt;Before we actually do some programming with Hoon, let&amp;#39;s meet two 
more kinds of type - &lt;code&gt;%face&lt;/code&gt; and &lt;code&gt;%fork&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  type  $|  ?(%noun %void)
          $%  [%atom p=term]
              [%cell p=type q=type]
              [%cube p=* q=type]  
              [%face p=term q=type]
              [%fork p=type q=type]
          ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;code&gt;%fork&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;%fork&lt;/code&gt; is simply a union type.  A type is a set of nouns -
&lt;code&gt;[%fork p q]&lt;/code&gt; means &amp;quot;it could be a p, or maybe a q.&amp;quot;&lt;/p&gt;

&lt;p&gt;Any branching computation in which different branches produce
different types will generate a fork.  For example, without
worrying too much about the mysterious &lt;code&gt;?:&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :type; ?:(&amp;amp; %foo [13 10])
%foo
{ %foo [@ud @ud] }

~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(?:(&amp;amp; %foo [13 10]))
[ %fork
  p=[%cube p=7.303.014 q=[%atom p=%tas]]
  q=[%cell p=[%atom p=%ud] q=[%atom p=%ud]]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we start to understand why the type renderer is useful, as
&lt;code&gt;{ %foo [@ud @ud] }&lt;/code&gt; (which is &lt;em&gt;not&lt;/em&gt; in any way Hoon syntax) is a
little easier to read than the actual type noun.&lt;/p&gt;

&lt;p&gt;(Readers of a mathematical bent may ask: since Hoon has a union
type, where is the intersection type?  There is none.  Hoon is
not one of these languages whose goal is to be as mathematically
powerful as possible.  Since a programming language is a UI for
programmers, and programmers are not mathematicians, Hoon is
designed to be as powerful as it has to be - and no more.)&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;%face&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;A type is not just a set of nouns - it&amp;#39;s also a &lt;em&gt;meaning&lt;/em&gt; which
makes sense of any noun in that set.  The typed noun exports a
namespace - give it a name, and it gives you another noun.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s use this feature:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; foo=42
foo=42
~waclux-tomwyc/try=&amp;gt; :type; foo=42
foo=42
foo=@ud
~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(foo=42)
[%face p=%foo q=[%atom p=%ud]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;%face&lt;/code&gt;, we&amp;#39;ve simply wrapped a label around another type.
Note that this doesn&amp;#39;t impair our ability to compute with the
value.  Computationally, &lt;code&gt;foo=42&lt;/code&gt; is just &lt;code&gt;42&lt;/code&gt;: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; (add 17 foo=42)
59
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But how do we use this namespace?&lt;/p&gt;

&lt;p&gt;To play comfortably with names, it&amp;#39;ll help if we introduce some Arvo
shell syntax.  As in Unix, you can bind variables in the Arvo shell.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test 42
~waclux-tomwyc/try=&amp;gt; test
42
~waclux-tomwyc/try=&amp;gt; (add 17 test)
59
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;=name value&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; in any way Hoon syntax - any Hoon expression
is a valid Arvo command, but not every Arvo command is a Hoon
expression.)&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s put a &lt;code&gt;%face&lt;/code&gt; inside this shell variable and try to use it:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test foo=42
~waclux-tomwyc/try=&amp;gt; test
foo=42
~waclux-tomwyc/try=&amp;gt; foo.test
42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You probably expected it to be &lt;code&gt;test.foo&lt;/code&gt;.  This disoriented
feeling should vanish in a few minutes.  Let&amp;#39;s go further:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test foo=42
~waclux-tomwyc/try=&amp;gt; test
foo=42
~waclux-tomwyc/try=&amp;gt; foo.test
42

~waclux-tomwyc/try=&amp;gt; =test bar=foo=42
~waclux-tomwyc/try=&amp;gt; test
bar=foo=42
~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(test)
[%face p=%bar q=[%face p=%foo q=[%atom p=%ud]]]

~waclux-tomwyc/try=&amp;gt; bar.test
foo=42
~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(bar.test)
[%face p=%foo q=[%atom p=%ud]]

~waclux-tomwyc/try=&amp;gt; foo.bar.test
42
~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(foo.bar.test)
[%atom p=%ud]

~waclux-tomwyc/try=&amp;gt; foo.test
! -find-limb.foo
! find-none
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Name resolution&lt;/h2&gt;

&lt;p&gt;We&amp;#39;re starting to learn a little about name resolution in Hoon.
We&amp;#39;ve seen that &lt;code&gt;foo.bar.test&lt;/code&gt; means &amp;quot;foo in bar in test.&amp;quot;  We&amp;#39;ve
seen that faces have to be unwrapped a layer at a time, so &amp;quot;foo in
test&amp;quot; is an error.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s try some cells:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test [cat=3 dog=4]
~waclux-tomwyc/try=&amp;gt; cat.test
3
~waclux-tomwyc/try=&amp;gt; =test [cat=3 dog=[pig=9 rat=12]]
~waclux-tomwyc/try=&amp;gt; rat.dog.test
12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that name resolution seeks into cells.  This solves one of
the problems we had when programming in Nock.  For example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test [cow=97 test]
~waclux-tomwyc/try=&amp;gt; cow.test
97
~waclux-tomwyc/try=&amp;gt; rat.dog.test
12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By replacing &lt;code&gt;test&lt;/code&gt; with &lt;code&gt;[cow=97 test]&lt;/code&gt;, we&amp;#39;ve done exactly the
same thing as nock &lt;code&gt;8&lt;/code&gt;.  (And we&amp;#39;ll do more of it.)  Note that
because we didn&amp;#39;t wrap a face around &lt;code&gt;test&lt;/code&gt;, we seek into it when
looking for &lt;code&gt;dog&lt;/code&gt;, and &lt;code&gt;rat.dog.test&lt;/code&gt; works just the same way.
Even though &lt;code&gt;dog&lt;/code&gt; is now at a different axis within &lt;code&gt;test&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For reasons we&amp;#39;ll see soon, we often want empty names.  As we saw
before, the syntax for an empty name is &lt;code&gt;$&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test $=42
~waclux-tomwyc/try=&amp;gt; $.test
42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And interesting cases tell us more about the search algorithm:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test [cat=3 cat=[pig=9 rat=12]]
~waclux-tomwyc/try=&amp;gt; cat.test
3
~waclux-tomwyc/try=&amp;gt; pig.cat.test
! -find-limb.pig
! find-none
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that when we search a cell, we search the head first.  It
is not in any way an error to have two faces with the same name.
And in fact, we can even work with this constraint:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; ^cat.test
[pig=9 rat=12]
~waclux-tomwyc/try=&amp;gt; pig.^cat.test
9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;limb&lt;/code&gt; to resolve is not just a name - it takes a prefix which
is an arbitrary number of &lt;code&gt;^&lt;/code&gt; characters.  This count is the
number of name instances to ignore before matching.  For
instance: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test [cat=3 cat=[pig=9 rat=12] cat=42]
~waclux-tomwyc/try=&amp;gt; ^^cat.test
42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#39;re actually ready to describe the full resolution model.&lt;/p&gt;

&lt;h3&gt;Wing resolution&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;wing&lt;/code&gt; is a dot-separated list, reading outside to in from
right to left.  Each element is a &lt;code&gt;limb&lt;/code&gt;.  We&amp;#39;ve seen one kind of
limb - the name, with &lt;code&gt;^&lt;/code&gt; prefixes.&lt;/p&gt;

&lt;p&gt;But we can also use axes directly from Hoon.  For instance:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test [cat=3 dog=[pig=9 rat=12]]
~waclux-tomwyc/try=&amp;gt; +3.test
dog=[pig=9 rat=12]
~waclux-tomwyc/try=&amp;gt; dog.test
[pig=9 rat=12]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the difference between these two.  The noun is the same -
they are both &lt;code&gt;[9 12]&lt;/code&gt;.  But the type is different:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(+3.test)
[ %face
  p=%dog
    q
  [ %cell
    p=[%face p=%pig q=[%atom p=%ud]]
    q=[%face p=%rat q=[%atom p=%ud]]
  ]
]

~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(dog.test)
[ %cell
  p=[%face p=%pig q=[%atom p=%ud]]
  q=[%face p=%rat q=[%atom p=%ud]]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The axis gets us to the %dog face; the name actually removes it.
So we can write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; pig.dog.+3.test
9
~waclux-tomwyc/try=&amp;gt; pig.dog.test
9
~waclux-tomwyc/try=&amp;gt; pig.+3.test
! -find-limb.pig
! find-none
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perhaps this is obvious.  Perhaps it&amp;#39;s not.&lt;/p&gt;

&lt;h3&gt;Axis syntax&lt;/h3&gt;

&lt;p&gt;This may seem like overkill.  Perhaps it &lt;em&gt;is&lt;/em&gt; overkill.  But Hoon
has five syntaxes for an axis limb.&lt;/p&gt;

&lt;p&gt;The first we&amp;#39;ve seen already: the axis itself as a decimal, eg,
&lt;code&gt;+3&lt;/code&gt;.  The second is a simple dot, meaning &lt;code&gt;+1&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test 42
~waclux-tomwyc/try=&amp;gt; ..test
42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yes, that&amp;#39;s the limb &lt;code&gt;.&lt;/code&gt;, as applied (with &lt;code&gt;.&lt;/code&gt;), to &lt;code&gt;test&lt;/code&gt;.  Have
we gone crazy?  Perhaps - but in fact, this one gets used a lot.&lt;/p&gt;

&lt;p&gt;Then we have an list-indexing syntax for constant offsets in
lists that (as is the Hoon convention) flow to the right.
Indices start at 1.  &lt;code&gt;&amp;amp;&lt;/code&gt; produces the list element, &lt;code&gt;|&lt;/code&gt; produces
the suffix:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test [1 2 3 4 ~]
~waclux-tomwyc/try=&amp;gt; &amp;amp;2.test
2
~waclux-tomwyc/try=&amp;gt; |2.test
[3 4 ~]
~waclux-tomwyc/try=&amp;gt; &amp;amp;1.test
1
~waclux-tomwyc/try=&amp;gt; |1.test
[2 3 4 ~]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This mechanism - which essentially just converts the list index
into an axis for &lt;code&gt;+&lt;/code&gt; - is not used much, but nice when needed.
It applies only to constant indices, though, which is odd.  (For
non-constant indices, use the Hoon function &lt;code&gt;snag&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Finally, we have a graphical binary syntax which reads from left
to right, alternating the pairs &lt;code&gt;-&lt;/code&gt;/&lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;/&lt;code&gt;&amp;gt;&lt;/code&gt; to mean head
and tail respectively.  For example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test [[[8 9] [10 11]] [12 13] 14 30 31]
~waclux-tomwyc/try=&amp;gt; -.test
[[8 9] 10 11]
~waclux-tomwyc/try=&amp;gt; +.test
[[12 13] 14 30 31]
~waclux-tomwyc/try=&amp;gt; -&amp;lt;.test
[8 9]
~waclux-tomwyc/try=&amp;gt; +&amp;gt;.test
[14 30 31]
~waclux-tomwyc/try=&amp;gt; +&amp;gt;-.test
14
~waclux-tomwyc/try=&amp;gt; -&amp;gt;-.test
10
~waclux-tomwyc/try=&amp;gt; +&amp;gt;+&amp;lt;.test
30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The alternating glyphs create pleasant graphical patterns which
are moderately memorable when used in moderation.  Of course, in
general, when we have names we should use them.&lt;/p&gt;

&lt;h3&gt;Resolving forks&lt;/h3&gt;

&lt;p&gt;What happens when we resolve a name in a fork?  Yikes.  The
general principle is that name resolution across a fork works if,
and only if, the names resolve to the same axis on both branches.&lt;/p&gt;

&lt;p&gt;For instance:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; =test ?:(&amp;amp; [pig=3 dog=4] [pig=%pig dog=%dog cat=%cat])
~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(test)
[ %fork
    p
  [ %cell
    p=[%face p=%pig q=[%atom p=%ud]]
    q=[%face p=%dog q=[%atom p=%ud]]
  ]
    q
  [ %cell
    p=[%face p=%pig q=[%cube p=6.777.200 q=[%atom p=%tas]]]
      q
    [ %cell
      p=[%face p=%dog q=[%cube p=6.778.724 q=[%atom p=%tas]]]
      q=[%face p=%cat q=[%cube p=7.627.107 q=[%atom p=%tas]]]
    ]
  ]
]
~waclux-tomwyc/try=&amp;gt; pig.test
3
~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(pig.test)
[%fork p=[%atom p=%ud] q=[%cube p=6.777.200 q=[%atom p=%tas]]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And yet:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; dog.test
! -find-limb.dog
! find-fork
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Why?  Because &lt;code&gt;dog&lt;/code&gt; is at &lt;code&gt;+3&lt;/code&gt; on one side of the fork, &lt;code&gt;+6&lt;/code&gt; on
the other.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ve left only one major kind of type undefined - the
mysterious, frightening &lt;code&gt;%core&lt;/code&gt;.  We made a core in Nock, but
that was a little while ago.  We&amp;#39;ll explain them in Hoon when we
make one.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch5&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Intro To Hoon&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch7&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Hoon Computes&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Chapter V (Intro To Hoon)</title>
   <link href="http://urbit.org/doc/2013/11/18/ch5/"/>
   <updated>2013-11-18T00:00:00-08:00</updated>
   <id>http://urbit.org/doc/2013/11/18/ch5</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch4&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Using Nock&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch6&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Moar Hoon Types&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;quot;Like all men in Babylon, I have been proconsul; like all, a slave.&amp;quot;&lt;/em&gt;
&lt;strong&gt;(The Lottery in Babylon)&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;Principles of type&lt;/h2&gt;

&lt;p&gt;By working through the Nock tutorial, you&amp;#39;ve actually come closer
than you know to knowing Hoon.  Hoon is actually not much more
than a fancy wrapper around Nock. People who know C can think of
Hoon as the C to Urbit&amp;#39;s Nock - just a sprinkling of syntax,
wrapped around machine code and memory.&lt;/p&gt;

&lt;p&gt;For instance, it&amp;#39;s easy to imagine how instead of calculating
tree axes by hand, we could actually assign &lt;em&gt;names&lt;/em&gt; to different
parts of the tree - and those names would stay the same as we
pushed more data on the subject.  It can&amp;#39;t hurt to dream, right?&lt;/p&gt;

&lt;p&gt;The way we&amp;#39;re going to do this is by associating something called
a &lt;code&gt;type&lt;/code&gt; with the subject.  You may have heard of types before.
Technically, Hoon is a statically typed language, which just
means that the type isn&amp;#39;t a part of your program: it&amp;#39;s just a
piece of data the compiler keeps around as it turns your Hoon
into Nock.&lt;/p&gt;

&lt;p&gt;In some languages, especially functional languages, types are
dangerous scary concepts that involve a lot of math.  For those
who like this sort of thing, that&amp;#39;s the sort of thing they like.
For the rest of us, there&amp;#39;s Hoon. It&amp;#39;s a functional language, but
not one of those scary ones.&lt;/p&gt;

&lt;p&gt;A lot of other languages use dynamic types, in which the type of
a value is carried along with the data as you use it.  Even
languages like Lisp, which are nominally typeless, look rather
typed from the Hoon perspective.  For example, a Lisp atom knows
dynamically whether it&amp;#39;s a symbol or an integer.  A Hoon atom is
just a Nock atom, which is just a number.  So without a static
type, Hoon doesn&amp;#39;t even know how to print an atom properly.&lt;/p&gt;

&lt;p&gt;When we parse a Hoon expression, file, etc, we produce what we
call a &lt;code&gt;twig&lt;/code&gt;, which (if you know the CS jargon) is an AST.  A
twig is a noun that&amp;#39;s converted into a Nock formula, with
the assistance of a type which describes the subject of the
formula:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[subject-type twig] =&amp;gt; formula
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But actually this isn&amp;#39;t quite right, because Hoon does something
called &amp;quot;type inference.&amp;quot;  When we have a type that describes the
subject for the formula we&amp;#39;re trying to generate, as we generate
that formula we want to also generate a type for the product of
that formula on that subject.  So our compiler computes:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[subject-type twig] =&amp;gt; [product-type formula]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As long as &lt;code&gt;subject-type&lt;/code&gt; is a correct description of some
subject, you can take any twig and compile it against
&lt;code&gt;subject-type&lt;/code&gt;, producing a &lt;code&gt;formula&lt;/code&gt; such that &lt;code&gt;*(subject
formula)&lt;/code&gt; is a product correctly described by &lt;code&gt;product-type&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Actually, this works well enough that in Hoon there is no direct
syntax for defining or declaring a type.  There is only a syntax
for constructing twigs.  Types are always produced by inference.&lt;/p&gt;

&lt;h2&gt;Printing types&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s start looking at types with the simplest possible kind of
hoon - an atomic constant, which ignores the subject and its
type, and just produces its own subject.  Here&amp;#39;s everyone&amp;#39;s
favorite atomic constant:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; 42
42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s also print its type - in two different ways:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :type; 42
42
@ud

~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(42)
[%atom p=&amp;#39;ud&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;W-what?  Since types are of course static, printing them out
dynamically involves a little bit of black magic at the Hoon
and/or Arvo levels.  All will be revealed in due course.&lt;/p&gt;

&lt;p&gt;But a type, like everything else in Hoon, is a noun.  Suffice it
to say that &lt;code&gt;-:!&amp;gt;(42)&lt;/code&gt; is just printing this noun, whereas
&lt;code&gt;:type; 42&lt;/code&gt; is rendering it intelligently as a string.  In this
case, the rendering is actually Hoon syntax, but in general it&amp;#39;s
just a string.&lt;/p&gt;

&lt;p&gt;In this case, looking directly at the type noun is preferable.
But for a core, the type actually contains the entire codebase.
For example, if you type&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(&amp;quot;string&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;you&amp;#39;ll have to press ^C to rescue yourself, or wait until you&amp;#39;ve
printed out more or less the entire Arvo kernel.  Black magic is
evil magic - it must exact its evil price.  But someday, you&amp;#39;ll 
be more the sorcerer and less his apprentice.&lt;/p&gt;

&lt;h2&gt;Atom examples&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s look at some more of these atoms:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :type; 0x42
0x42
@ux

~waclux-tomwyc/try=&amp;gt; :type; &amp;#39;foo&amp;#39;
&amp;#39;foo&amp;#39;
@ta

~waclux-tomwyc/try=&amp;gt; :type; ~2013.12.6
~2013.12.6
@da

~waclux-tomwyc/try=&amp;gt; :type; .127.0.0.1
.127.0.0.1
@if

~waclux-tomwyc/try=&amp;gt; :type; ~m45
~m45
@dr

~waclux-tomwyc/try=&amp;gt; :type; `@da`(add ~2013.12.6 ~m45)
~2013.12.6..00.45.00
@da
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Okay, we got a little out of control with that last one.  But the
point should be clear.&lt;/p&gt;

&lt;p&gt;Note again that there is no dynamic type here.  All these values
are atoms.  Let&amp;#39;s cast them all to decimals to see (don&amp;#39;t worry
about the cast syntax - we&amp;#39;ll cover that later):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ud`0x42
66
~waclux-tomwyc/try=&amp;gt; `@ud`&amp;#39;foo&amp;#39;
7.303.014
~waclux-tomwyc/try=&amp;gt; `@ud`.127.0.0.1
2.130.706.433
~waclux-tomwyc/try=&amp;gt; `@ud`~2013.12.6
170.141.184.500.724.667.905.957.736.036.171.776.000
~waclux-tomwyc/try=&amp;gt; `@ud`~m45
49.806.208.999.015.789.363.200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Yes, 45 minutes is actually quite a large number when your unit
of time is 2^-64 seconds.)&lt;/p&gt;

&lt;p&gt;What are these atoms, anyway?  Let&amp;#39;s look at the actual type noun
(which, without magic, exists only at compile time):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(42)
[%atom p=&amp;#39;ud&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;p&lt;/code&gt; is called the &lt;code&gt;odor&lt;/code&gt; of the atom.  In this case, it&amp;#39;s &lt;code&gt;&amp;#39;ud&amp;#39;&lt;/code&gt;,
ie, unsigned decimal:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ud`&amp;#39;ud&amp;#39;
25.717
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That&amp;#39;s an unsigned-decimal interpretation of the atom &amp;#39;ud&amp;#39;, which
without a cast is an atom of odor &lt;code&gt;@ta&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :type; &amp;#39;ud&amp;#39;
&amp;#39;ud&amp;#39;
@ta

~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(&amp;#39;ud&amp;#39;)
[%atom p=&amp;#39;ta&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In case this is at all mysterious, we note:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; (add &amp;#39;u&amp;#39; (mul 256 &amp;#39;d&amp;#39;))
25.717
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As a general convention, when we represent UTF-8/ASCII text as an
atom, we store it LSB first.  A text atom is generally called a
&lt;code&gt;cord&lt;/code&gt;; if it is ASCII only, a &lt;code&gt;span&lt;/code&gt;; if it is ASCII restricted
to the Hoon symbol subset (lowercase with hyphens), a &lt;code&gt;term&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;The logic of smell&lt;/h2&gt;

&lt;p&gt;What is an odor, anyway?  We&amp;#39;ve seen that the type of an atom
constant gets an odor which is a function of its syntax.  We&amp;#39;ve
also seen that when we print atoms on the console, the printer is
(in some black-magic way) aware of the odor, and can print the
atom in roughly the same syntax we originally entered it.&lt;/p&gt;

&lt;p&gt;Hoon&amp;#39;s type system is generally strong, but odors are weak.  The
parser itself will only generate a &lt;code&gt;@ta&lt;/code&gt; for an actual ASCII
span, but not every atom is a constant.  For instance, consider
our construction of &lt;code&gt;&amp;#39;ud&amp;#39;&lt;/code&gt;.  Let&amp;#39;s look at the type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :type; &amp;#39;u&amp;#39;
&amp;#39;u&amp;#39;
@ta

~waclux-tomwyc/try=&amp;gt; :type; 256 
256
@ud

~waclux-tomwyc/try=&amp;gt; :type; (add &amp;#39;u&amp;#39; (mul 256 &amp;#39;d&amp;#39;))
25.717
@
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not only are we mixing atoms of different odors in our
arithmetic, but the result appears to be odorless.  It is
odorless.  But we can cast it back:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :type; `@ta`(add &amp;#39;u&amp;#39; (mul 256 &amp;#39;d&amp;#39;))
&amp;#39;ud&amp;#39;
@ta
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While Hoon&amp;#39;s type system is quite intelligent in some ways, it is
by no means smart enough to evaluate your arithmetic and conclude
that it produces a valid ASCII span.  We can convert any atom to
any other odor of atom, without any sanity checks:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@dr`25.717
~.s0..0000.0000.0000.6475

~waclux-tomwyc/try=&amp;gt; `@if`25.717
.0.0.100.117
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It so happens that &lt;code&gt;25.717&lt;/code&gt; is a valid amount of time, and also a
valid IPv4 address.  But obviously not all atoms are meaningful
values of every odor.  We&amp;#39;re not going to annoy you by stressing
out the console printer with bad ASCII, but we could.&lt;/p&gt;

&lt;p&gt;(And why do we say &lt;code&gt;25.717&lt;/code&gt; rather than &lt;code&gt;25,717&lt;/code&gt;?  Are we
Germans?  No, but we want all atom syntaxes to be URL-safe.
See below.)&lt;/p&gt;

&lt;p&gt;Odors are a weak type system because the programmer often knows,
at a logical level not at all available to the type system, that
(for example) &lt;code&gt;(add &amp;#39;u&amp;#39; (mul 256 &amp;#39;d&amp;#39;))&lt;/code&gt; produces an ASCII span.
We want to keep the programmer from accidentally using a date as
if it were text, but we don&amp;#39;t want to keep her from intentionally
converting between odors or ascribing odor to the result of an
arbitrary computation.&lt;/p&gt;

&lt;p&gt;An odor is exactly what it looks like - an ASCII span.  This span
is a taxonomy which grows more specific to the right.  For
instance, &lt;code&gt;@t&lt;/code&gt; for UTF-8 text, &lt;code&gt;@ta&lt;/code&gt; for URL-safe ASCII text,
&lt;code&gt;@tas&lt;/code&gt; for a Hoon symbol; or &lt;code&gt;@u&lt;/code&gt; for an unsigned integer, &lt;code&gt;@ux&lt;/code&gt;
for an unsigned integer formatted as hexadecimal.&lt;/p&gt;

&lt;p&gt;The general principle of type enforcement is that atoms change
freely either up or down the taxonomy, but not across.  For
instance, you can treat a &lt;code&gt;@tas&lt;/code&gt; as a &lt;code&gt;@t&lt;/code&gt;, as in a strong type
system; but you can also treat a &lt;code&gt;@t&lt;/code&gt; as a &lt;code&gt;@tas&lt;/code&gt;, or an &lt;code&gt;@&lt;/code&gt; as
anything.  However, passing a &lt;code&gt;@t&lt;/code&gt; to a function that expects an
&lt;code&gt;@ux&lt;/code&gt; is a type error.&lt;/p&gt;

&lt;p&gt;Even the ability to cast a &lt;code&gt;@ud&lt;/code&gt; to a &lt;code&gt;@dr&lt;/code&gt; is a syntactic hack;
casts in Hoon do not evade type enforcement.  When you write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;`@dr`25.717
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the parser actually produces the equivalent of&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;`@dr``@`25.717
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;because we can&amp;#39;t turn &lt;code&gt;@ud&lt;/code&gt; directly into &lt;code&gt;@dr&lt;/code&gt;, but we can turn
&lt;code&gt;@ud&lt;/code&gt; into &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; into &lt;code&gt;@dr&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;The smell of size&lt;/h2&gt;

&lt;p&gt;Besides these prefixes, which indicate the rendering and/or
meaning of atoms, the odor system has another orthogonal
mechanism to restrict the size of atoms.  Like the prefix, this
mechanism is weak - it is not enforced and trivially evaded.&lt;/p&gt;

&lt;p&gt;An odor span contains two parts, both optional: a lowercase
prefix and an uppercase suffix.  The suffix, if present, is a
single character A-Z &lt;code&gt;c&lt;/code&gt; which indicates an atom of size less
than or equal to &lt;code&gt;n&lt;/code&gt; bits, where &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;1 &amp;lt;&amp;lt; (c - &amp;#39;A&amp;#39;)&lt;/code&gt;.
Thus, &lt;code&gt;@tD&lt;/code&gt; is one UTF-8 byte (whatever that means); &lt;code&gt;@tN&lt;/code&gt;
is a kilobyte or less of UTF-8.&lt;/p&gt;

&lt;p&gt;(It&amp;#39;s easy to complain from a standards perspective that &amp;quot;UTF-8&amp;quot;
defines a format for bytestreams, not bytes, and at a strict
level it means no more to say &amp;quot;one UTF-8 byte&amp;quot; than to say, say,
&amp;quot;one GIF byte.&amp;quot;  But odors are not a strict type system.  It is
possible for a byte to &lt;em&gt;smell&lt;/em&gt; of UTF-8 - or even of GIF.)&lt;/p&gt;

&lt;p&gt;When enforcing conversions, &lt;code&gt;@t&lt;/code&gt; has no size information and can
be used as &lt;code&gt;@tD&lt;/code&gt;; and &lt;code&gt;@tD&lt;/code&gt;, of course, can be used as &lt;code&gt;@t&lt;/code&gt;.  But
using &lt;code&gt;@tN&lt;/code&gt; as &lt;code&gt;@tD&lt;/code&gt; is an error.  There is no way to generate
the smell of size from a constant without a cast.  And of course
arithmetic results have no odor at all.&lt;/p&gt;

&lt;p&gt;While the utility of this mechanism is debatable, at worst it
serves as a comment which documents the programmer&amp;#39;s intentions.&lt;/p&gt;

&lt;p&gt;A full table - for convenience, not because you&amp;#39;re stupid:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;A   1 bit
B   2 bits
C   4 bits
D   1 byte
E   2 bytes
F   4 bytes
G   8 bytes
H   16 bytes
I   32 bytes
J   64 bytes
K   128 bytes
L   256 bytes
M   512 bytes
N   1K
O   2K
P   4K
Q   8K
R   16K
S   32K
T   64K
U   128K
V   256K
W   512K
X   1MB
Y   2MB
Z   4MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You of course can build an atom larger than 4MB, though whether
you should is another question entirely.  But the type system
cannot express a size odor above 4MB.&lt;/p&gt;

&lt;h2&gt;Known and unknown odors&lt;/h2&gt;

&lt;p&gt;The variety of units and formats which an atom can represent is
essentially infinite.  The set of syntaxes which Hoon can parse
and print is fundamentally limited.&lt;/p&gt;

&lt;p&gt;For instance, Hoon has no syntax which means &amp;quot;number of miles.&amp;quot;
But within your program, nothing stops you from using the odor
system to distinguish a number of miles from, for instance, a
number of kilometers:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@udm`25.717
25.717
~waclux-tomwyc/try=&amp;gt; `@udk`25.717
25.717
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The printer has no idea what a &lt;code&gt;@udm&lt;/code&gt; is, but it knows what a
&lt;code&gt;@ud&lt;/code&gt; and can print accordingly.  Then, if you have a function
which expects a &lt;code&gt;@udm&lt;/code&gt; and you try to pass it a &lt;code&gt;@udk&lt;/code&gt;, it will
fail.  The feature seems banal, but spacecraft have been laid low
by less.&lt;/p&gt;

&lt;p&gt;This is clearly a crude mechanism.  If you don&amp;#39;t like it, you
don&amp;#39;t have to use it.&lt;/p&gt;

&lt;h2&gt;Known odors&lt;/h2&gt;

&lt;p&gt;Hoon knows about the following odors, with defined meanings:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@c              UTF-32 codepoint
@d              date
  @da           absolute date
  @dr           relative date (ie, timespan)
@f              yes or no (inverse boolean)
@n              nil
@p              phonemic base
@r              IEEE floating-point
  @rd           double precision  (64 bits)
  @rh           half precision (16 bits)
  @rq           quad precision (128 bits)
  @rs           single precision (32 bits)
@s              signed integer, sign bit low
  @sb           signed binary
  @sd           signed decimal
  @sv           signed base32
  @sw           signed base64
  @sx           signed hexadecimal
@t              UTF-8 text (cord)
  @ta           ASCII text (span)
    @tas        ASCII symbol (term)
@u              unsigned integer
  @ub           unsigned binary
  @ud           unsigned decimal
  @uv           unsigned base32
  @uw           unsigned base64
  @ux           unsigned hexadecimal
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each of these forms has a URL-safe syntax, which we&amp;#39;ll get to.
Each parses as an atomic constant in Hoon, and each is printed
by the Hoon prettyprinter.&lt;/p&gt;

&lt;p&gt;But first, a little more Hoonology.&lt;/p&gt;

&lt;h2&gt;The humble type&lt;/h2&gt;

&lt;p&gt;What is a Hoon type, anyway?  We know a type is a noun.  So is 
everything.  What are the semantics of this noun?&lt;/p&gt;

&lt;p&gt;Regardless of what this highly overloaded word may and does and
does mean in every other system of computation that has deployed
it, a type in Hoon has two roles.  &lt;/p&gt;

&lt;p&gt;One, it defines a set of nouns.  Any finite noun is either in 
this set, or not in it.&lt;/p&gt;

&lt;p&gt;Two, it ascribes semantics to all nouns in this set.  For
example, a Hoon type exports a semantic namespace.&lt;/p&gt;

&lt;p&gt;With this settled, let&amp;#39;s start by introducing, purely in an
informal and totally friendly way, the &lt;code&gt;tile&lt;/code&gt; syntax in which 
&lt;code&gt;type&lt;/code&gt; itself is defined in &lt;code&gt;/=main=/arvo/hoon/hoon&lt;/code&gt;.  This is
not the full definition of &lt;code&gt;type&lt;/code&gt;, just a simple subset:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  type  $|  ?(%noun %void)
          $%  [%atom p=term]
              [%cell p=type q=type]
          ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again, never mind the syntax.  We can easily describe this subset
of &lt;code&gt;type&lt;/code&gt; in plain English.&lt;/p&gt;

&lt;p&gt;It can be &lt;code&gt;%noun&lt;/code&gt; (ie, the atom &lt;code&gt;1.853.189.998&lt;/code&gt;).  Set:
all nouns.  Examples:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :type; *
0
*

~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(*)
%noun

~waclux-tomwyc/try=&amp;gt; :type; `*`%noun
1.853.189.998
*

~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(`*`%noun)
%noun
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It can be the atom &lt;code&gt;%void&lt;/code&gt;.  Set: no nouns.  We can&amp;#39;t show any
examples producing &lt;code&gt;%void&lt;/code&gt; - by definition, none of them would
terminate.  Because that&amp;#39;s what &lt;code&gt;%void&lt;/code&gt; means.&lt;/p&gt;

&lt;p&gt;It can be the cell &lt;code&gt;[%atom p]&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a &lt;code&gt;term&lt;/code&gt; (&lt;code&gt;@tas&lt;/code&gt;),
possibly empty (ie, &lt;code&gt;0&lt;/code&gt;).  Set: all atoms.  Examples: above.&lt;/p&gt;

&lt;p&gt;It can be the triple &lt;code&gt;[%cell p q]&lt;/code&gt; (ie, &lt;code&gt;[%cell [p q]]&lt;/code&gt;), where
each of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; is itself a &lt;code&gt;type&lt;/code&gt;.  Set: all cells of &lt;code&gt;p&lt;/code&gt;
and &lt;code&gt;q&lt;/code&gt;.  Examples:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :type; [3 4]
[3 4]
[@ud @ud]

~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;([3 4])
[%cell p=[%atom p=%ud] q=[%atom p=%ud]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;The noble cube&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s introduce another kind of type here, because we&amp;#39;ll need it
to talk about constant syntax:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;++  type  $|  ?(%noun %void)
          $%  [%atom p=term]
              [%cell p=type q=type]
              [%cube p=* q=type]
          ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that when we enter an ordinary constant, like &lt;code&gt;42&lt;/code&gt;, its type
&lt;code&gt;[%atom %ud]&lt;/code&gt; is the set of all atoms (with odor &lt;code&gt;@ud&lt;/code&gt;, but any
atom can have that or any odor).  Its type is certainly not the
set consisting exclusively of the value &lt;code&gt;42&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But here&amp;#39;s how we produce this &amp;quot;cubical&amp;quot; constant:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :type; %42
%42
%42

~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(%42)
[%cube p=42 q=[%atom p=%ud]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In general, a &lt;code&gt;%cube&lt;/code&gt; type contains &lt;code&gt;p&lt;/code&gt;, a single noun, and &lt;code&gt;q&lt;/code&gt;,
a base type which provides semantics.&lt;/p&gt;

&lt;p&gt;Syntactically, any atomic constant can be preceded by &lt;code&gt;%&lt;/code&gt; to
generate a cube.  The exception is &lt;code&gt;@tas&lt;/code&gt;, which always needs &lt;code&gt;%&lt;/code&gt;
and is always cubical.&lt;/p&gt;

&lt;h2&gt;Canonical atom syntaxes&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s briefly cover the syntax of each built-in odor.  It would
be counterproductive to specify them exactly here; first, this is
a tutorial rather than a spec, and second the spec is the code.
For the exact semantics, consult &lt;code&gt;++so&lt;/code&gt; in &lt;code&gt;hoon.hoon&lt;/code&gt;.  Rather,
we&amp;#39;ll explain the form and run through some examples.&lt;/p&gt;

&lt;p&gt;If some of these syntaxes seem contrived or odd, bear in mind:
none of them collides with any of the others, and they are all
URL-safe and more.  The canonical atom forms use only lowercase 
characters, numbers, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;.  A cell form adds &lt;code&gt;_&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Unsigned decimal, &lt;code&gt;@ud&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Unsigned decimal is the common or neutral atom representation.
It&amp;#39;s not very compact and in many cases conveys no intelligible
information at all, but it&amp;#39;s impossible to screw up.  &lt;code&gt;@ud&lt;/code&gt; is
the default print format for both &lt;code&gt;@u&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; - ie, unsigned
numbers with no printing preference, and opaque atoms.&lt;/p&gt;

&lt;p&gt;Hoon&amp;#39;s unsigned decimal format is the normal Continental syntax.
It differs from the Anglo-American only in the use of periods,
rather than commas, between groups of 3:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; 0
0
~waclux-tomwyc/try=&amp;gt; 19
19
~waclux-tomwyc/try=&amp;gt; 1.024
1.024
~waclux-tomwyc/try=&amp;gt; 65.536
65.536
~waclux-tomwyc/try=&amp;gt; (bex 20)
1.048.576
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An unsigned decimal not broken into groups is a syntax error.
Also, whitespace or even linebreaks can appear between the dot
and the next group. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; 65.  536
65.536
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Unsigned hexadecimal, &lt;code&gt;@ux&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@ux&lt;/code&gt; has the same syntax as &lt;code&gt;@ud&lt;/code&gt;, except that it&amp;#39;s prefixed by 
&lt;code&gt;0x&lt;/code&gt; and uses groups of four.  Hex digits are lowercase only.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; 0x0
0x0
~waclux-tomwyc/try=&amp;gt; `@ud`0x17
23
~waclux-tomwyc/try=&amp;gt; `@ux`(bex 20)
0x10.0000
~waclux-tomwyc/try=&amp;gt; 0x10.  0000
0x10.0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Unsigned base64, &lt;code&gt;@uw&lt;/code&gt;&lt;/h3&gt;

&lt;h3&gt;Unsigned base32, &lt;code&gt;@uv&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The prefix is &lt;code&gt;0w&lt;/code&gt; for base64 and &lt;code&gt;0v&lt;/code&gt; for base32.  The digits
for &lt;code&gt;@uw&lt;/code&gt; are, in order: &lt;code&gt;0-9&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;A-Z&lt;/code&gt;, -, ~:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ud`0w-
62
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;code&gt;@uv&lt;/code&gt;, the digits are &lt;code&gt;0-9&lt;/code&gt;, &lt;code&gt;a-v&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Signed decimal, &lt;code&gt;@sd&lt;/code&gt;&lt;/h3&gt;

&lt;h3&gt;Signed hexadecimal, &lt;code&gt;@sx&lt;/code&gt;&lt;/h3&gt;

&lt;h3&gt;Signed base64, &lt;code&gt;@sw&lt;/code&gt;&lt;/h3&gt;

&lt;h3&gt;Signed base32, &lt;code&gt;@sv&lt;/code&gt;&lt;/h3&gt;

&lt;h3&gt;Signed binary, &lt;code&gt;@sb&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Obviously, without finite-sized integers, the sign extension
trick does not work.  A signed integer in Hoon is a different way
to use atoms than an unsigned integer; even for positive numbers,
the signed integer cannot equal the unsigned.&lt;/p&gt;

&lt;p&gt;The prefix for a negative signed integer is a single &lt;code&gt;-&lt;/code&gt; before
the unsigned syntax.  The prefix for a &lt;em&gt;positive&lt;/em&gt; signed integer
is &lt;code&gt;--&lt;/code&gt;.  The sign bit is the low bit:  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; -1
-1
~waclux-tomwyc/try=&amp;gt; --1
--1
~waclux-tomwyc/try=&amp;gt; `@ud`-1
1
~waclux-tomwyc/try=&amp;gt; `@ud`--1
2
~waclux-tomwyc/try=&amp;gt; `@ud`-2
3
~waclux-tomwyc/try=&amp;gt; `@ud`--2
4
~waclux-tomwyc/try=&amp;gt; `@ux`-0x10
0x1f
~waclux-tomwyc/try=&amp;gt; `@ux`--0x10
0x20
~waclux-tomwyc/try=&amp;gt; `@ud`--0w-
124
~waclux-tomwyc/try=&amp;gt; `@sw`124
--0w-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Absolute date, &lt;code&gt;@da&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Urbit dates represent 128-bit chronological time, with 2^64
seconds from the start of the universe to the end.  2^127 is
3:30:08 PM on December 5, AD 226, for reasons not clear or relevant:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@da`(bex 127)
~226.12.5..15.30.08

~waclux-tomwyc/try=&amp;gt; `@da`(dec (bex 127))
~226.12.5..15.30.07..ffff.ffff.ffff.ffff
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The time of day and/or second fragment is optional:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ux`~2013.12.7
0x8000.000d.2140.7280.0000.0000.0000.0000

~waclux-tomwyc/try=&amp;gt; `@ux`~2013.12.7..15.30.07
0x8000.000d.2141.4c7f.0000.0000.0000.0000

~waclux-tomwyc/try=&amp;gt; `@ux`~2013.12.7..15.30.07..1234
0x8000.000d.2141.4c7f.1234.0000.0000.0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We also do BC:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ux`~226-.12.5
0x7fff.fffc.afb1.b800.0000.0000.0000.0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The semantics of the time system are that UGT (Urbit Galactic
Time) is GMT/UTC as of leap second 25.  UGT is chronological and
will never add leap seconds, even if UTC continues this mistake.
If a gap appears, it must be resolved in the presentation layer, 
with timezones and other human curiosities.&lt;/p&gt;

&lt;h3&gt;Relative date, &lt;code&gt;@dr&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;#39;s also nice to have a syntax for basic time intervals:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ux`~s1
0x1.0000.0000.0000.0000

~waclux-tomwyc/try=&amp;gt; `@ux`~m1
0x3c.0000.0000.0000.0000

~waclux-tomwyc/try=&amp;gt; (div ~m1 ~s1)
60

~waclux-tomwyc/try=&amp;gt; (div ~h1 ~m1)
60

~waclux-tomwyc/try=&amp;gt; (div ~h1 ~s1)
3.600

~waclux-tomwyc/try=&amp;gt; (div ~d1 ~h1)
24

~waclux-tomwyc/try=&amp;gt; `@da`(add ~2013.11.30 ~d1)
~2013.12.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are no &lt;code&gt;@dr&lt;/code&gt; intervals under a second or over a day.  Since
the resolution is so high, though, &lt;code&gt;(div ~s1 1.000.000)&lt;/code&gt; produces
a pretty accurate microsecond.&lt;/p&gt;

&lt;h3&gt;Loobean, &lt;code&gt;@f&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;A loobean, or just &lt;code&gt;bean&lt;/code&gt;, is 0 or 1.  &lt;code&gt;0&lt;/code&gt; is yes, &lt;code&gt;1&lt;/code&gt; is no:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ud`.y
0
~waclux-tomwyc/try=&amp;gt; `@ud`.n
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;People who find this strange are probably strange themselves.&lt;/p&gt;

&lt;h3&gt;Nil, &lt;code&gt;@n&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Nil indicates an absence of information, as in a list terminator.
The only value is &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ud`~
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Unicode text, &lt;code&gt;@t&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@t&lt;/code&gt; is a sequence of UTF-8 bytes, LSB first - sometimes called a
&lt;code&gt;cord&lt;/code&gt;.  For lowercase numbers and letters, the canonical syntax 
is &lt;code&gt;~~text&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; ~~foo
&amp;#39;foo&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the prettyprinter makes an unprincipled exception and 
prints the text in a noncanonical format:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ux`~~foo
0x6f.6f66
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We want to be able to encode an arbitrary Unicode string as a
single URL-safe token, using no punctuation but &lt;code&gt;.~-&lt;/code&gt;, in &lt;code&gt;@t&lt;/code&gt;.
Space is &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt; is &lt;code&gt;~.&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; is &lt;code&gt;~~&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; is &lt;code&gt;-&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; ~~foo.bar
&amp;#39;foo bar&amp;#39;
~waclux-tomwyc/try=&amp;gt; ~~foo.bar~.baz~~moo-hoo
&amp;#39;foo bar.baz~moo-hoo&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For all other ASCII/Unicode characters, insert the Unicode
codepoint in lower-case hexadecimal, followed by &lt;code&gt;.&lt;/code&gt;.  For
example, for U+2605 &amp;quot;BLACK STAR&amp;quot;, write:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; ~~foo~2605.bar
&amp;#39;foo★bar&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This UTF-32 codepoint is of course converted to UTF-8:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ux`~~foo~2605.bar
0x72.6162.8598.e26f.6f66
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;URL-safe ASCII text, &lt;code&gt;@ta&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@ta&lt;/code&gt; encodes the ASCII subset that all canonical atom syntaxes
restrict themselves to.  The prefix is &lt;code&gt;~.&lt;/code&gt;.  There are no escape
sequences except &lt;code&gt;~~&lt;/code&gt;, which means &lt;code&gt;~&lt;/code&gt;, and &lt;code&gt;~-&lt;/code&gt;, which means
&lt;code&gt;\_&lt;/code&gt;.  &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;.&lt;/code&gt; encode themselves.  No other characters
besides numbers and lowercase letters need apply.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s cast these to &lt;code&gt;@t&lt;/code&gt; to see them quoted:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@t`~.foo
&amp;#39;foo&amp;#39;
~waclux-tomwyc/try=&amp;gt; `@t`~.foo.bar
&amp;#39;foo.bar&amp;#39;
~waclux-tomwyc/try=&amp;gt; `@t`~.foo~~bar
&amp;#39;foo~bar&amp;#39;
~waclux-tomwyc/try=&amp;gt; `@t`~.foo~-bar
&amp;#39;foo_bar&amp;#39;
~waclux-tomwyc/try=&amp;gt; `@t`~.foo-bar
&amp;#39;foo-bar&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;@ta&lt;/code&gt; atom is called a &lt;code&gt;span&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Codepoint, &lt;code&gt;@c&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Normally when we build atoms of Unicode text, we use a UTF-8
bytestream, LSB first.  But sometimes it&amp;#39;s useful to build atoms
of one or more UTF-32 words.&lt;/p&gt;

&lt;p&gt;The codepoint syntax is the same as &lt;code&gt;@t&lt;/code&gt;, except with a &lt;code&gt;~-&lt;/code&gt;
prefix.  Let&amp;#39;s repeat our examples, with hex display:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ux`~-foo
0x6f.0000.006f.0000.0066

~waclux-tomwyc/try=&amp;gt; `@ux`~-foo.bar
0x72.0000.0061.0000.0062.0000.0020.0000.006f.0000.006f.0000.0066
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Phonemic, &lt;code&gt;@p&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;#39;ve seen &lt;code&gt;@p&lt;/code&gt; used for ships, of course.  But it&amp;#39;s not just for
ships - it&amp;#39;s for any short number optimized for memorability, not
for arithmetic.  &lt;code&gt;@p&lt;/code&gt; is great for checksums, for instance.&lt;/p&gt;

&lt;p&gt;That said, &lt;code&gt;@p&lt;/code&gt; is subtly customized for the sociopolitical
design of Urbit as a digital republic.  For example, one feature
we &lt;em&gt;don&amp;#39;t&lt;/em&gt; want is the ability to see at a glance which carrier
and cruiser issued a destroyer.  Consider the carrier &lt;code&gt;0x21&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@p`0x21
~mep
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It issues &lt;code&gt;255&lt;/code&gt; cruisers, including &lt;code&gt;0x4321&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@p`0x4321
~pasnut
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which issues &lt;code&gt;65.535&lt;/code&gt; destroyers, including &lt;code&gt;0x8765.4321&lt;/code&gt; and
several successors:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@p`0x8765.4321
~famsyr-dirwes
~waclux-tomwyc/try=&amp;gt; `@p`0x8766.4321
~lidlug-maprec
~waclux-tomwyc/try=&amp;gt; `@p`0x8767.4321
~tidlus-roplen
~waclux-tomwyc/try=&amp;gt; `@p`0x8768.4321
~lisnel-lonbet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Of course, anyone who can juggle bits can see that
&lt;code&gt;~famsyr-dirwes&lt;/code&gt; is a close cousin of &lt;code&gt;~lidlug-maprec&lt;/code&gt;.  But she
actually has to juggle bits to do it.  Obfuscation does not
prevent calculated associations, just automatic ones.&lt;/p&gt;

&lt;p&gt;But at the yacht level, we actually want to see a uniform 32-bit
space of yachts directly associated with the destroyer:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@p`0x9.8765.4321
~talfes-sibwaclux-tomwyc-famsyr-dirwes
~waclux-tomwyc/try=&amp;gt; `@p`0xba9.8765.4321
~tacbep-ronreg-famsyr-dirwes
~waclux-tomwyc/try=&amp;gt; `@p`0xd.cba9.8765.4321
~bicsub-ritbyt-famsyr-dirwes
~waclux-tomwyc/try=&amp;gt; `@p`0xfed.cba9.8765.4321
~sivrep-hadfeb-famsyr-dirwes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;IPv4 address, &lt;code&gt;@if&lt;/code&gt;&lt;/h3&gt;

&lt;h3&gt;IPv6 address, &lt;code&gt;@is&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Urbit lives atop IP and would be very foolish to not support
a syntax for the large atoms that are IPv4 and IPv6 addresses.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@if&lt;/code&gt; is the standard IPv4 syntax, prefixed with &lt;code&gt;.&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ux`.127.0.0.1
0x7f00.0001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;@is&lt;/code&gt; is the same as &lt;code&gt;@if&lt;/code&gt;, but with 8 groups of 4 hex digits:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ux`.dead.beef.0.cafe.42.babe.dead.beef
0xdead.beef.0000.cafe.0042.babe.dead.beef
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;IEEE single-precision, &lt;code&gt;@rs&lt;/code&gt;&lt;/h3&gt;

&lt;h3&gt;IEEE double-precision, &lt;code&gt;@rd&lt;/code&gt;&lt;/h3&gt;

&lt;h3&gt;IEEE quad-precision, &lt;code&gt;@rq&lt;/code&gt;&lt;/h3&gt;

&lt;h3&gt;IEEE half-precision, &lt;code&gt;@rh&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Hoon does not yet support floating point, so these syntaxes
don&amp;#39;t actually work.  But the syntax for a single-precision
float is the normal English syntax, with a &lt;code&gt;.&lt;/code&gt; prefix:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;.6.2832             ::  τ as @rs
.-6.2832            ::  -τ as @rs
.~6.2832            ::  τ as @rd
.~-6.2832           ::  -τ as @rd
.~~6.2832           ::  τ as @rh
.~~~6.2832          ::  τ as @rq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Hoon is a Tauist language and promotes International Tau Day.)&lt;/p&gt;

&lt;h3&gt;Transparent cell syntax&lt;/h3&gt;

&lt;p&gt;By adding &lt;code&gt;_&lt;/code&gt;, we can encode arbitrary nouns in our safe subset.
The prefix to a canonical cell is &lt;code&gt;._&lt;/code&gt;; the separator is &lt;code&gt;_&lt;/code&gt;;
the terminator is &lt;code&gt;__&lt;/code&gt;.  Thus:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; ._3_4__
[3 4]

~waclux-tomwyc/try=&amp;gt; :type; ._.127.0.0.1_._0x12_19___~tasfyn-partyv__
[.127.0.0.1 [0x12 19] ~tasfyn-partyv]
[@if [@ux @ud] @p]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Those who don&amp;#39;t see utility in this strange feature have
perhaps never needed to jam a data structure into a URL.&lt;/p&gt;

&lt;h3&gt;Opaque noun syntax&lt;/h3&gt;

&lt;p&gt;Speaking of jam, sometimes we really don&amp;#39;t care what&amp;#39;s inside our
noun.  Then, the syntax to use is a variant of &lt;code&gt;@uw&lt;/code&gt; prefixed by
&lt;code&gt;~&lt;/code&gt;, which incorporates the built-in &lt;code&gt;jam&lt;/code&gt; and &lt;code&gt;cue&lt;/code&gt; marshallers:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; (jam [3 4])
78.241
~waclux-tomwyc/try=&amp;gt; `@uw`(jam [3 4])
0wj6x
~waclux-tomwyc/try=&amp;gt; (cue 0wj6x)
[3 4]
~waclux-tomwyc/try=&amp;gt; ~0wj6x
[3 4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Noncanonical syntaxes&lt;/h2&gt;

&lt;p&gt;These are syntaxes for constants which don&amp;#39;t fit the canonical
character-set constraints.&lt;/p&gt;

&lt;h3&gt;Hoon symbol, &lt;code&gt;@tas&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@tas&lt;/code&gt;, a &lt;code&gt;term&lt;/code&gt;, is our most exclusive odor.  The only
characters permitted are lowercase ASCII, &lt;code&gt;-&lt;/code&gt; except as the first
or last character, and &lt;code&gt;0-9&lt;/code&gt; except as the first character.&lt;/p&gt;

&lt;p&gt;The syntax for &lt;code&gt;@tas&lt;/code&gt; is the text itself, always preceded by &lt;code&gt;%&lt;/code&gt;.
This means a term is always cubical.  You can cast it to &lt;code&gt;@tas&lt;/code&gt;
if you like, but we just about always want the cube:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; %dead-fish9
%dead-fish9

~waclux-tomwyc/try=&amp;gt; -:!&amp;gt;(%dead-fish9)
[%cube p=271.101.667.197.767.630.546.276 q=[%atom p=%tas]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The empty &lt;code&gt;@tas&lt;/code&gt; has a special syntax, &lt;code&gt;$&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; %$
%$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A term without &lt;code&gt;%&lt;/code&gt; is not a constant, but a name:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; dead-fish9
! -find-limb.dead-fish9
! find-none
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Loobeans, &lt;code&gt;@f&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;.y&lt;/code&gt; is a little cumbersome, so we can say &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;.
The &lt;code&gt;%&lt;/code&gt; prefix cubes as usual.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; `@ud`&amp;amp;
0
~waclux-tomwyc/try=&amp;gt; `@ud`|
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Cords, &lt;code&gt;@t&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The canonical &lt;code&gt;~~&lt;/code&gt; syntax for &lt;code&gt;@t&lt;/code&gt;, while it has its place, 
is intolerable in a number of ways - especially when it comes to
escaping capitals.  So &lt;code&gt;@t&lt;/code&gt; is both printed and parsed in a
conventional-looking single-quote syntax:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; &amp;#39;foo bar&amp;#39;
&amp;#39;foo bar&amp;#39;
~waclux-tomwyc/try=&amp;gt; `@ux`&amp;#39;foo bar&amp;#39;
0x72.6162.206f.6f66
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Escape &lt;code&gt;&amp;#39;&lt;/code&gt; with &lt;code&gt;\&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; &amp;#39;Foo \&amp;#39;bar&amp;#39;
&amp;#39;Foo \&amp;#39;bar&amp;#39;
~waclux-tomwyc/try=&amp;gt; `@ux`&amp;#39;\&amp;#39;&amp;#39;
0x27
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Strings&lt;/h3&gt;

&lt;p&gt;Text in Hoon is generally manipulated in two ways, depending on
what you&amp;#39;re doing: as an atomic cord/span/term, or as a &lt;code&gt;tape&lt;/code&gt;
which is a list of bytes (&lt;em&gt;not&lt;/em&gt; codepoints).&lt;/p&gt;

&lt;p&gt;To generate a tape, use double quotes:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; &amp;quot;foo&amp;quot;
&amp;quot;foo&amp;quot;
~waclux-tomwyc/try=&amp;gt; `*`&amp;quot;foo&amp;quot;
[102 111 111 0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#39;re getting off the constant reservation, but strings also
interpolate with curly-braces:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; &amp;quot;hello {(weld &amp;quot;wor&amp;quot; &amp;quot;ld&amp;quot;)} is a fun thing to say&amp;quot;
&amp;quot;hello world is a fun thing to say&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And they can be joined across space or lines with a &lt;code&gt;.&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; &amp;quot;hello&amp;quot;.&amp;quot;world&amp;quot;
&amp;quot;helloworld&amp;quot;
~waclux-tomwyc/try=&amp;gt; &amp;quot;hello&amp;quot;. &amp;quot;world&amp;quot;
&amp;quot;helloworld&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch4&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Using Nock&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch6&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Moar Hoon Types&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Chapter IV (Using Nock)</title>
   <link href="http://urbit.org/doc/2013/11/18/ch4/"/>
   <updated>2013-11-18T00:00:00-08:00</updated>
   <id>http://urbit.org/doc/2013/11/18/ch4</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch3&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Nock Is Easy&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch5&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Hoon Attacks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;quot;But are you crazy enough?&amp;quot;&lt;/em&gt;
&lt;strong&gt;(Point Break)&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;Playing with Nock&lt;/h2&gt;

&lt;p&gt;Now we&amp;#39;re going to actually do some cool stuff with Nock.&lt;/p&gt;

&lt;p&gt;Fortunately, we have an entire OS, Arvo, which is built on Nock.
Unfortunately, there&amp;#39;s really no practical reason to work
directly in Nock when you&amp;#39;re using Arvo - except for learning
Nock, which you do once and never again.  So the things we&amp;#39;ll
have to do are a little bit cumbersome.&lt;/p&gt;

&lt;p&gt;What Arvo is good at is evaluating Hoon.  And it&amp;#39;s possible to
evaluate Nock from Hoon, much the way you can put inline assembly
in C.  Through this indirection, we have two ways to run Nock in
Hoon: on the command line and via an app file.&lt;/p&gt;

&lt;h3&gt;Command line&lt;/h3&gt;

&lt;p&gt;From the Arvo command line, you can run one-liners with the Hoon
rune &lt;code&gt;.*&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; .*(42 [4 0 1])
43
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Application file&lt;/h3&gt;

&lt;p&gt;Unfortunately, the Arvo command line doesn&amp;#39;t do multiline input
well, and if there&amp;#39;s any hope of writing complex Nock formulas
it&amp;#39;s by using plenty of whitespace and linebreaks.&lt;/p&gt;

&lt;p&gt;So we&amp;#39;ve constructed a template for writing Nock formulas as Arvo
applications.  Unfortunately Arvo is a young OS and has no way to
edit a file.  But Arvo runs on Unix and Unix is a very old OS.
Arvo syncs its filesystem with your &lt;code&gt;$URBIT_HOME&lt;/code&gt; directory,
propagating changes on either side.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s assume your &lt;code&gt;$URBIT_HOME&lt;/code&gt; is &lt;code&gt;urb/&lt;/code&gt;, and your ship is
&lt;code&gt;~waclux-tomwyc&lt;/code&gt;.  The Nock application template is in&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;urb/waclux-tomwyc/try/bin/nock.hoon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Its text should be:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;!:             ::  To write Nock as an Arvo application in Hoon
|=  *          ::
|=  [a=* ~]    ::  For educational purposes only
:_  ~  :_  ~   ::
:-  %la        ::  Preserve this mysterious boilerplate square
%+  sell  %noun::
.*  a          ::  Replace the formula with your own
:::::::::::::::::
               ::  Formula: increment
[4 0 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the rest of this document we&amp;#39;ll simply assume you can copy
boilerplate, and write the rest of the file:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[4 0 1]                           ::    bump /1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(The pseudocode in the comments is not in any way described.  If
you have trouble figuring it out, that&amp;#39;s okay, because it should
make itself obvious by the end of the document.)&lt;/p&gt;

&lt;p&gt;Test this by running:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :nock 42
43
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our first complex example will be a decrement function.  With or
without &lt;code&gt;vere&lt;/code&gt; running, copy the template from Unix:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ cp urb/waclux-tomwyc/try/bin/nock.hoon urb/waclux-tomwyc/try/bin/dec.hoon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, use a Unix editor to change &amp;quot;Formula: increment&amp;quot; to
&amp;quot;Formula: decrement&amp;quot; in &lt;code&gt;dec.hoon&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Either next time you start &lt;code&gt;vere&lt;/code&gt;, or on your next keyboard event
if you&amp;#39;re already running it, you&amp;#39;ll see something like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt; + /~waclux-tomwyc/try/1/bin/dec/hoon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Arvo has slurped up dec.hoon from your filesystem.  To test it,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :dec 42
43
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Well, we didn&amp;#39;t change the formula, so it still increments.  But
it&amp;#39;s a start.&lt;/p&gt;

&lt;h2&gt;Decrement&lt;/h2&gt;

&lt;p&gt;The only arithmetic operation in Nock is increment.  So how do we
decrement?  The algorithm is obvious: to decrement &lt;code&gt;n&lt;/code&gt;, start
from &lt;code&gt;0&lt;/code&gt;, and count up to &lt;code&gt;n-1&lt;/code&gt;.  Or rather, count up to a number
&lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;m+1&lt;/code&gt; equals &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(Is this going to be an &lt;code&gt;O(n)&lt;/code&gt; algorithm?  It is.  How do we
compute effectively in a platform where decrement is &lt;code&gt;O(n)&lt;/code&gt;?
Gosh, it seems difficult, doesn&amp;#39;t it?  We&amp;#39;ll get to that.)&lt;/p&gt;

&lt;p&gt;The first thing we&amp;#39;re going to need is a counter.  Right now
our subject is just the atom we&amp;#39;re trying to decrement - &lt;code&gt;/1&lt;/code&gt;,
referenced with the formula &lt;code&gt;[0 1]&lt;/code&gt;.  Thus, to increment it,
the formula is &lt;code&gt;[4 0 1]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s try to put the counter into the subject with one of our
macros operators, &lt;code&gt;8&lt;/code&gt;.  Recall our revised rule for &lt;code&gt;8&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;34r::    *[a 8 b c]       *[[*[a b] a] c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The formula &lt;code&gt;c&lt;/code&gt; is applied to the subject &lt;code&gt;[*[a b] a]&lt;/code&gt;.  What is
our &lt;code&gt;b&lt;/code&gt;?  It should just produce our initial counter value - 0.
So, use operator &lt;code&gt;1&lt;/code&gt; to produce a constant - &lt;code&gt;[1 0]&lt;/code&gt;.  Let&amp;#39;s
put this counter in the subject, and then increment as usual.&lt;/p&gt;

&lt;p&gt;Edit &lt;code&gt;dec.hoon&lt;/code&gt; so that the formula reads&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8                               ::  push
  [1 0]                           ::    just 0
  [4 0 1]                         ::    bump /1
]                                 ::
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that for these tall bracket structures, the space after &lt;code&gt;[&lt;/code&gt;
is essential.  Then, you&amp;#39;ll see the file automatically update in
Arvo:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/2/bin/dec/hoon
~waclux-tomwyc/try=&amp;gt; :dec 42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Whoops!  It crashed:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;! /~waclux-tomwyc/try/~2013.11.26..00.01.38..499b/bin/dec/:&amp;lt;[4 1].[13 2]&amp;gt;
! /~waclux-tomwyc/try/~2013.11.26..00.01.38..499b/bin/dec/:&amp;lt;[4 8].[13 2]&amp;gt;
! /~waclux-tomwyc/try/~2013.11.26..00.01.38..499b/bin/dec/:&amp;lt;[5 1].[13 2]&amp;gt;
! /~waclux-tomwyc/try/~2013.11.26..00.01.38..499b/bin/dec/:&amp;lt;[6 1].[13 2]&amp;gt;
! /~waclux-tomwyc/try/~2013.11.26..00.01.38..499b/bin/dec/:&amp;lt;[7 1].[13 2]&amp;gt;
! exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What did we do wrong?  We forgot that the subject had changed.
When we get to &lt;code&gt;[4 0 1]&lt;/code&gt;, the subject is not &lt;code&gt;42&lt;/code&gt;, but &lt;code&gt;[0 42]&lt;/code&gt; -
the counter is there.  So our original argument, &lt;code&gt;42&lt;/code&gt;, is
actually at &lt;code&gt;/3&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8                               ::  push
  [1 0]                           ::   just 0
  [4 0 3]                         ::   bump /3
]                                 ::

: /~waclux-tomwyc/try/3/bin/dec/hoon
~waclux-tomwyc/try=&amp;gt; :dec 42
43
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Okay, at least it increments again.  (Constantly readjusting tree
addresses by hand is one good reason to use a higher-level
language, like Hoon.) But now, perhaps, we can build a decrement
that works for at least one input value - &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Obviously at some point we&amp;#39;ll have to build a loop.  But for now,
all we need is an &lt;code&gt;if&lt;/code&gt; statement that compares the incremented
counter to the original argument.  We know the original argument
is at &lt;code&gt;/3&lt;/code&gt;, and the counter is at &lt;code&gt;/2&lt;/code&gt;; we use the if operator,
&lt;code&gt;6&lt;/code&gt;, and the equality test operator &lt;code&gt;5&lt;/code&gt;.  If the comparison
fails, we shrug our shoulders and keep incrementing the argument.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8                               ::  push
  [1 0]                           ::   just 0
  [ 6                             ::   pick
    [5 [4 0 2] [0 3]]             ::    same (bump /2) /3
    [0 2]                         ::    /2
    [4 0 3]                       ::    bump /3
  ]                               ::   |
]                                 ::  |

: /~waclux-tomwyc/try/4/bin/dec/hoon
~waclux-tomwyc/try=&amp;gt; :dec 42
43
~waclux-tomwyc/try=&amp;gt; :dec 1
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#39;re getting closer.  But now, that loop:&lt;/p&gt;

&lt;p&gt;Up till now, our subject has contained only data.  If we want to
loop, we&amp;#39;re obviously going to have to bite the bullet and put
code in our subject - which will become a &lt;code&gt;[code data]&lt;/code&gt; cell.
In Nock (and Hoon) this is called a &lt;code&gt;core&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Suppose we take our &lt;code&gt;6&lt;/code&gt; formula and put it in the subject.  Then,
with this core subject &lt;code&gt;[formula counter argument]&lt;/code&gt;, we&amp;#39;ll run
the formula itself.  With this subject, the formula is &lt;code&gt;/2&lt;/code&gt;, and
of course the core itself is &lt;code&gt;/1&lt;/code&gt;.  So we can activate the core
with &lt;code&gt;[2 [0 1] [0 2]]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course, since the subject has changed again, we need to change
the addresses again.  The counter is now &lt;code&gt;/6&lt;/code&gt; and the argument
is now &lt;code&gt;/7&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8                               ::  push
  [1 0]                           ::   just 0
  [ 8                             ::   push
    [ 1                           ::    quid
      [ 6                         ::     pick
        [5 [4 0 6] [0 7]]         ::      same (bump /6) /7
        [0 6]                     ::      /6
        [4 0 7]                   ::      bump /7
      ]                           ::     |
    ]                             ::    |
    [2 [0 1] [0 2]]               ::    nock /1 /2
  ]                               ::   |
]                                 ::  |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This does exactly the same thing as before:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/5/bin/dec/hoon
~waclux-tomwyc/try=&amp;gt; :dec 42
43
~waclux-tomwyc/try=&amp;gt; :dec 1
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But somehow, we feel it &lt;em&gt;could&lt;/em&gt; do better.  Why?  Because where
we do the useless &lt;code&gt;[4 0 7]&lt;/code&gt;, we have a subject containing the
code we want to invoke.  It&amp;#39;s just that the counter is wrong.&lt;/p&gt;

&lt;p&gt;We need to do the same thing as &lt;code&gt;[2 [0 1] [0 2]&lt;/code&gt;, but the subject
is not &lt;code&gt;[0 1]&lt;/code&gt;.  That would be &lt;code&gt;[formula counter argument]&lt;/code&gt;.  We
need &lt;code&gt;[formula (counter + 1) argument]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, &lt;code&gt;formula&lt;/code&gt; is &lt;code&gt;[0 2]&lt;/code&gt;, &lt;code&gt;counter&lt;/code&gt; is &lt;code&gt;[0 6]&lt;/code&gt;, and &lt;code&gt;argument&lt;/code&gt; is
&lt;code&gt;[0 7]&lt;/code&gt;.  With autocons, we can just put them together to make a
(superfluous) formula for &lt;code&gt;[formula counter argument]&lt;/code&gt; - ie,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[[0 2] [0 6] [0 7]]               ::  cons /2 /6 /7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But we actually want to increment the counter:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[[0 2] [4 0 6] [0 7]]             ::  cons /2 (bump /6) /7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And to invoke our formula on this modified core:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[2 [[0 2] [4 0 6] [0 7]] [0 2]]   ::  nock (cons /2 (bump /6) /7) /2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we put this into the decrement, it should actually work:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8                               ::  push
  [1 0]                           ::   just 0
  [ 8                             ::   push
    [ 1                           ::    quid
      [ 6                         ::     pick
        [5 [4 0 6] [0 7]]         ::      same (bump /6) /7
        [0 6]                     ::      /6
        [ 2                       ::      nock
           [[0 2] [4 0 6] [0 7]]  ::       (cons /2 (bump /6) /7)
           [0 2]                  ::       /2
        ]                         ::      |
      ]                           ::     |
    ]                             ::    |
    [2 [0 1] [0 2]]               ::    nock /1 /2
  ]                               ::   |
]                                 ::  |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And it does:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/6/bin/dec/hoon
~waclux-tomwyc/try=&amp;gt; :dec 42
41
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But there&amp;#39;s one more step.  Remember operator &lt;code&gt;9&lt;/code&gt;?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;35 ::    *[a 9 b c]       *[a 7 c 2 [0 1] 0 b]
35r::    *[a 9 b c]       *[*[a c] *[*[a c] 0 b]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Suppose &lt;code&gt;c&lt;/code&gt; is a formula that produces a core.  Then we see
immediately what &lt;code&gt;9&lt;/code&gt; does: it activates a core, using the formula
at &lt;code&gt;/b&lt;/code&gt; within the core.&lt;/p&gt;

&lt;p&gt;So we can rewrite our decrement to use &lt;code&gt;9&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8                               ::  push
  [1 0]                           ::   just 0
  [ 8                             ::   push
    [ 1                           ::    quid
      [ 6                         ::     pick
        [5 [4 0 6] [0 7]]         ::      same (bump /6) /7
        [0 6]                     ::      /6
        [9 2 [0 2] [4 0 6] [0 7]] ::      call.2 (cons /2 (bump /6) /7)
      ]                           ::     |
    ]                             ::    |
    [9 2 0 1]                     ::    call.2 /1
  ]                               ::   |
]                                 ::  |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Seems to work nicely:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;: /~waclux-tomwyc/try/6/bin/dec/hoon
~waclux-tomwyc/try=&amp;gt; :dec 42
41
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Of course, there are limits:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :dec 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You&amp;#39;ll have to hit &lt;code&gt;^C&lt;/code&gt;, and you&amp;#39;ll see a big ugly error stack.
Nock can work wonders but it can&amp;#39;t decrement 0.  (Yes, you can
build signed integers in Hoon - they are represented as atoms
with the sign bit low.)&lt;/p&gt;

&lt;h3&gt;A function&lt;/h3&gt;

&lt;p&gt;As we start to build up toward language-level primitives, it
behooves us to do things the way a higher-level language would do
them.  Well, more exactly, the way Hoon does things.&lt;/p&gt;

&lt;p&gt;Surprisingly, although a formula defines a function of the
subject, a function - at the language level - is not the same
thing as a formula.  Or rather, the argument is not the same
thing as the subject.&lt;/p&gt;

&lt;p&gt;For instance, as we saw in decrement, the subject for the loop
needs to contain the code itself.  If we apply a formula which
can&amp;#39;t call back into itself, our ability to loop is sorely
diminished.  So at the very least, when we call a function,
the subject can&amp;#39;t just be &lt;code&gt;argument&lt;/code&gt; - it has to be the cell
&lt;code&gt;[formula argument]&lt;/code&gt;, so that the function can recurse.&lt;/p&gt;

&lt;p&gt;Actually, it&amp;#39;s confusing to say &lt;code&gt;argument&lt;/code&gt;, because this implies
a special status for single and multiple arguments.  In Nock and
Hoon, we say &lt;code&gt;sample&lt;/code&gt;, which is always one thing, but can be a
cell for &amp;quot;functions of two arguments&amp;quot;, a triple for three, etc.
Eg, the sample for a decrement function is an atom; the sample
for an add function is a cell of two atoms; etc.&lt;/p&gt;

&lt;p&gt;Furthermore, a function needs more data than just the argument -
it might, for instance, want to call other functions.  Where&amp;#39;s it
going to get them?  There is no external environment in Nock.&lt;/p&gt;

&lt;p&gt;So the standard convention for a Nock function - or a Hoon
function - is&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[formula sample context]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;code&gt;formula&lt;/code&gt; is the code, &lt;code&gt;sample&lt;/code&gt; is the argument(s), and
&lt;code&gt;context&lt;/code&gt; is any other data and/or code that may be useful.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s a bit irregular that we are taking the external subject
and using it directly from our formula.  Let&amp;#39;s try to build a
function with this convention and call it directly.&lt;/p&gt;

&lt;p&gt;First, we&amp;#39;ll build an increment function to keep things simple.
We actually don&amp;#39;t need anything in the context, so we&amp;#39;ll put 0.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8                               ::  push
  [                               ::   cons
    [1 [4 0 6]]                   ::    quid bump /6  ::  formula
    [1 0]                         ::    just 0        ::  sample
    [1 0]                         ::    just 0        ::  context
  ]                               ::   |
  [ 9                             ::   call
    2                             ::    .2
    [0 4] [0 3] [0 11]            ::    cons /4 /3 /11
  ]                               ::   |
]                                 ::  |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Why &lt;code&gt;[[0 4] [0 3] [0 11]]&lt;/code&gt;?  Our goal in calling the function is
to take the blank default core we&amp;#39;ve created at &lt;code&gt;/2&lt;/code&gt;, and
substitute in the original subject of the outer formula, which
before the outer &lt;code&gt;8&lt;/code&gt; was &lt;code&gt;/1&lt;/code&gt; and is now &lt;code&gt;/3&lt;/code&gt;.  Around this
we wrap the formula from the default core, at &lt;code&gt;/4&lt;/code&gt;, and the
(dummy) context, at &lt;code&gt;/11&lt;/code&gt; - that is, &lt;code&gt;/7&lt;/code&gt; within &lt;code&gt;/2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s fit our decrement into this framework:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8                                     ::  push
  [                                     ::   cons
    [ 1                                 ::    quid    ::  formula
      [ 8                               ::     push
        [1 0]                           ::      just 0
        [ 8                             ::      push
          [ 1                           ::       quid
            [ 6                         ::        pick
              [5 [4 0 6] [0 30]]        ::         same /6 /30
              [0 6]                     ::         /6
              [9 2 [0 2] [4 0 6] [0 7]] ::         call.2 /2 (bump /6) /11
            ]                           ::        |
          ]                             ::       |
          [9 2 0 1]                     ::       call.2 /1
        ]                               ::      |
      ]                                 ::     |
    ]                                   ::    |
    [1 0]                               ::    just 0  ::  sample
    [1 0]                               ::    just 0  ::  context
  ]                                     ::   |
  [9 2 [0 4] [0 3] [0 11]]              ::   call.2 /4 /3 /11
]                                       ::  |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Observe that nothing has changed from the way we called our
increment function, and only one thing has changed within the
decrement formula - the axis of the argument.  Now at &lt;code&gt;/7&lt;/code&gt; is not
the naked argument to decrement, but our outer core.  The sample
is at &lt;code&gt;/6&lt;/code&gt; within this &lt;code&gt;/7&lt;/code&gt;, ie, at &lt;code&gt;/30&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;A library&lt;/h2&gt;

&lt;p&gt;Frankly, this is getting close to the limits of anything you&amp;#39;d
want to do in hand-generated Nock.  But why not press on?&lt;/p&gt;

&lt;p&gt;What we&amp;#39;d really like to do is build a library of functions that
can call each other.  It&amp;#39;s easy to guess that this library will
be a core.  But what does this core look like?&lt;/p&gt;

&lt;p&gt;A function core, &lt;code&gt;[formula sample context]&lt;/code&gt;, is a very useful
kind of core, but it&amp;#39;s not the only kind of core.  (Actually,
because the word &amp;quot;function&amp;quot; is too easy to throw around, we have
a special name for a function core: we call it a &lt;code&gt;gate&lt;/code&gt;.  Compare
to &amp;quot;lambda&amp;quot; or &amp;quot;closure.&amp;quot;)&lt;/p&gt;

&lt;p&gt;But in general, a core is just &lt;code&gt;[code data]&lt;/code&gt; - or, to use more
lingo, &lt;code&gt;[battery payload]&lt;/code&gt;.  The payload can be anything - it&amp;#39;s
just data.&lt;/p&gt;

&lt;p&gt;The battery can be one &lt;em&gt;or more&lt;/em&gt; formulas, each of which is
applied with the core as its subject.  This is why &lt;code&gt;9&lt;/code&gt; takes the
axis operand &lt;code&gt;b&lt;/code&gt;.  If the core is a gate, the battery is just one
formula; this is the head of the core, so &lt;code&gt;b&lt;/code&gt; is 2.&lt;/p&gt;

&lt;p&gt;But not every core is a gate.  Suppose we want to build a
library?  We could assemble a bundle of cores and put it in
the context.  So, let&amp;#39;s say we need to write subtract, which
obviously is going to use decrement.  So, the context will be&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[subtract-gate decrement-gate]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But wait.  Each gate is &lt;code&gt;[formula sample context]&lt;/code&gt;.  So, because
Nock doesn&amp;#39;t do cycles, there&amp;#39;s no way the subtract gate and the
decrement gate can each reference each other through the context.
It happens to be the case here that subtract needs decrement, but
decrement doesn&amp;#39;t need subtract.  But we&amp;#39;re not looking for ugly
at this point - we know Nock is more than capable of that.&lt;/p&gt;

&lt;p&gt;To support general mutual recursion, our library needs to be a
battery in which each formula produces a gate.  The context of
that gate is the library core.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s repeat this again because it&amp;#39;s so important.  Our library
will be a battery in which each formula produces a gate.  The
context of that gate is the library core.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s build a trivial library core of this form, with one
function, good old increment.  Then, we&amp;#39;ll call it.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8                               ::  push
  [                               ::   cons
    [ 1                           ::    quid          ::  battery
      [1 [4 0 6]]                 ::     quid bump /6
      [1 0]                       ::     just 0
      [0 1]                       ::     /1
    ]                             ::    |
    [1 0]                         ::    just 0        ::  payload
  ]                               ::   |
  [ 8                             ::   push
    [9 2 0 2]                     ::    call.2 /2
    [9 2 [0 4] [0 7] [0 11]]      ::    call.2 /4 /7 /11
  ]                               ::   |
]                                 ::  |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Compare this to the standalone increment above.  It&amp;#39;s obviously
more complex and it should be.&lt;/p&gt;

&lt;p&gt;First of all, what we put in the library core is not the function
gate directly, but a formula that generates the gate.  This way,
and only this way, we can put the library itself in the context.&lt;/p&gt;

&lt;p&gt;Second, what&amp;#39;s the payload of the library core?  It&amp;#39;s &lt;code&gt;0&lt;/code&gt;,
because the library doesn&amp;#39;t depend on anything.  It certainly
doesn&amp;#39;t depend on the argument to our application.&lt;/p&gt;

&lt;p&gt;Third, now we can&amp;#39;t just call the gate directly.  We have to
actually build it.  So we need another &lt;code&gt;8&lt;/code&gt; to &amp;quot;push it on the
stack&amp;quot;, and then we call it with the usual &lt;code&gt;9&lt;/code&gt;.  Since the
subject at this point is &lt;code&gt;[gate library argument]&lt;/code&gt;, the sample we
use is &lt;code&gt;[0 7]&lt;/code&gt; rather than &lt;code&gt;[0 3]&lt;/code&gt; - everything else is the same.&lt;/p&gt;

&lt;p&gt;But does it work?  C&amp;#39;mon, you know it works:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :dec 42
43
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Okay, let&amp;#39;s go ahead and put our actual decrement function in
the library.  We won&amp;#39;t write the pseudocode here, because it&amp;#39;s an
excellent exercise to add it - see below.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8
  [
    [ 1
      [ 1
        [ 8
          [1 0]
          [ 8
            [ 1
              [ 6
                [5 [4 0 6] [0 30]]
                [0 6]
                [9 2 [0 2] [4 0 6] [0 7]]
              ]
            ]
            [9 2 0 1]
          ]
        ]
      ]
      [1 0]
      [0 1]
    ]
    [1 0]
  ]
  [ 8
    [9 2 0 2]
    [ 9
      2
      [0 4] [0 7] [0 11]
    ]
  ]
]

~waclux-tomwyc/try=&amp;gt; :dec 42
43
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, let&amp;#39;s go crazy and add a subtract function, which calls
decrement.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ 8
  [
    [
      [ 1
        [ 1
          [ 8
            [9 5 0 7]
            [ 6
              [5 [1 0] [0 29]]
              [0 28]
              [ 9
                2
                [0 6]
                [ [9 2 [0 4] [0 28] [0 15]]
                  [9 2 [0 4] [0 29] [0 15]]
                ]
                [0 15]
              ]
            ]
          ]
        ]
        [1 0]
        [0 1]
      ]
      [ 1
        [ 1
          [ 8
            [1 0]
            [ 8
              [ 1
                [ 6
                  [5 [4 0 6] [0 30]]
                  [0 6]
                  [9 2 [0 2] [4 0 6] [0 7]]
                ]
              ]
              [9 2 0 1]
            ]
          ]
        ]
        [1 0]
        [0 1]
      ]
    ]
    [1 0]
  ]
  [ 8
    [9 4 0 2]
    [ 9
      2
      [0 4] [0 7] [0 11]
    ]
  ]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the call to build the gate is &lt;code&gt;[9 4 0 2]&lt;/code&gt;, because the
subtract arm is the head of the battery, which is the head of the
core - ie, &lt;code&gt;/2&lt;/code&gt; within &lt;code&gt;/2&lt;/code&gt; - ie, &lt;code&gt;/4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Does this work?  Really?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; :dec [42 12]
30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Exercises&lt;/h2&gt;

&lt;p&gt;Do you actually know Nock now?  Well, possibly.&lt;/p&gt;

&lt;p&gt;A good exercise is to add more simple math functions to this
battery.  Try add, multiply, and divide.  One way to start is by
walking through the uncommented routines above, putting
pseudocode comments on them, and figuring out what they&amp;#39;re doing.&lt;/p&gt;

&lt;p&gt;Computing axes is slightly arduous (which is why we use Hoon,
generally).  We are torturing ourselves by using Nock, but we
might as well use Hoon to calculate axes:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~waclux-tomwyc/try=&amp;gt; (peg 3 3)
7
~waclux-tomwyc/try=&amp;gt; (peg 3 5)
13
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ie, &lt;code&gt;(peg a b)&lt;/code&gt; is &lt;code&gt;/b&lt;/code&gt; within &lt;code&gt;/a&lt;/code&gt;.  Writing Nock without this
would be pretty tough.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch3&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Nock Is Easy&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch5&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Hoon Attacks&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Chapter III (Nock Is Easy)</title>
   <link href="http://urbit.org/doc/2013/11/18/ch3/"/>
   <updated>2013-11-18T00:00:00-08:00</updated>
   <id>http://urbit.org/doc/2013/11/18/ch3</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch2&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Intro To Nock&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch4&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Using Nock&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;quot;You get used to it. I don’t even see the code. All I see is blonde, brunette, redhead.&amp;quot;&lt;/em&gt;
&lt;strong&gt;(The Matrix)&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;Fundamentals&lt;/h2&gt;

&lt;p&gt;Now that we have all the tools, let&amp;#39;s learn Nock from scratch.
Here are all the rules defining &lt;code&gt;*&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;23 ::    *[a [b c] d]     [*[a b c] *[a d]]
24 ::
25 ::    *[a 0 b]         /[b a]
26 ::    *[a 1 b]         b
27 ::    *[a 2 b c]       *[*[a b] *[a c]]
28 ::    *[a 3 b]         ?*[a b]
29 ::    *[a 4 b]         +*[a b]
30 ::    *[a 5 b]         =*[a b]
31 ::
32 ::    *[a 6 b c d]     *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
33 ::    *[a 7 b c]       *[a 2 b 1 c]
34 ::    *[a 8 b c]       *[a 7 [[7 [0 1] b] 0 1] c]
35 ::    *[a 9 b c]       *[a 7 c 2 [0 1] 0 b]
36 ::    *[a 10 [b c] d]  *[a 8 c 7 [0 3] d]
37 ::    *[a 10 b c]      *[a c]
38 ::
39 ::    *a               *a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As we saw in the last chapter, when &lt;code&gt;a&lt;/code&gt; is an atom, &lt;code&gt;*a&lt;/code&gt; is
always an error.  So Nock proper is a function of a cell.
Informally, that cell is always described as a pair&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[subject formula]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code&gt;subject&lt;/code&gt; is the data and &lt;code&gt;formula&lt;/code&gt; is the program.  Notice
that &lt;code&gt;a&lt;/code&gt; in the rules above, except 39, is always the subject.
So: let&amp;#39;s learn how to write a Nock formula.&lt;/p&gt;

&lt;h2&gt;Autocons&lt;/h2&gt;

&lt;p&gt;We observe from the rules above that a formula, too, is always a
cell.  But when we look inside that cell, we see two basic kinds
of formulas:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[operator operands]
[formula formula]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An operator is always an atom (&lt;code&gt;0&lt;/code&gt; through &lt;code&gt;10&lt;/code&gt;).  A formula is
always a cell.  Line 23 distinguishes these forms:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;23 ::    *[a [b c] d]     [*[a b c] *[a d]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Suppose you have two formulas &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;, each of which computes
some function of the subject &lt;code&gt;s&lt;/code&gt;.  You can then construct the
formula &lt;code&gt;h&lt;/code&gt; as &lt;code&gt;[f g]&lt;/code&gt;; and &lt;code&gt;h(s)&lt;/code&gt; equals &lt;code&gt;[f(s) g(s)]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For instance, recall our computation from the last chapter:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;*[[19 42] [0 3] 0 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;s&lt;/code&gt; is &lt;code&gt;[19 42]&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;[0 3]&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt; is &lt;code&gt;[0 2]&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt; is &lt;code&gt;[[0 3] 0
2]&lt;/code&gt;.  &lt;code&gt;f(s)&lt;/code&gt; is &lt;code&gt;42&lt;/code&gt;; &lt;code&gt;g(s)&lt;/code&gt; is &lt;code&gt;19&lt;/code&gt;; so &lt;code&gt;h(s)&lt;/code&gt; is &lt;code&gt;[42 19]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Why?  We could have an operator &lt;code&gt;11&lt;/code&gt;, &lt;code&gt;cons&lt;/code&gt; to a Lisp veteran,
with the operands &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; - so instead of writing&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[[0 3] 0 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we&amp;#39;d say&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[11 [0 3] 0 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But not only is this less elegant, it&amp;#39;s less convenient.  Of
course, convenience at the Nock level matters little, but we
repeat this pattern at the Hoon level - where it&amp;#39;s often more
pleasant to say &lt;code&gt;[a b]&lt;/code&gt; than &lt;code&gt;(cons a b)&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;Basic operators&lt;/h2&gt;

&lt;p&gt;Nock is small, but it could be smaller.  If we didn&amp;#39;t care at all
about the efficiency of the interpreter - in other words, if Nock
was a theoretical exercise rather than a practical tool - we
could make do with just the first six operators:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;25 ::    *[a 0 b]         /[b a]
26 ::    *[a 1 b]         b
27 ::    *[a 2 b c]       *[*[a b] *[a c]]
28 ::    *[a 3 b]         ?*[a b]
29 ::    *[a 4 b]         +*[a b]
30 ::    *[a 5 b]         =*[a b]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s run through them one by one.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;0&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;0&lt;/code&gt; just applies the &lt;code&gt;/&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;25 ::    *[a 0 b]         /[b a]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For any subject &lt;code&gt;a&lt;/code&gt;, the formula &lt;code&gt;[0 b]&lt;/code&gt; produces &lt;code&gt;/[b a]&lt;/code&gt;, which
is why&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;*[[19 42] 0 3]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is &lt;code&gt;/[3 19 42]&lt;/code&gt;, which is &lt;code&gt;42&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;1&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;1&lt;/code&gt; just ignores its subject and produces its operand:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;26 ::    *[a 1 b]         b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;code&gt;2&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;2&lt;/code&gt; is the only interesting basic operator:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;27 ::    *[a 2 b c]       *[*[a b] *[a c]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we generate a calculation to perform.  Given the formula &lt;code&gt;[2
b c]&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is a formula for generating the new subject; &lt;code&gt;c&lt;/code&gt; is a
formula for generating the new formula.  To compute &lt;code&gt;*[a 2 b c]&lt;/code&gt;,
we evaluate both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; against the current subject &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;3&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;3&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, and &lt;code&gt;5&lt;/code&gt; just apply &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; respectively -
that is, cell/atom, increment, and equals.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;28 ::    *[a 3 b]         ?*[a b]
29 ::    *[a 4 b]         +*[a b]
30 ::    *[a 5 b]         =*[a b]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Macros&lt;/h2&gt;

&lt;p&gt;Operators &lt;code&gt;6&lt;/code&gt; through &lt;code&gt;10&lt;/code&gt; are all essentially macros:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;32 ::    *[a 6 b c d]     *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
33 ::    *[a 7 b c]       *[a 2 b 1 c]
34 ::    *[a 8 b c]       *[a 7 [[7 [0 1] b] 0 1] c]
35 ::    *[a 9 b c]       *[a 7 c 2 [0 1] 0 b]
36 ::    *[a 10 [b c] d]  *[a 8 c 7 [0 3] d]
37 ::    *[a 10 b c]      *[a c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each of these cases just resolves to another Nock computation, in
which each pattern matched on the left appears no more than once
on the right.  I.e., it&amp;#39;s a macro.  But what do the macros do?
Let&amp;#39;s work through them, from easiest to hardest.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;10&lt;/code&gt; (37)&lt;/h3&gt;

&lt;p&gt;The second case of 10 is so easy it&amp;#39;s puzzling:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;37 ::    *[a 10 b c]      *[a c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For any &lt;code&gt;b&lt;/code&gt;, the formula &lt;code&gt;[10 b c]&lt;/code&gt; seems to be perfectly
equivalent to the formula &lt;code&gt;c&lt;/code&gt;.  But why?  Why would we say
&lt;code&gt;[10 b c]&lt;/code&gt; when we could just say &lt;code&gt;c&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;The answer is that &lt;code&gt;10&lt;/code&gt; is a hint to the interpreter.  It&amp;#39;s true
that &lt;code&gt;[10 b c]&lt;/code&gt; has to be &lt;em&gt;semantically&lt;/em&gt; equivalent to &lt;code&gt;c&lt;/code&gt;, but
it doesn&amp;#39;t have to be &lt;em&gt;practically&lt;/em&gt; equivalent.  Since whatever
information is in &lt;code&gt;b&lt;/code&gt; is discarded, a practical interpreter is
free to ignore it, or to use it in any way that does not affect
the results of the computation.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;7&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;7&lt;/code&gt; is our next easiest macro:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;33 ::    *[a 7 b c]       *[a 2 b 1 c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Informally, the formula &lt;code&gt;[7 b c]&lt;/code&gt; composes the formulas &lt;code&gt;b&lt;/code&gt; and
&lt;code&gt;c&lt;/code&gt;.  To use a bit of math notation, if &lt;code&gt;d&lt;/code&gt; is &lt;code&gt;[7 b c]&lt;/code&gt;,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;d(a) == c(b(a))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s see how this works by applying some reductions to the
definition of &lt;code&gt;7&lt;/code&gt;, and producing a simpler definition that
doesn&amp;#39;t look like a macro:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;*[a 2 b 1 c]

    &amp;lt;&amp;lt;27 ::    *[a 2 b c]       *[*[a b] *[a c]]&amp;gt;&amp;gt;

*[*[a b] *[a 1 c]]

    &amp;lt;&amp;lt;26 ::    *[a 1 b]         b&amp;gt;&amp;gt;

*[*[a b] c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we can write a revised line 33, perhaps slightly clearer:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;33r::    *[a 7 b c]       *[*[a b] c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;code&gt;8&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;8&lt;/code&gt; looks slightly horrible but you shouldn&amp;#39;t fear it at all:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;34 ::    *[a 8 b c]       *[a 7 [[7 [0 1] b] 0 1] c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What does this even mean?  Let&amp;#39;s go through the same process
of reducing it.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;*[a 7 [[7 [0 1] b] 0 1] c]

  &amp;lt;&amp;lt;33r::    *[a 7 b c]       *[*[a b] c]&amp;gt;&amp;gt;

*[*[a [7 [0 1] b] 0 1] c]

  &amp;lt;&amp;lt;23 ::    *[a [b c] d]     [*[a b c] *[a d]]&amp;gt;&amp;gt;

*[[*[a 7 [0 1] b] *[a 0 1]] c]

  &amp;lt;&amp;lt;33r::    *[a 7 b c]       *[*[a b] c]&amp;gt;&amp;gt;

*[[*[*[a 0 1] b] *[a 0 1]] c]

  &amp;lt;&amp;lt;25 ::    *[a 0 b]         /[b a]&amp;gt;&amp;gt;

*[[*[a b] a] c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So our revised rule 34:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;34r::    *[a 8 b c]       *[[*[a b] a] c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What does this actually do?  Well, look at it.  It evaluates the
formula &lt;code&gt;c&lt;/code&gt; with the cell of &lt;code&gt;*[a b]&lt;/code&gt; and the original subject
&lt;code&gt;a&lt;/code&gt;.  In other words, in math notation, if &lt;code&gt;d&lt;/code&gt; is &lt;code&gt;[8 b c]&lt;/code&gt;,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;d(a) == c([b(a) a])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But why?  Suppose, for the purposes of &lt;code&gt;c&lt;/code&gt;, we need not just &lt;code&gt;a&lt;/code&gt;,
but some intermediate noun computed from &lt;code&gt;a&lt;/code&gt; that will be useful
in &lt;code&gt;c&lt;/code&gt;&amp;#39;s calculation.  We apply &lt;code&gt;c&lt;/code&gt; with a new subject that&amp;#39;s a
cell of the intermediate value and the old subject - not at all
unlike pushing a new variable on the stack.&lt;/p&gt;

&lt;p&gt;For extra credit, a good question to ask yourself: why do we
need to write &lt;code&gt;[7 [0 1] b]&lt;/code&gt; and not just &lt;code&gt;b&lt;/code&gt;?&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;10&lt;/code&gt; (36)&lt;/h3&gt;

&lt;p&gt;We now understand all the moving parts we need to figure out the
other reduction of &lt;code&gt;10&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;36 ::    *[a 10 [b c] d]  *[a 8 c 7 [0 3] d]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Reducing:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;*[a 8 c 7 [0 3] d]

  &amp;lt;&amp;lt;34r::    *[a 8 b c]       *[[*[a b] a] c]&amp;gt;&amp;gt;

*[[*[a c] a] [7 [0 3] d]]

  &amp;lt;&amp;lt;33r::    *[a 7 b c]       *[*[a b] c]&amp;gt;&amp;gt;

*[*[[*[a c] a] 0 3] d]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you&amp;#39;ve assimilated a bit of Nock already, you may feel the
temptation to reduce this to&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;*[a d]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;since it would be very reasonable to think that&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;*[[*[a c] a] 0 3]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is just &lt;code&gt;a&lt;/code&gt;.  And it seems to be - given the semantics of 8 as
we&amp;#39;ve explained them.&lt;/p&gt;

&lt;p&gt;But there&amp;#39;s a problem, which is that &lt;code&gt;c&lt;/code&gt; might not terminate.
If &lt;code&gt;c&lt;/code&gt; terminates, this reduction is correct.  Otherwise it&amp;#39;s not. 
So the best we can do is:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;36r::    *[a 10 [b c] d]  *[*[[*[a c] a] 0 3] d]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Why?  &lt;code&gt;10&lt;/code&gt; in either case is a hint.  If &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;[10 x y]&lt;/code&gt; is an
atom, we reduce line 37 and &lt;code&gt;x&lt;/code&gt; is simply discarded.  Otherwise,
&lt;code&gt;x&lt;/code&gt; is a cell &lt;code&gt;[b c]&lt;/code&gt;; &lt;code&gt;b&lt;/code&gt; is discarded, but &lt;code&gt;c&lt;/code&gt; is computed as a
formula and its result is discarded.&lt;/p&gt;

&lt;p&gt;Effectively, this mechanism lets us feed both static and dynamic
information into the interpreter&amp;#39;s hint mechanism.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;6&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;6&lt;/code&gt; certainly looks intimidating:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;32 ::    *[a 6 b c d]     *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We could explain &lt;code&gt;6&lt;/code&gt; as a reduction sequence.  But it&amp;#39;s a long
one.  Instead, let&amp;#39;s invent another operator which makes &lt;code&gt;6&lt;/code&gt; easy:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   ::    $[0 b c]         b
   ::    $[1 b c]         c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then we can restate &lt;code&gt;6&lt;/code&gt; quite compactly:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;32r::    *[a 6 b c d]     *[a $[*[a b] c d]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;6&lt;/code&gt; stands revealed as the humble if-then-else.  Nock &lt;em&gt;is&lt;/em&gt; easy.&lt;/p&gt;

&lt;p&gt;This excuse for an explanation may not satisfy everyone.  A good
exercise is to check that &lt;code&gt;6&lt;/code&gt; as defined &lt;em&gt;actually&lt;/em&gt; has these
properties - and can&amp;#39;t be simplified.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;9&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;9&lt;/code&gt; is an audacious mystery:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;35 ::    *[a 9 b c]       *[a 7 c 2 [0 1] 0 b]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#39;ll reduce &lt;code&gt;9&lt;/code&gt; but not explain it.  When we use it in an
example, it&amp;#39;ll be obvious what it is.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;*[a 7 c 2 [0 1] 0 b]]

  &amp;lt;&amp;lt;33r::    *[a 7 b c]       *[*[a b] c]&amp;gt;&amp;gt;

*[*[a c] 2 [0 1] 0 b]]

  &amp;lt;&amp;lt;27 ::    *[a 2 b c]       *[*[a b] *[a c]]&amp;gt;&amp;gt;

*[*[*[a c] [0 1]] *[*[a c] 0 b]]

  &amp;lt;&amp;lt;25 ::    *[a 0 b]         /[b a]&amp;gt;&amp;gt;

*[*[a c] *[*[a c] 0 b]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we have:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;35r::    *[a 9 b c]       *[*[a c] *[*[a c] 0 b]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you have a really fine instinctive sense of Nock, you might
understand what &lt;code&gt;9&lt;/code&gt; is for.  Otherwise, don&amp;#39;t worry for now.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/doc/2013/11/18/ch2&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Intro To Nock&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch4&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Using Nock&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Chapter II (Intro To Nock)</title>
   <link href="http://urbit.org/doc/2013/11/18/ch2/"/>
   <updated>2013-11-18T00:00:00-08:00</updated>
   <id>http://urbit.org/doc/2013/11/18/ch2</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/setup&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Setup&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch3&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Nock Is Easy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;quot;What one fool can do, another can&amp;quot;&lt;/em&gt;
&lt;strong&gt;(Ancient Simian proverb)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Now that we&amp;#39;ve installed Arvo, let&amp;#39;s learn Nock.&lt;/p&gt;

&lt;p&gt;Think of Nock as a kind of functional assembly language.  It&amp;#39;s
not like assembly language in that it&amp;#39;s directly executed by the
hardware.  It is like assembly language in that (a) everything in
Urbit executes as Nock; (b) you wouldn&amp;#39;t want to program directly
in Nock; and (c) learning to program directly in Nock is a great
way to start understanding Urbit from the ground up.&lt;/p&gt;

&lt;p&gt;Just as Unix runs C programs by compiling them to assembler,
Urbit runs Hoon programs by compiling them to Nock.  You could
try to learn Hoon without learning Nock.  But just as C is a thin
wrapper over the physical CPU, Hoon is a thin wrapper over
the Nock virtual machine.  It&amp;#39;s a tall stack made of thin layers,
which is much easier to learn a layer at a time.&lt;/p&gt;

&lt;p&gt;And unlike most fundamental theories of computing, there&amp;#39;s really
nothing smart or interesting about Nock.  Of course, in a
strictly formal sense, all of computing is math.  But that
doesn&amp;#39;t mean it needs to feel like math.  Nock is a simple
mechanical device and it&amp;#39;s meant to feel that way.&lt;/p&gt;

&lt;h2&gt;Specification&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s start with the Nock spec.  It may look slightly
intimidating, but at least it isn&amp;#39;t long.&lt;/p&gt;

&lt;p&gt;No, you can&amp;#39;t just look at this and tell what it&amp;#39;s doing.
But at least there are only 39 lines of it.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;1  ::    A noun is an atom or a cell.
2  ::    An atom is a natural number.
3  ::    A cell is an ordered pair of nouns.
4  ::
5  ::    nock(a)          *a
6  ::    [a b c]          [a [b c]]
7  ::
8  ::    ?[a b]           0
9  ::    ?a               1
10 ::    +[a b]           +[a b]
11 ::    +a               1 + a
12 ::    =[a a]           0
13 ::    =[a b]           1
14 ::    =a               =a
15 ::
16 ::    /[1 a]           a
17 ::    /[2 a b]         a
18 ::    /[3 a b]         b
19 ::    /[(a + a) b]     /[2 /[a b]]
20 ::    /[(a + a + 1) b] /[3 /[a b]]
21 ::    /a               /a
22 ::
23 ::    *[a [b c] d]     [*[a b c] *[a d]]
24 ::
25 ::    *[a 0 b]         /[b a]
26 ::    *[a 1 b]         b
27 ::    *[a 2 b c]       *[*[a b] *[a c]]
28 ::    *[a 3 b]         ?*[a b]
29 ::    *[a 4 b]         +*[a b]
30 ::    *[a 5 b]         =*[a b]
31 ::
32 ::    *[a 6 b c d]     *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
33 ::    *[a 7 b c]       *[a 2 b 1 c]
34 ::    *[a 8 b c]       *[a 7 [[7 [0 1] b] 0 1] c]
35 ::    *[a 9 b c]       *[a 7 c 2 [0 1] 0 b]
36 ::    *[a 10 [b c] d]  *[a 8 c 7 [0 3] d]
37 ::    *[a 10 b c]      *[a c]
38 ::
39 ::    *a               *a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bear in mind: this is pseudocode.  It is neither Nock nor Hoon.
Strictly speaking, it&amp;#39;s really just English.  All formal systems
resolve to informal language at the very bottom.  What&amp;#39;s
important is just that no two reasonable people can read the spec
to mean two different things.&lt;/p&gt;

&lt;h2&gt;Sounds&lt;/h2&gt;

&lt;p&gt;In characteristic Urbit style, we got tired of three or
four-syllable pronunciations of ASCII punctuation characters and
assigned them all standard one-syllable names.  We&amp;#39;ll meet the
rest later, but the ones we use in Nock:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;`$`   buc
`/`   fas
`+`   lus
`(`   pel
`)`   per
`[`   sel
`]`   ser
`*`   tar
`=`   tis
`?`   wut
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Nouns&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s look at the data model first - lines 1-3 above.  Ideally,
you &lt;em&gt;can&lt;/em&gt; look at this and just tell what it&amp;#39;s doing.  But let&amp;#39;s
explain it a little anyway.&lt;/p&gt;

&lt;p&gt;An atom is a natural number - ie, an unsigned integer.  Nock does
not limit the size of atoms, or know what an atom means.&lt;/p&gt;

&lt;p&gt;For instance, the atom 97 might mean the number 97, or it might
mean the letter &amp;#39;a&amp;#39; (ASCII 97).  A very large atom might be the
number of grains of sand on the beach - or it might be a GIF of
your children playing on the beach.  Typically when we represent
strings or files as atoms, the first byte is the low byte.  But
even this is just a convention.  An atom is an atom.&lt;/p&gt;

&lt;p&gt;A cell is an ordered pair of any two nouns - cell or atom.  We
group cells with square brackets:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[1 1]
[34 45]
[[3 42] 12]
[[1 0] [0 [1 99]]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To keep our keyboards from wearing out, line 6 tells us that
brackets group to the right:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;6  ::    [a b c]           [a [b c]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So instead of writing&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[2 3]
[2 [6 7]]
[2 [6 [14 15]]]
[2 [6 [[28 29] [30 31]]]]
[2 [6 [[28 29] [30 [62 63]]]]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we can write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[2 3]
[2 6 7]
[2 6 14 15]
[2 6 [28 29] 30 31]
[2 6 [28 29] 30 62 63]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While this notational convenience is hardly rocket science, it&amp;#39;s
surprising how confusing it can be, especially if you have a Lisp
background.  Lisp&amp;#39;s &amp;quot;S-expressions&amp;quot; are very similar to nouns,
except that Lisp has multiple types of atom, and Lisp&amp;#39;s syntax
automatically adds list terminators to groups.  So in Lisp&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;#39;(2 6 7)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is a shorthand for&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;#39;(2 6 7 . nil)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the equivalent noun is&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[2 6 7 0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or, of course,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[2 [6 [7 0]]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Rules&lt;/h2&gt;

&lt;p&gt;A Nock program is given meaning by a process of reduction.  To compute
&lt;code&gt;Nock(x)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is any noun, we step through the rules from
the top down, find the first left-hand side that matches &lt;code&gt;x&lt;/code&gt;, and
reduce it to the right-hand side.&lt;/p&gt;

&lt;p&gt;Right away we see line 5:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;5  ::    Nock(a)           *a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When we use variable names, like &lt;code&gt;a&lt;/code&gt;, in the pseudocode spec, we
simply mean that the rule fits for any noun &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So &lt;code&gt;Nock(x)&lt;/code&gt; is &lt;code&gt;*x&lt;/code&gt;, for any noun &lt;code&gt;x&lt;/code&gt;.  And how do we reduce
&lt;code&gt;*x&lt;/code&gt;?  Looking up, we see that lines 23 through 39 reduce &lt;code&gt;*x&lt;/code&gt; -
for different patterns of &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, suppose our &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;[5 1 6]&lt;/code&gt;.  Stepping downward
through the rules, the first one that matches is line 26:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;26 ::    *[a 1 b]        b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Line 26 tells us that when reducing any noun of the form &lt;code&gt;[a 1
b]&lt;/code&gt;, the result is just &lt;code&gt;b&lt;/code&gt;.  So &lt;code&gt;*[5 1 6]&lt;/code&gt; is &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For a more complicated example, try&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;*[[19 42] [0 3] 0 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first rule it matches is line 23:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;23 ::    *[a [b c] d]     [*[a b c] *[a d]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;since &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;[19 42]&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt; is &lt;code&gt;[0 2]&lt;/code&gt;.
So this reduces to a new computation&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[*[[19 42] 0 3] *[[19 42] 0 2]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each side of this matches rule 25:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;25 ::    *[a 0 b]         /[b a]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we have&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[/[3 [19 42]] /[2 [19 42]]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When we explain &lt;code&gt;/&lt;/code&gt;, we&amp;#39;ll see that this is &lt;code&gt;[42 19]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, suppose our &lt;code&gt;x&lt;/code&gt; is just &lt;code&gt;42&lt;/code&gt;.  The first rule that
matches is the last:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;39 ::    *a               *a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;*42&lt;/code&gt; is &lt;code&gt;*42&lt;/code&gt;, which is &lt;code&gt;*42&lt;/code&gt;.  Logically, Nock goes into
an infinite reduction loop and never terminates.&lt;/p&gt;

&lt;p&gt;In practice, this is just a clever CS way to specify the simple
reality that &lt;code&gt;*42&lt;/code&gt; is an error and makes no sense.  An actual
interpreter will not spin forever - it will throw an exception
outside the computation.&lt;/p&gt;

&lt;h2&gt;Functions&lt;/h2&gt;

&lt;p&gt;We&amp;#39;ve already seen the &lt;code&gt;*&lt;/code&gt; function (pronounced &amp;quot;tar&amp;quot;), which
just means &lt;code&gt;Nock&lt;/code&gt;.  This is the main show and we&amp;#39;ll work through
it soon, but first let&amp;#39;s explain the functions it uses - &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;,
&lt;code&gt;+&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Equals: &lt;code&gt;=&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;=&lt;/code&gt; (pronounced &amp;quot;tis&amp;quot;, or sometimes &amp;quot;is&amp;quot;) tests a cell for
equality.  &lt;code&gt;0&lt;/code&gt; means yes, &lt;code&gt;1&lt;/code&gt; means no:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;12 ::    =[a a]           0
13 ::    =[a b]           1
14 ::    =a               =a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again, testing an atom for equality makes no sense and logically
fails to terminate.&lt;/p&gt;

&lt;h3&gt;Depth: &lt;code&gt;?&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;?&lt;/code&gt; (pronounced &amp;quot;wut&amp;quot;) tests whether is a noun is a cell.  Again,
&lt;code&gt;0&lt;/code&gt; means yes, &lt;code&gt;1&lt;/code&gt; means no:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;8  ::    ?[a b]           0
9  ::    ?a               1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(This convention is the opposite of old-fashioned booleans, so we
try hard to say &amp;quot;yes&amp;quot; and &amp;quot;no&amp;quot; instead of &amp;quot;true&amp;quot; and &amp;quot;false.&amp;quot;)&lt;/p&gt;

&lt;h3&gt;Increment: &lt;code&gt;+&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;+&lt;/code&gt; (pronounced &amp;quot;lus&amp;quot;, or sometimes &amp;quot;plus&amp;quot;) adds 1 to an atom:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;10 ::    +[a b]           +[a b]
11 ::    +a               1 + a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because &lt;code&gt;+&lt;/code&gt; works only for atoms, whereas &lt;code&gt;=&lt;/code&gt; works only for
cells, the error rule matches first for &lt;code&gt;+&lt;/code&gt; and last for &lt;code&gt;=&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Address: &lt;code&gt;/&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/&lt;/code&gt; (pronounced &amp;quot;fas&amp;quot;) is a tree address function:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;16 ::    /[1 a]           a
17 ::    /[2 a b]         a
18 ::    /[3 a b]         b
19 ::    /[(a + a) b]     /[2 /[a b]]
20 ::    /[(a + a + 1) b] /[3 /[a b]]
21 ::    /a               /a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This looks way more complicated than it is.  Essentially, we define a
noun as a binary tree - where each node branches to a left and right
child - and assign an address, or &lt;em&gt;axis&lt;/em&gt;, to every element in the
tree.  The root of the tree is &lt;code&gt;/1&lt;/code&gt;.  The left child of
every node at &lt;code&gt;/a&lt;/code&gt; is &lt;code&gt;/2a&lt;/code&gt;; the right child is &lt;code&gt;/2a+1&lt;/code&gt;.  (Writing &lt;code&gt;(a
+ a)&lt;/code&gt; is just a clever way to write &lt;code&gt;2*a&lt;/code&gt;, while minimizing the set of
pseudocode forms.)&lt;/p&gt;

&lt;p&gt;For a complete tree of depth 3, the axis address space looks
like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;         1
    2          3
 4    5     6     7
8 9 10 11 12 13 14 15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s use the example &lt;code&gt;[[97 2] [1 42 0]]&lt;/code&gt;.  So&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;/[1 [97 2] [1 42 0]]      [[97 2] [1 42 0]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;because &lt;code&gt;/1&lt;/code&gt; is the root of the tree, ie, the whole noun.  Then
its left child is &lt;code&gt;/2&lt;/code&gt; (ie, &lt;code&gt;(1 + 1)&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;/[2 [97 2] [1 42 0]]      [97 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And its right child is &lt;code&gt;/3&lt;/code&gt; (ie, &lt;code&gt;(1 + 1 + 1)&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;/[3 [97 2] [1 42 0]]      [1 42 0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And delving into &lt;code&gt;/3&lt;/code&gt;, we see &lt;code&gt;/(3 + 3)&lt;/code&gt; and &lt;code&gt;(3 + 3 + 1)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;/[6 [97 2] [1 42 0]]      1
/[7 [97 2] [1 42 0]]      [42 0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If this seems like rocket science, the problem may be that you&amp;#39;re
too smart to understand Nock.  Forget everything you learned in
school and start over from line 1.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s also fun to build nouns in which every atom is its own axis:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;1
[2 3]
[2 6 7]
[[4 5] 6 7]
[[4 5] 6 14 15]
[[4 5] [12 13] 14 15]
[[4 [10 11]] [12 13] 14 15]
[[[8 9] [10 11]] [12 13] 14 30 31]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once you&amp;#39;ve spent enough time programming in Urbit, you&amp;#39;ll know
these axes in your dreams.  No - really. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/setup&quot;&gt;&lt;strong&gt;Prev&lt;/strong&gt;: Setup&lt;/a&gt;
&lt;a href=&quot;/doc/2013/11/18/ch3&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;: Nock Is Easy&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Hi Zod! or basic Urbit tunneling</title>
   <link href="http://urbit.org/blog/2013/10/08/hizod/"/>
   <updated>2013-10-08T00:00:00-07:00</updated>
   <id>http://urbit.org/blog/2013/10/08/hizod</id>
   <content type="html">&lt;p&gt;One bug, or really minor misfeature, in Urbit&amp;#39;s networking - not the evil :update bug, possibly aka &amp;quot;ok/not responding,&amp;quot; which remains my main quarry today, but one I had to investigate on the way to it - is that it&amp;#39;s all very well and good to punch a NAT hole, but a lot of routers - for I guess understandable reasons - like to heal the hole up relatively quickly.  As in, a minute or two.&lt;/p&gt;

&lt;p&gt;Naturally this means you&amp;#39;re (a) totally disconnected from the Internets and Urbit too, (b) when you return, it will be with a different 48-bit address, and (c) returning means you need to re-establish your hierarchical route.&lt;/p&gt;

&lt;p&gt;There are two ways a ship talks to another ship.  Actually, there are three.  In A, my ship knows your ship&amp;#39;s 48-bit UDP address (ie, IPv4+port).  (Like everywhere on the internets, IPv6 is perfectly supported in theory.)  In B, my ship &lt;em&gt;thinks it might&lt;/em&gt; know your ship&amp;#39;s address.  In C, it knows it doesn&amp;#39;t.&lt;/p&gt;

&lt;p&gt;In C, it forwards through the hierarchy, which for now at present every destroyer is ~doznec through ~zod.  In A, it sends a direct packet.  In B - the state I enter when I&amp;#39;ve received a &lt;em&gt;forwarded&lt;/em&gt; packet from you, not knowing whether I can send back through the hole - because it is not a tunnel from you to me, but from you to the first ship, probably ~doznec, on the hierarchical path from you to me - it sends &lt;em&gt;both&lt;/em&gt;.  &lt;/p&gt;

&lt;p&gt;As long as one party in the conversation can have its tunnels forwarded (&amp;quot;full cone NAT&amp;quot;), we can converge on a direct conversation with both ships in state C (&amp;quot;STUN&amp;quot;).  Otherwise, we end up with the dramatically inferior perma-forwarded TURN.  Earlier in the summer it was the major cause of Urbit flakage, but NAT traversal seems to work okay now.&lt;/p&gt;

&lt;p&gt;With one exception.  If I forward to ~doznec, how does the packet then get to you?  ~doznec needs a valid 48-bit UDP address for you, which was the address you used to talk to it.  (The #1 newbie Unix network programming question: what system call do I use to get my own IP address()?  There are a lot of ways to do it, all bad.  The answer is that you shouldn&amp;#39;t depend on your own IP address - and to the world, your address is where they see your packets coming from.)&lt;/p&gt;

&lt;p&gt;Some of us are old and some of us who are old worked with old people when we were young.  I remember in the early &amp;#39;90s, when I was working on interactive TV, this incredibly ancient person was in the office for some reason - probably looking for the Medicare clinic - and he explained that he&amp;#39;d worked on Telex.  Not everyone in the room knew what Telex was, so he explained it.  &amp;quot;Telex,&amp;quot; he said, &amp;quot;was the information superhighway when it was paved with gravel.&amp;quot;  &lt;/p&gt;

&lt;p&gt;Well, there&amp;#39;s certainly &lt;em&gt;some&lt;/em&gt; asphalt on the Internets, but... in a network paved with gravel, there is no way to keep your hole up but continuous active pinging.  As a result, on a bad network your connectivity can only be restored by a trivial communication up the hierarchy - ie, :hi ~zod.  The reason this isn&amp;#39;t done automatically is just that functionality of this type is currently in the process of migrating out of the kernel into userspace.  So, while Urbit remains in the NICU... doing it manually never ever hurts.&lt;/p&gt;

&lt;p&gt;Also, I welcome peoples&amp;#39; opinions on the right &lt;em&gt;period&lt;/em&gt; for this keepalive.   Is 2 min short enough?  Ya think?  I am anything but an expert here...&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Urbit, from the NICU to ops Week</title>
   <link href="http://urbit.org/blog/2013/10/06/nicu/"/>
   <updated>2013-10-06T00:00:00-07:00</updated>
   <id>http://urbit.org/blog/2013/10/06/nicu</id>
   <content type="html">&lt;p&gt;(TLDR: to keep using Urbit, delete all your pre-10/6 data, git
pull the source again, make clean, make, and start over.  Your
destroyers and tickets will keep working.  No, this will not keep
happening, though it may happen once or twice again.)&lt;/p&gt;

&lt;p&gt;Urbit has been in the wild for almost two weeks now.  Which is
crazy.  Also, 11.000 people have (according to Vimeo) watched our
10-minute screencast of a command-line session.  Apparently in a
world of suck, there is a lot of pent-up demand for !suck.&lt;/p&gt;

&lt;p&gt;What sucks is that we can&amp;#39;t really satisfy this demand right now.
Because Urbit still sucks.  It was born prematurely and is doing
all it can to keep breathing. &lt;/p&gt;

&lt;p&gt;At least we&amp;#39;ve finished the major revision control update that
was in the works.  Now if your friend &lt;code&gt;~tomsyt-balsen&lt;/code&gt; else has a
desk (ie, branch) &lt;code&gt;funky&lt;/code&gt; you want to use, you can&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~tasfyn-partyv/try=&amp;gt; :clone /~tomsyt-balsen/funky
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and &lt;code&gt;funky&lt;/code&gt; will be on &lt;code&gt;~tasfyn-partyv&lt;/code&gt; promptly.  To update,
just use the same command again.  It can even merge a bit.  Also, &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~tasfyn-partyv/try=&amp;gt; :update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will update the core files you got when your ship was born.  And
finally, if the Arvo sources change, you can reload everything
very simply with &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~tasfyn-partyv/try=&amp;gt; :reset
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will replace all the Arvo code, including Hoon in Hoon
itself, and keep your data intact - even running processes.  We
told you there was a use for Nock.  For a simpler change in a
single vane (kernel module), eg &lt;code&gt;%clay&lt;/code&gt; (revision control), just&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~tasfyn-partyv/try=&amp;gt; :reload %clay
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bear in mind that for updates in the standard library (&lt;code&gt;%zuse&lt;/code&gt;)
to propagate to the shell (&lt;code&gt;%batz&lt;/code&gt;), you need to reload first
&lt;code&gt;%zuse&lt;/code&gt;, then &lt;code&gt;%batz&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But - isn&amp;#39;t all this rather premature?  Yes, it is!  The point of
this update was not that anyone needs real revision control in
Urbit yet, except of course for Urbit itself.  The point is that
we need to stabilize our data structures, because Urbit needs to
get to continuity.&lt;/p&gt;

&lt;p&gt;What is continuity, exactly?  It&amp;#39;s a problem that emerges in a
network of single-level stores.  No one has built such a network
before, to my knowledge, so we&amp;#39;re making it up as we go along.&lt;/p&gt;

&lt;p&gt;In a normal 20th-century OS, there is a hierarchy of ephemeral
and persistent data that corresponds to the memory hierarchy on a
normal computer.  People sometimes talk about DRAM replacements
that are naturally persistent, but even if DRAM was persistent,
a computer running Unix would still need to be rebooted.  In
Unix, a TCP socket is ephemeral relative to a process, and a
process is ephemeral relative to the filesystem.&lt;/p&gt;

&lt;p&gt;In Arvo there is no ephemeral state anywhere.  All state is
consistent and indefinitely preserved.  This works great when it
works perfectly, but it also removes a source of resilience.
Essentially the Urbit approach is to operate with high precision
and low tolerance, like an American aerospace design.  The Unix
approach has a more... Soviet... quality.  Truly excellent in its
own way - don&amp;#39;t get me wrong.&lt;/p&gt;

&lt;p&gt;So, for example, every network connection needs to maintain
message sequence numbers on both sides.  On Unix, these are bound
to your TCP socket, which is doubly ephemeral.  In Urbit, they
are bound to your public key (certificate iteration).  If your
ship loses continuity, it needs to generate a new key.  This
should not happen often - in a healthy ecosystem, never.  We know
how to compute reliably in the cloud - when was the last time,
say, a Google app lost your data?&lt;/p&gt;

&lt;p&gt;Moreover, unlike in Unix, all our data is structured and typed.
When we change the type of state, whether at the kernel or user
level, we have to write a type adaptor.  We can.  So the only
excuse for ephemerality is that the underlying computer can fail,
which is what redundancy is for.&lt;/p&gt;

&lt;p&gt;But, with an immature system, it&amp;#39;s often a lot easier just to
throw away your whole state and reboot the universe.  So... we&amp;#39;ve
been doing that.&lt;/p&gt;

&lt;p&gt;Which we hope to change this week.  If you&amp;#39;re using Urbit this
week, it&amp;#39;s Ops Week.  We&amp;#39;ll be trying to keep the server up and
usable for the most trivial task of a social network, chat.  &lt;/p&gt;

&lt;p&gt;But, since Urbit is still in the NICU, join us on IRC at #urbit
on freenode.  Starting Monday morning, it&amp;#39;ll be a big nonstop
party with occasional disasters.&lt;/p&gt;

&lt;p&gt;And finally... anyone operating the submarines prefixed&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;~fotdug-milred
~ritheb-latlen
~hidnyr-rivrun
~binnep-lagser
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;you&amp;#39;re sending us packets in the old protocol.  Please follow
these instructions at the top, so we can delete you from our
crude manual packet blacklist!  Because when we break the world,
we really break it...&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Tea at the palaz of Hoon</title>
   <link href="http://urbit.org/blog/2013/09/26/palaz/"/>
   <updated>2013-09-26T15:00:00-07:00</updated>
   <id>http://urbit.org/blog/2013/09/26/palaz</id>
   <content type="html">&lt;div id=&quot;post&quot;&gt;
  &lt;blockquote&gt;
&lt;p&gt;Not less because in purple I descended&lt;br /&gt;The western day through what you called&lt;br /&gt;The loneliest air, not less was I myself.&lt;/p&gt;

&lt;p&gt;What was the ointment sprinkled on my beard?&lt;br /&gt;What were the hymns that buzzed beside my ears?&lt;br /&gt;What was the sea whose tide swept through me there?&lt;/p&gt;

&lt;p&gt;Out of my mind the golden ointment rained,&lt;br /&gt;And my ears made the blowing hymns they heard.&lt;br /&gt;I was myself the compass of that sea:&lt;/p&gt;

&lt;p&gt;I was the world in which I walked, and what I saw&lt;br /&gt;Or heard or felt came not but from myself;&lt;br /&gt;And there I found myself more truly and more strange.&lt;/p&gt;

&lt;p&gt;-Wallace Stevens&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A hymn can be full of love, or hate. And the quality of Urbit&amp;#8217;s haters is absurdly high. We cherish each and every one of them. There&amp;#8217;s something sublime about being hit with a perfectly-formed jab. So we&amp;#8217;d like to serve some of the choicest examples for you here, names redacted (we don&amp;#8217;t want to embarrass anyone). Here they are:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://web.archive.org/web/20130925195007/http://www.mcclatchydc.com/2013/09/24/203134/exclusive-john-mcafee-vows-to.html&quot;&gt;&lt;img alt=&#39;It&#39;s an image. It&#39;s a link&#39; src=&#39;/assets/tweets.png&#39; /&gt;&lt;/a&gt; Sadly, though we&amp;#8217;re avid followers of the &lt;a href=&quot;http://www.mercurynews.com/business/ci_24168403/exclusive-john-mcafee-vows-make-internet-impossible-hack&quot;&gt;adventures&lt;/a&gt; of John McAfee, he&amp;#8217;s not involved.&lt;/p&gt;

&lt;p&gt;Yet.&lt;/p&gt;

&lt;p&gt;But &lt;a href=&#39;http://forums.somethingawful.com/showthread.php?threadid=3571697&amp;amp;userid=0&amp;amp;perpage=40&amp;amp;pagenumber=2#post419831292&#39;&gt;outside&lt;/a&gt; the Twitterverse is where&lt;a href=&#39;http://forums.somethingawful.com/showthread.php?threadid=3571697&amp;amp;userid=0&amp;amp;perpage=40&amp;amp;pagenumber=2#post419831292&#39;&gt; things &lt;/a&gt; really start to&lt;a href=&#39;http://forums.somethingawful.com/showthread.php?threadid=3571697&amp;amp;userid=0&amp;amp;perpage=40&amp;amp;pagenumber=1#post419822422&#39;&gt; shine.&lt;/a&gt; &lt;em&gt;This&lt;/em&gt; is how you gripe:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;this one looks like x86 assembly had a fetal alcohol syndrome love child with haskell&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;so are there actually several people involved in this, and if so, what language do they speak amongst themselves?&lt;/p&gt;

&lt;p&gt;or do they just gently sway in unison, softly keening&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;++  grip			 ::  extend will  
  |=  [wet=will law=will]  
  ^-  will  
  ?~  wet  law  
  ?:  =(wet law)  law  
  ?^  t.wet  
    ?&amp;gt;((meld i.wet i.t.wet) [i.wet $(wet t.wet)])  
  ?~  law  
    ?&amp;gt;((pier i.wet) [i.wet ~])  
  ?~  q.p.q.i.wet  
    ?&amp;gt;((meld i.wet i.law) [i.wet law])  S&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;#8217;s like the obfuscated c code contestants and the losethos guy got together and created a monster&lt;/p&gt;

&lt;p&gt;wait why do I feel moist&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And our &lt;a href=&#39;http://irclog.perlgeek.de/perl6/2013-09-25&#39;&gt;favorite:&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;08:14 * moritz: congratulates the makers on the most elaborate joke he has seen in quite some time&lt;/p&gt;

&lt;p&gt;08:15 * timotimo: imagines being the creator of urbit and seeing it show up on a publically logged irc channel of a similarly insane language design community via a google alert&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Because that&amp;#8217;s literally what happened&amp;#8230;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#39;Aint even mad&#39; src=&#39;/assets/notevenmad.jpg&#39; /&gt;&lt;/p&gt;

&lt;p&gt;[Note: there&amp;#8217;s also a lot of great substantive criticism out there, especially on the &lt;a href=&#39;https://news.ycombinator.com/item?id=6438320&#39;&gt;Hacker News Thread&lt;/a&gt;. We love all that too.]&lt;/p&gt;

&lt;p&gt;We also want to acknowledge some of the love we&amp;#8217;ve received over the past few days:&lt;/p&gt;
&lt;blockquote class=&#39;twitter-tweet&#39;&gt;&lt;p&gt;PLT/OS geeks, this is weird and fascinating. Plan 9 meets Factor meets Haskell, (t)rolled into one: &lt;a href=&#39;http://t.co/22e4xIBWIN&#39;&gt;http://t.co/22e4xIBWIN&lt;/a&gt; (via &lt;a href=&#39;https://twitter.com/goodmanio&#39;&gt;@goodmanio&lt;/a&gt;)&lt;/p&gt;&amp;mdash; Alex Payne (@al3x) &lt;a href=&#39;https://twitter.com/al3x/statuses/382954933974097920&#39;&gt;September 25, 2013&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;blockquote class=&#39;twitter-tweet&#39;&gt;&lt;p&gt;&lt;a href=&#39;https://twitter.com/fet&#39;&gt;@fet&lt;/a&gt; Yeah. It&amp;#39;s first thing to give me the same feeling I had as a teenager, stumbling around the early internet trying to learn computing…&lt;/p&gt;&amp;mdash; Izzy (@frozendevil) &lt;a href=&#39;https://twitter.com/frozendevil/statuses/382942599847215104&#39;&gt;September 25, 2013&lt;/a&gt;&lt;/blockquote&gt;&lt;blockquote class=&quot;twitter-tweet&quot;&gt;&lt;p&gt;of course, my first thought *after* &amp;quot;is this a joke?&amp;quot; was &amp;quot;hmm, this would be fun to implement in Python&amp;quot;&lt;/p&gt;&amp;mdash; James Tauber (@jtauber) &lt;a href=&quot;https://twitter.com/jtauber/statuses/383052324429893632&quot;&gt;September 26, 2013&lt;/a&gt;&lt;/blockquote&gt;&lt;blockquote class=&#39;twitter-tweet&#39;&gt;&lt;p&gt;It&amp;#39;s late. I should have been in bed hours ago. Instead I made my first commit to urbit and quoted Borges in my email to get my destroyers.&lt;/p&gt;&amp;mdash; J Kenneth King (@agentultra) &lt;a href=&#39;https://twitter.com/agentultra/statuses/382718105111109633&#39;&gt;September 25, 2013&lt;/a&gt;&lt;/blockquote&gt;&lt;blockquote class=&#39;twitter-tweet&#39;&gt;&lt;p&gt;Urbit seems deeply cool, deeply weird, but destined to be a new Usenet for libertarian cipherpunks and bitcoin fans.&lt;/p&gt;&amp;mdash; David Flanagan (@__DavidFlanagan) &lt;a href=&#39;https://twitter.com/__DavidFlanagan/statuses/383126596246196224&#39;&gt;September 26, 2013&lt;/a&gt;&lt;/blockquote&gt;&lt;blockquote class=&#39;twitter-tweet&#39;&gt;&lt;p&gt;Oh my God. &lt;a href=&#39;http://t.co/ImZkS1d71U&#39;&gt;http://t.co/ImZkS1d71U&lt;/a&gt; .  It&amp;#39;s like being a kid again!  Hackers still exist! Someone else wants to rebuild *everything*!&lt;/p&gt;&amp;mdash; Mike Biggs (@nfomon) &lt;a href=&#39;https://twitter.com/nfomon/statuses/382690623352225793&#39;&gt;September 25, 2013&lt;/a&gt;&lt;/blockquote&gt;&lt;blockquote class=&#39;twitter-tweet&#39;&gt;&lt;p&gt;*drops everything, goes to live in Urbit monastery*&lt;/p&gt;&amp;mdash; Swizzlr (@swizzlr) &lt;a href=&#39;https://twitter.com/swizzlr/statuses/382986416730681344&#39;&gt;September 25, 2013&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;But our favorite piece of love was this comment on &lt;a href=&#39;https://news.ycombinator.com/item?id=6439913&#39;&gt;Hacker News&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Watching the &lt;a href=&quot;http://vimeo.com/75312418&quot;&gt;video&lt;/a&gt; blew my brains out the back of my head. Figuratively of course. Thanks for not letting me get anything productive done for the rest of the day.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>Continuity timeframe</title>
   <link href="http://urbit.org/blog/2013/09/25/continuity/"/>
   <updated>2013-09-25T15:00:00-07:00</updated>
   <id>http://urbit.org/blog/2013/09/25/continuity</id>
   <content type="html">&lt;p&gt;Thought we&amp;#39;d share the following email that we sent out on the developers
mailing list (urbit-dev@googlegroups.org):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Welcome to Urbit! You&amp;#39;ve been added to this mailing list because you all are
now proud owners of one or more destroyers (let us know if you&amp;#39;re not and
we&amp;#39;ll remedy that). We&amp;#39;ll be using this list to update all of you with the
latest news from the offworld colonies. Presently your subscription settings
are at one digest email daily (we have a powerful hatred of listserv-spam).
Feel free to change these settings on Google Groups to whatever you like.&lt;/p&gt;

&lt;p&gt;Our target date for network continuity is Friday October 4th. At which point
the data structures we create will (if we succeed) live forever. We&amp;#39;ll almost
certainly do at least one reboot sometime before then, so you&amp;#39;ll have to
recreate your destroyers from your keys when we do.&lt;/p&gt;

&lt;p&gt;Also, we plan on putting up some actual Hoon doc by then, so you all can, you
know, actually learn Hoon.&lt;/p&gt;

&lt;p&gt;I&amp;#39;ll leave you with some Borges: &amp;quot;Stranger and more pure than any hron is, at
times, the ur: the object produced through suggestion, educed by hope.&amp;quot; &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since this blog post is not limited to 1000 words (seriously Google) and
because I love that quote so damn much, I&amp;#39;ll post the whole thing:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;quot;In the most ancient regions of Tlön, the duplication of lost objects is not
infrequent. Two persons look for a pencil; the first finds it and says nothing;
the second finds a second pencil, no less real, but closer to his expectations.
These secondary objects are called hronir and are, though awkward in form,
somewhat longer. Until recently, the hronir were the accidental products of
distraction and forgetfulness. It seems unbelievable that their methodical
production dates back scarcely a hundred years, but this is what the Eleventh
Volume tells us.&lt;/p&gt;

&lt;p&gt;[...]&lt;/p&gt;

&lt;p&gt;The methodical fabrication of hronir (says the Eleventh Volume) has performed
prodigious services for archaeologists.  It has made possible the interrogation
and even the modification of the past, which is now no less plastic and docile
than the future. Curiously, the hronir of second and third degree - the hronir
derived from another hron, those derived from the hron of a hron - exaggerate
the aberrations of the initial one; those of fifth degree are almost uniform;
those of ninth degree become confused with those of the second; in those of the
eleventh there is a purity of line not found in the original. The process is
cyclical: the hron of the twelfth degree begins to fall off in quality.
Stranger and more pure than any hron is, at times, the ur: the object produced
through suggestion, educed by hope.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>Welcome to Urbit</title>
   <link href="http://urbit.org/blog/2013/09/24/urbit-intro/"/>
   <updated>2013-09-24T15:00:00-07:00</updated>
   <id>http://urbit.org/blog/2013/09/24/urbit-intro</id>
   <content type="html">&lt;p&gt;But wait - what the hell is Urbit?&lt;/p&gt;

&lt;p&gt;One of Urbit&amp;#39;s problems is that we don&amp;#39;t exactly have a word for
what Urbit is.  If there is such a word, it somehow means both
&amp;quot;operating system&amp;quot; and &amp;quot;network protocol,&amp;quot; while somehow also
implying &amp;quot;functional&amp;quot; and &amp;quot;deterministic.&amp;quot;  &lt;/p&gt;

&lt;p&gt;Not only is there no such word, it&amp;#39;s not even clear there
&lt;em&gt;should&lt;/em&gt; be one.  And if there was, could we even hear it?
As Wittgenstein said: if a lion could talk, we would not
understand him.  But heck, let&amp;#39;s try anyway.&lt;/p&gt;

&lt;p&gt;As a network protocol, we could call Urbit a &amp;quot;seven-layer
protocol&amp;quot; - that is, a protocol that specifies the complete
semantics of the general-purpose computer that processes it.  As
any decent IETF ninja will tell you, this is a very bad idea for
all sorts of extremely obvious reasons.&lt;/p&gt;

&lt;p&gt;And from the OS perspective, Urbit is yet another slice of
userspace crap with the temerity to call itself an &amp;quot;operating
system.&amp;quot; Urbit is not actually an OS in the bare-metal sense.
It&amp;#39;s a VM that runs on Linux or OS X.  Someday it might be so
daring as to descend to Xen.  Urbit has no interest at all in
drivers, peripherals, etc.  It is just a UDP transceiver in the
cloud.  Worst of all - Urbit is not even preemptive.  A poser!
(Actually all the real work, as in node, is done by libuv.)&lt;/p&gt;

&lt;p&gt;Moreover, this VM is formally isolated from your actual OS.  And
everything that uses it.  Nothing in Urbit can request system
services or call existing libraries.  So Urbit is not only badly
designed and fraudulently hyped.  It&amp;#39;s also profoundly useless.&lt;/p&gt;

&lt;p&gt;Well... your browser has been reasonably successful with this
restriction.  But your browser was never designed to be any kind
of OS.  To the extent that it&amp;#39;s sort of become an OS, it is
specialized for the very undemanding job of being a client.  A
general-purpose client, which is neat.  But not a general-purpose
server - which is a much harder problem.&lt;/p&gt;

&lt;p&gt;A general-purpose server is a slab of code that feels totally
confident when faced with the problem of storing &lt;em&gt;all your
personal and/or corporate data&lt;/em&gt;, across &lt;em&gt;arbitrary functional
upgrades&lt;/em&gt;, for &lt;em&gt;all time forever&lt;/em&gt;, while efficiently executing
and managing &lt;em&gt;any useful program or programs, transient or
persistent&lt;/em&gt;.  Yeah, that&amp;#39;s a server OS.&lt;/p&gt;

&lt;p&gt;So, conventionally, this industrial strength slab of code is
written with conventional OS techniques involving (a) bare metal
and (b) like, semaphores and shit.  The kernel alone is like 12
million lines of code.  Not that a browser is any much smaller.&lt;/p&gt;

&lt;p&gt;And so, 20th-century network computing is the world&amp;#39;s most
beautiful wire, between two dumpsters of shit spaghetti.  Two
&lt;em&gt;completely different&lt;/em&gt; dumpsters.  It turns out that with a big
enough dumpster of shit spaghetti, you can feed the world.  And
why not two?  Incompatibility creates jobs, you know.&lt;/p&gt;

&lt;p&gt;Oh, and you can have a client without an identity.  But you can&amp;#39;t
have a &lt;em&gt;server&lt;/em&gt; without an identity.  So Urbit has to solve &lt;em&gt;that&lt;/em&gt;
problem.  Unless it&amp;#39;s just going to be a Web server.  (Urbit is
actually a perfectly decent Web server.)  Unless it has an actual
identity model, your general-purpose server - presumably a
&lt;em&gt;network&lt;/em&gt; server - has no network effect.  No identity, no
network.  No network, who the hell cares?&lt;/p&gt;

&lt;p&gt;And unlike your ordinary, common or garden Web application
server, Urbit does need that network effect.  You see, it&amp;#39;s not
even our own work.  It&amp;#39;s something we found.  On an unmarked USB
stick by the side of the road three kilometers from Area 51.  &lt;/p&gt;

&lt;p&gt;We think it&amp;#39;s probably still human engineering.  First of all,
there are no aliens.  Second, Urbit uses Unicode.  Do the aliens
have Unicode?  Or SHA-256?  &lt;em&gt;Where did Unicode come from,
anyway?&lt;/em&gt;  And at the I/O level, we see UDP, HTTP, etc.  The
command line does Emacs keys.  At the very least, someone on
Earth (or at least &lt;em&gt;from&lt;/em&gt; Earth) has done some porting.&lt;/p&gt;

&lt;p&gt;But other than these cosmetic details, there&amp;#39;s not much sign of a
connection to ordinary Earth computing.  For instance, Urbit
isn&amp;#39;t written in any of our Earth languages.  It is written in
something called Hoon, which is a strict, higher-order, typed
functional language - but has nothing in else in common with 
other Earth languages, functional or not.  Hoon does not even 
use standard PL theory.  And its syntax is just as alien, although 
at least it confines itself to the ASCII plane.  (And you
probably thought the &amp;quot;A&amp;quot; in &amp;quot;ASCII&amp;quot; stood for &amp;quot;American.&amp;quot;)&lt;/p&gt;

&lt;p&gt;Worse yet, Hoon is not written in anything normal.  It&amp;#39;s written
in Hoon.  To be precise - the Hoon compiler compiles itself to a
much simpler automaton, Nock.  Besides machine language itself,
and its various bytecode homages, there are three simple formal
models of computing - Turing machines, lambda calculus, and Chuck
Moore.  There is also a fourth which no one has ever found useful
for anything: combinators.  Nock is a combinator automaton.&lt;/p&gt;

&lt;p&gt;While nowhere near the simplest such automaton known, and
certainly not of any &lt;em&gt;theoretical&lt;/em&gt; interest, Nock is so stupid
that if you gzip the spec, it&amp;#39;s only 374 bytes.  Nock&amp;#39;s only
arithmetic operation is increment.  So decrement is an &lt;code&gt;O(n)&lt;/code&gt;,
operation; add is &lt;code&gt;O(m*n)&lt;/code&gt;... &lt;/p&gt;

&lt;p&gt;Clearly not a practical system.  Even if this... &lt;em&gt;thing&lt;/em&gt;... that
sits on top of it was in any way, shape or form remotely sane.&lt;/p&gt;

&lt;p&gt;So why not try it?  Heck, why not at least check it out?  Strange
and foolish dreamers may hie themselves to teh github:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/urbit&quot;&gt;https://github.com/urbit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Various people have built and run Urbit on Ubuntu, Homebrew and
MacPorts.  It&amp;#39;s possible that all these people were stone cold
ninjas.  Urbit is a pretty cool toy, I think, if you&amp;#39;re a ninja.
Unfortunately it is not really ready for ordinary rice farmers.
If you can&amp;#39;t resolve build dependencies by hand, we&amp;#39;re sorry.
Urbit is probably not yet ready for you.&lt;/p&gt;

&lt;p&gt;Where should you run Urbit?  Ideally, in the cloud.  Urbit can
punch a decent NAT hole.  It doesn&amp;#39;t like to, though - what does?
Bear in mind that your Urbit instance is a single-level store -
your state is saved as a log and a checkpoint (as in Redis -
except that Redis is both fast and reliable).  This will work
much better on server hardware.  That said, there are plenty of
good reasons to keep your servers in the closet with the plants.&lt;/p&gt;

&lt;p&gt;Next, you need a ticket.  Or not.  You at least need to decide
whether you want a ticket or not.  Actually, the answer is
simple.  You do want one.  But you don&amp;#39;t need one - not yet.&lt;/p&gt;

&lt;p&gt;Because Urbit, the OS, never depends on Earth semantics, it needs
its own network protocol - Ames.  Ames is a P2P protocol with its
own public-key infrastructure.  (Ames is encrypted, but the
current cryptosuite, suite A, is worthless snakeoil.  Don&amp;#39;t trust
it with your Trader Joe receipts.)  Ames runs over UDP, and pays
as little attention to IP routing as possible.  Needless to say,
Urbit does not use the DNS at all.&lt;/p&gt;

&lt;p&gt;To sling packets on Ames, you need an identity.  Needless to say,
there are a lot of ways to do distributed cryptographic identity,
all of them bad.&lt;/p&gt;

&lt;p&gt;The general reason all PKIs suck is called &amp;quot;Zooko&amp;#39;s Triangle.&amp;quot;
Your identities can be distributed, secure, or human-meaningful -
pick any two.  There is no way to solve Zooko&amp;#39;s Triangle.  The
only way to attack it is to compromise on at least one vertex.&lt;/p&gt;

&lt;p&gt;To see how Urbit works, let&amp;#39;s start with a standard solution.  An
Urbit identity is called a &amp;quot;ship.&amp;quot;  You can launch your own ship
by generating a 2048-bit RSA key and hashing it to a 128-bit
fingerprint, which is your identity.  This trivial design is the
basis of all distributed, secure PKIs.&lt;/p&gt;

&lt;p&gt;Unfortunately, an identity should be above all a &lt;em&gt;name&lt;/em&gt;.  A
128-bit fingerprint looks like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    316.931.986.049.624.498.975.974.005.376.666.572.699
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which isn&amp;#39;t a name.  For no better reason than the fact that,
unless you&amp;#39;re an autistic savant, you are basically a monkey with
an overgrown monkey brain.  A name is something that fits in a 
register.  Your monkey brain doesn&amp;#39;t have 128-bit registers.&lt;/p&gt;

&lt;p&gt;Suppose we could use 64-bit fingerprints?  At first this seems
even less promising.  First of all, your monkey brain doesn&amp;#39;t
have 64-bit registers, either.  Second, at 64 bits, collisions
are already a real problem.&lt;/p&gt;

&lt;p&gt;But we can solve both these problems.  Your monkey brain doesn&amp;#39;t
have 64-bit registers.  But anything that lets us do 64-bit
identities might stretch down to 32 bits.  And at 64 or 32 bits,
we can&amp;#39;t assign identities by random hash.  So we&amp;#39;ll have to find
another way of distributing them.&lt;/p&gt;

&lt;p&gt;A 32-bit identity - or even a 16-bit identity - will still never
be human-meaningful.  Perhaps we can make it human-memorable.
Meaningful addresses are a nice feature in a social network, but
memorable addresses are essential.  And if we have memorable
addresses, perhaps we can build meaningful names on top.&lt;/p&gt;

&lt;p&gt;The classic example of a memorable address is a street address.
Your street address identifies you precisely, using a name.  You
have this great brain hardware for remembering names.  But what
does the name of your street &lt;em&gt;mean&lt;/em&gt;?  Nothing at all, usually.
And even if it does mean something, by accident or design, that
meaning has nothing at all to do with you.  (One of us grew up in
Columbia, Maryland, which has street names like &amp;quot;Greek Boy
Place.&amp;quot;)&lt;/p&gt;

&lt;p&gt;So all we need is a simple, tasteful, memorable way to remember
32 bits - and we&amp;#39;re on our way to approximating the Triangle.&lt;/p&gt;

&lt;p&gt;Decimal notation is the worst way of remembering a 32-bit number.
IP notation is a little better.  Urbit has a typically crude
approach: we map every byte to a CVC phoneme, making names like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   ~tasfyn-partyv
   ~sivbud-barnel
   ~tomsyt-balsen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These strings, while quite meaningless, are no less memorable
than real human names in many a language.  Moreover, they form a
language of their own, and become more memorable as you use them.
And there are 4 billion of them, which (as we&amp;#39;ll see) is almost
exactly the right number.&lt;/p&gt;

&lt;p&gt;But how do we distribute them?  One obvious solution is a proof
of work scheme, as in Bitcoin.  Coordinating a global
proof-of-work scheme is quite nontrivial, however.  Also, there
is a second reason to compromise 100% decentralization: packet
routing.  It might be possible to use a blockchain as a global
routing table.  It would take some thinking about.&lt;/p&gt;

&lt;p&gt;Furthermore, there&amp;#39;s a clue here that the Bitcoin approach just
isn&amp;#39;t getting.  The limited subspace of short names, within the
general space of 128-bit names, is essentially &lt;em&gt;real estate&lt;/em&gt;.
There is absolutely no reason, moral or practical, to give this
real estate away for free to people whose only contribution is
generating CO2 on their GPUs.  Mining is not in any way a
productive activity.&lt;/p&gt;

&lt;p&gt;Rather, initially, this real estate belongs to Urbit itself.  If
Urbit has value, its real estate has value.  If Urbit has no
value, its so-called real estate is a bunch of worthless bits.
Therefore, any value in the real estate can, should, and will be
used to bootstrap the system from an economic perspective.  Ie,
it belongs to and will be captured by Urbit&amp;#39;s developers and/or
early adopters.  If you find this morally wrong, sorry.  You&amp;#39;re
probably some kind of a communist.&lt;/p&gt;

&lt;p&gt;But because Urbit is a free republican society - not (ahem) a
fascist corporate dictatorship like Google, Facebook or Twitter -
a crucial aspect of launching or transferring a ship is that the
decision is irreversible.  &lt;/p&gt;

&lt;p&gt;As the master of an Urbit ship, your informal title is
cryptographic and &lt;em&gt;allodial&lt;/em&gt; - no one, not the government and
certainly not us, can challenge it.  Unless the attacker can
steal your secrets.  In which case, of course, she might as well
be you.  That&amp;#39;s like Bitcoin too.&lt;/p&gt;

&lt;p&gt;If Bitcoin is money, Urbit is land.  (Floating land is still
land, if there&amp;#39;s a limited amount of it.)  You own both in the
same way, by proving you can keep a secret.  A Bitcoin is not
useful for anything, except selling to a greater fool.  (We&amp;#39;re
just kidding - we&amp;#39;re huge Bitcoin fans.)  But an Urbit ship is
directly useful, so long as Urbit itself is useful.&lt;/p&gt;

&lt;p&gt;You fill your Bitcoin wallet either by creating new coins, or
buying old ones from Satoshi and his cronies.  You build your
Urbit fleet by buying ships from us and our cronies.  (Don&amp;#39;t ask
what we had to do to get them from the aliens.  Those aliens are
into a lot of strange shit, man.)  Ships are transferable, but
Urbit is not designed to be a digital currency.  Transaction
overhead is artificially high.  Again, as in real estate.&lt;/p&gt;

&lt;p&gt;Urbit at present is empty and worthless.  So 32-bit ships -
destroyers - are $0.  Launch a 128-bit ship (a submarine) and
ask me, ~tasfyn-partyv, for one.  We&amp;#39;ll send you one, two, or a
dozen.  You can be as anonymous as you want, if you&amp;#39;re polite.
But, if the network lives, a destroyer price will develop.  It
will be very low at first, but not zero.  Urbit is designed to be
free as in speech.  It&amp;#39;s not designed to be free as in beer.&lt;/p&gt;

&lt;p&gt;How, cryptographically, are cloud ships distributed?  And how are
packets routed?  The answer is the same - the prefix hierarchy.&lt;/p&gt;

&lt;p&gt;In Urbit&amp;#39;s naval terminology, ships above 64 bits are 
&amp;quot;submarines.&amp;quot;  64-bit ships are &amp;quot;yachts.&amp;quot; 32-bit, &amp;quot;destroyers.&amp;quot;
16-bit, &amp;quot;cruisers.&amp;quot;  8-bit, &amp;quot;carriers.&amp;quot;  This also resembles a
feudal hierarchy, so it comes with a feudal terminology.  There
are 256 imperial carriers, 65.280 royal cruisers, 4.294.901.760
rebel destroyers, uncounted scads of private yachts, and more or
less infinitely many rogue submarines.&lt;/p&gt;

&lt;p&gt;Every ship but a submarine has a &amp;quot;will,&amp;quot; or certificate chain - a
linked list of &amp;quot;deeds.&amp;quot;  The first deed in this list is signed by
the ship&amp;#39;s hierarchical prefix, or &amp;quot;flagship.&amp;quot;  Mere submarine are
independent; carriers create cruisers; cruisers create
destroyers; destroyers create yachts.  &lt;/p&gt;

&lt;p&gt;A submarine is the fingerprint of its own public key; a carrier&amp;#39;s
fingerprint is predefined in the kernel.  Anyone can create any
number of 128-bit submarines, whose free and independent
society the 64-bit naval hierarchy cannot interfere with.  And
of course, since Urbit is (a) in the public domain and (b) not
patented, anyone can fork Urbit and change the carrier
fingerprints.  Anyone can also create his own independent and
incompatible DNS, but efforts in this direction have not been
crowned with great success.  In general, the easier it is
technically to fork open-source code or an open standard, the
less likely a fork is to actually happen.&lt;/p&gt;

&lt;p&gt;An independent ship is an independent reputation.  Your flagship
hierarchy, though it created your ship, has no control over it -
so your reputations are and should be separate.  But there are
not 2^64 independent reputations in Urbit, only 2^32.  Cruisers
have no control over the destroyers they create, but yachts have
no independence from the destroyers that created them.&lt;/p&gt;

&lt;p&gt;The reason for this is simple - a destroyer corresponds not to a
person, but  to any institution with its own independent
reputation.  Yachts are for users, bots, or other sub-identities
of this institution.  Each destroyer has 2^32 of them, which is,
of course, a lot.&lt;/p&gt;

&lt;p&gt;How does independence work in practice?  By pinning/TOFU.  For
any deed number, or &amp;quot;life,&amp;quot; the first instance is accepted.  Thus
when changing secrets, perhaps to transfer a ship, the donor
signs a new deed created by the recipient.  Once any ship sees
this deed, it will never accept another signed by the old owner.
Thus, a cruiser cannot sell the same new destroyer twice.
Similarly, deed 7 of ~tasfyn-partyv signs deed 8; but no ship
which has a deed 8 for ~tasfyn-partyv will either accept deed 7,
or any other purported deed 8 which deed 7 later signs.&lt;/p&gt;

&lt;p&gt;Preventing a &amp;quot;double spend&amp;quot; thus depends on propagating the
latest deed.  For this purpose, the ocean is divided into two
kinds of ships: friends and non-friends of the ship being
transferred.  The ship has a list of its cryptographic partners,
or &amp;quot;neighbors,&amp;quot; for which it holds a symmetric key and a routing
(IP) address.  &lt;/p&gt;

&lt;p&gt;The new owner sends the new deed to all the neighbors, thus
locking the old owner out of them.  Future new friends will get
the new owner&amp;#39;s will the same way they get the new owner&amp;#39;s IP
address - by a lookup through the flagship hierarchy.  Thus if we
update both neighbors and flagship, the old owner is locked out
and the new owner is locked in.&lt;/p&gt;

&lt;p&gt;Technically, this is very much an imperfect procedure.  It relies
on social trust to make it effective.  For example, a malicious
seller could edit his neighbor list before delivering the ship.
You probably don&amp;#39;t want to buy a used destroyer from someone you
distrust.  Of course, the same is true of cars.&lt;/p&gt;

&lt;p&gt;And more broadly, the naval hierarchy can and should provide
general administrative support.  For one thing, the big ships
route your packets, at least when establishing contact with your
fellow destroyers.&lt;/p&gt;

&lt;p&gt;So - do you want an Urbit destroyer?  You know you do.  Moreover,
they&amp;#39;re free.  Of course, if you are satisfied with a name that
looks like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    ~machec-binnev-dordeb-sogduc--dosmul-sarrum-faplec-nidted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;you can keep swimming around Urbit in your submarine.&lt;/p&gt;

&lt;p&gt;For a while, anyway.  Because, besides memorability, there is
another reason for short names.&lt;/p&gt;

&lt;p&gt;What&amp;#39;s neat about short names is that there&amp;#39;s a finite number of
them.  This is not a bug, but a feature.  Essentially, to borrow
the thinking of political scientist James Scott, a finite space
is &lt;em&gt;governable&lt;/em&gt;.  An infinite space is ungovernable.&lt;/p&gt;

&lt;p&gt;If there are an infinite number of identities, there is no way
for anyone to distinguish between a new user and a banned user.
A reputation can be punished by destroying it, but anyone can
start again at zero.  A parasite whose only reason to use the
network is to abuse it can keep coming back for more.  An email 
spammer will never run out of addresses to spam from.&lt;/p&gt;

&lt;p&gt;IPv4 is a limited space, which almost but doesn&amp;#39;t cure spam.  The
problem is that IPv4 addresses are neither personal nor property,
so there is generally no easy way to punish a spammer as he
deserves through IP blacklisting.  He is very unlikely to be in
any sense the owner of the IP address on his packets.&lt;/p&gt;

&lt;p&gt;But if the email address and the IP address were the same thing,
and the present fuzzy economic relationship between the user of
an IP address were clear and simple, killing spam would become
easy.  You spam from a destroyer; you go on a list of spammers;
no one will accept your unsolicited messages, ever.&lt;/p&gt;

&lt;p&gt;You can get around this.  You can buy a new destroyer.  But the
thing is - it costs you &lt;em&gt;money&lt;/em&gt;.  You&amp;#39;re not spamming for the
fun of it.  If a destroyer costs a mere $1, the spam you send
from it needs to earn you $1.  &lt;/p&gt;

&lt;p&gt;This does not make it trivial for the forces of light to hunt you
down and render you into processed meat clippings.  But it sure
as heck evens the game.  Who will win?  I guess we&amp;#39;ll see.&lt;/p&gt;

&lt;p&gt;So do you want an Urbit destroyer? Read the &lt;a href=&quot;/2013/11/18/urbit-is-easy-ch1.html&quot;&gt;documentation&lt;/a&gt; for instructions. Come on, they&amp;#39;re free...&lt;/p&gt;
</content>
 </entry>
 

</feed>
