---
layout: post
category: doc
title: Chapter XI (Odds, Ends, Quirks)
---

[**Prev**: Type Inference](/doc/2013/11/19/ch10)

##A bestiary of cores##

The Hoon core is just not a gadget you're familiar with from
your Earth programming career.  A core is not a lambda, a
closure, a library, an object, etc.  Or perhaps we should say:
when we translate any of these into Hoon, we get a core.  So we
cannot translate "core" into any one of them.

But clearly in practice there are lots of different kinds of
practical cores.  For example, we have already met Hoon's
equivalent of the lambda, the `gate`.  Every gate is a core, but
not every core is a gate.  And the gate is by no means the only
subspecies of core.  So describing cores becomes a big part of
the Hoonist's alien vocabulary.  

Let's review briefly what we know about cores.  A core is a noun
of the form

    [battery payload]

where the `battery` is a tree of formulas, each invoked with the
entire core as the subject, and the payload is any noun.

There are three main ways we can talk about a core: its variance
model, `%gold`, `%iron`, `%zinc` or `%lead`, `%gold` by default;
the inference approach of each of its feet, `%ash` or `%elm`,
informally `dry` or `wet`, `dry` or `ash` by default; and its
payload pattern, which makes it a `gate`, `reef`, `book`,
`trap` or `tray`.  There are also several ways of using cores:
you can `pull`, `kick`, `slam` or `slug` them.

For an explanation of variance and inference, see chapter 10.
Here, let's go over the payload patterns.  Unlike most concepts
in Hoon, these are strictly informal conventions.  A core is a
core - there is no code in `hoon.hoon` that deals with a `gate`
per se.  Nonetheless, these definitions are precise and
unambiguous.

###Book###

A core whose payload is either another core, or a constant
(`%cube`), is a `book`.

###Reef###

A book whose payload is either another reef, or a cube, is a
`reef`.  Effectively, a reef is an entirely constant core.

###Trap###

Any core with one arm named `%$` is a trap.  "It's a trap!"

###Gate###

A gate is a trap whose payload has the form `[sample context]`,
`sample` being dynamic data and `context` being anything.

###Tray###

A tray is any core whose payload has the form `[sample
context]`.

###Categories###

Every reef is a book.  Every gate is a trap.  Every gate is a
tray.

###Using cores###

As we already know, a name or axis (which of course applies to
all nouns, not just cores) is a `limb`.  A list of limbs is a
`wing`.  

To access a wing or limb in a core is to `pull` it.  When we
write `a.b.x`, we pull the wing `a.b` (ie, `a` within `b`) from
`x`.  If the result is defined as a subtree of `x`, the wing is a
`leg`.  If it is computed from `x` by a formula, it's an `arm`.

To pull `%$` - the empty name - on a core is to `kick` it.  To
replace the sample with `a` in gate `g` then kick the gate, is
to `slam g with a`.  

(The archaic usage of "call" for `slam` is discouraged, but
common.  Please at least do not use "call" to mean `pull`.)

Slamming is a special case of `slug`, which pulls any limb on a
tray after replacing the sample.  To replace the sample with `a`
on tray `t`, then pull `m`, is to `slug t to m with a`.

Thus when we write

    (~(get by foo) bar)

`++by` produces a tray.  We slug `by` to `get` with `foo`,
producing a gate that searches the map `foo`, and slam this gate
with `bar`.  This is the most normal possible thing in the
universe, though it must seem strange to you now.

##On jet propulsion##

Consider the problem of optimizing a Nock interpreter.  Let's
assume that this process must not and will not contaminate the
pristine semantics of Nock itself.

But by definition, the interpreter does not need to be optimized
to compute all possible functions as fast as possible.  It only
needs to be optimized for the functions it computes.

Moreover, any given function (to use the word in its abstract
mathematical sense), can be computed by an indefinite, and
generally infinite, number of Nock formulas.  Again, we do not
need to optimize all possible formulas - just the ones our
interpreter actually executes.

A crude approach to this problem would be to compute the hash of
every formula we interpret, and hardcode these hashes into the
interpreter.  For hashes both commonly executed, and known to
match some known algorithm, a manual implementation of that
algorithm would be run.

Not quite what we do, but it's close enough.  Nock's conventional
jet model is more or less this hash-matching with the addition of
a reasonably convenient and effective mechanism for matching
formulas and their manual implementations ("jets").

In general it is not correct to match the formula when detecting
jet invocations.  Rather, we need to match the entire core and
the arm being pulled.  In other words, when instrumenting a Nock
interpreter, the correct way to match jets is to sit on top of 
Nock 9 and match both subject and arm.

When matching the subject to see if we can use a jet, we need a
jet description that (a) expects the subject to be a core, (b)
uses a hash to make sure it has the *battery*, and (c) imposes
some other complex constraint on the *payload* of the core.

(Who writes this jet description?  Perhaps the programmer who
wrote the core.  But this requires the programmer to either be the
developer who runs the core, or to have some parallel channel for
delivering her optimizations to the consumer.)
 
In any case, our task is matching the core to the jet.  We divide
this into two parts: one, matching the battery (and arm, since
different arms in a core may or may not be jet-propelled); two,
checking the payload constraint.

It is not practical to compute a hash, especially a *secure*
hash, of every formula we reduce in Nock - or even of every
battery.  We also do not want to make this match heuristically.
Finally, we do not want to give the developer - who may well be
creating the battery and the jet at the same time - the job of
computing hashes by hand.

Battery matching is still a difficult and potentially ugly
problem.  Worst of all, it seems potentially slow.  Some things
that save us:

One, at least unless co-developing core and jet, it is generally 
not common for new batteries to be created.  Therefore, caching
is very worthwhile and pointer equality is often useful.

Two, we do not have room for a full secure hash on every noun,
and we do not want to distinguish batteries from ordinary nouns
when it comes to storage.  However, every indirect noun does have
a 31-bit slot for a conventional FNV hash, `++mug`.  This is
computed lazily, relying on the fact that `0` is not in its
range.  (The mug slot is very useful for jet dispatch - but not
used only for jet dispatch.)

Broadly speaking, while `++mug` is by no means infallible, it
reduces the associative process enough for linear search to be
perfectly practical.

We then need to check the payload.  Broadly speaking, the payload
consists of some mosaic of code, static data, and dynamic data.

Consider a giant reef, like the one `hoon.hoon` constructs.  A
reef is a stack of books, in which each book is the payload of
the one above it.  To make sure our jet matches an arm in any of
these books, we need to check *every battery in the stack*.

The trick to checking a payload is to simplify the payload into a
single *parent core* and a surrounding bundle of data.  To
recognize its core, it is sufficient to (a) recognize its parent
- matching, once again, by the battery - and (b) validate all
other data in the core.

The most common structure of this form is, of course, the tray
`[battery [sample context]]`.  (Again, iff `battery` is a single 
formula which implements an arm `%$`, our tray is a gate.)  Trays
and other core conventions are simply design patterns, which may
be violated with complete impunity.  And there of course may be
multiple cores within the payload.  One must be selected and
treated as the parent; the rest are static data.

As for the sample and/or other dynamic data, it may or may not
prove useful and/or efficient for a jet dispatch mechanism to
enforce basic structure constraints on it.  Remember that, at the
Nock level, we have no guarantee that this core was constructed
in accordance with Hoon type rules.  

However, we can ask the programmer to at least do us the favor of
declaring *logical* cores.  Every time we construct a core -
which, for a core defined by an arm in a book, ie, a typical
library function, is every time we use it - we identify, using
the three legs of the `%sgcn` hint, three aspects of this core:

(p) the axis to its parent core
(q) the logical version of the algorithm implemented
(r) a list of bound arms, as [name axis] pairs

Thus there are two sources of information for a match: the
Hoon programmer, who specifies the logical name of her core;
and the jet programmer, whose declaration matches that logical
name, verifies the match by computing an actual hash, and also
describes any other constraints on the core her jet requires for
it to accurately simulate Nock.  

In addition, it is very advisable for a jet framework to include
tools that let the jet programmer bail out trivially with a
refusal to handle any given case of the function, returning
control to the pure Nock interpreter.

Another advantage of this model is that interpreters which
receive a match for jets for they don't have, still have a
declaration from the programmer's hand of the set of inner loops
that need to be optimized.  This completely eliminates any excuse
for a complex tracing JIT.  We know exactly where to JIT:
wherever we don't find a jet.

##Gonads##

It's common in functional programming to create pipelines of
functions which accept and produce the same type.  If we have
two, three, or 47 gates which both accept and produce an atom,
it's easy to string them together into one gate with two, three,
or 47 pipeline steps.

Suppose we think of one of these homogeneous parts as a block:

       ----
      |    |
    ->| F  |->
      |    |
       ----

    one little function

It's clear that these blocks fit neatly together into a pipeline:

       ----  ----  ----  ----
      |    ||    ||    ||    |
    ->| F  || G  || H  || I  |->
      |    ||    ||    ||    |
       ----  ----  ----  ----

    one big function

But suppose we have a function whose product isn't the same type
as its sample?

       ----
      |    \
    ->| F   )->
      |    /
       ----

    one funky function

It would seem difficult to use this as a building block.  But in
fact, all we need is a little piece of glue that accepts the
product type of F, and produces its sample type:
    
      ----
     \    |
    ->) U |->
     /    |
      ----

    one gluey function

With this, we can construct pipelines using U as the "mortar":

       ----  ----  ----  ----  ----  ----  ---- 
      |    \\    ||    \\    ||    \\    ||    \
    ->| F   )) U || G   )) U || H   )) U || I   )->
      |    //    ||    //    ||    //    ||    /
       ----  ----  ----  ----  ----  ----  ---- 

    one big funky, gluey function

Note that just as FGHI in the simple model has the same interface
as F, G, H or I, FUGUHUI in the complex model has the same
interface as F, G, H, or I.

Let's say the sample of F, the straight line, is X, and the
product of F, the bump, is Y.  So FUGUHUI turns an X into a Y,
just the way F does.

We can make this system even more powerful if, instead of using
the simple tool U, a gate whose sample is Y and whose product X, 
we use a more complex tool V.  V is a gate whose sample is a cell
`[m n]`, where `m` is a Y and `n` is another gate matching F.
V's product remains a Y.

Here's what this looks like in ASCII art:

       ----  ---- 
      |    \\    \
    ->| F   )m V  )->
      |    //    /
       ----  ---- 
              |n
             ----  ----  
            |    \\    \
          ->| G   )m V  )->
            |    //    /
             ----  ---- 
                    |n
                   ----  ----  
                  |    \\    \
                ->| H   )m V  )->
                  |    //    /
                   ----  ---- 
                          |n
                         ----  ----  
                        |    \\    \
                      ->| I   )m V  )->
                        |    //    /
                         ----  ---- 
             
    one big funky, gluey, complicated function

What's the advantage?  A V-function is more powerful than a
U-function, because the U-function has no choice but to turn its
X into a Y and use `n`, the rest of the pipeline, on it.  The V
function can do anything with its input - it could even ignore
the rest of the pipeline and just produce the `m` it got in.

In Hoon, we call one of these funky, gluey, complicated pipelines
a `gonad`.  The gonad rune is `;~`, `[%smsg p q]`.  A gonad has
one `go`, the V part - `p` in `[%smsg p q]` - and one or more
`nads`, the F, G, H or I parts (`q`).

There's one other complicated trick we play to make our gonads
work better.

If you look at the expansion, you'll see that before we pass `n`
to V, the go, we reset its sample to the sample of the gate that
`%smsg` produces.  Since neither the go nor `n` would otherwise
see this value, it allows for more hackery.

For instance, gonads are often used for parsing.  A common go for
parsing is `++pose`, whose nads are parsing rules tried in order -
the first to parse succeeds.  Because of this trick, when the
first nad returns a parsing failure, the second nad is sent to
the go pre-configured with the original problem.

The go doesn't have to do a proper slam on `n`, replacing its 
sample.  It can just use `n` as a trap, leaving the sample
default - in the case of `++pose`, the original parsing problem.
Which is exactly what we want.

##On debugging your urbits##

Okay so you tried to do something and it didn't work.

What happened?  Hopefully, nothing bad.  But coding is a vale of
tears.  Here are some bad things that can happen to you in Hoon.

###Parse error###

You could be 'avin a parse error.  The Hoon parser reports
the location - line and column - of errors quite accurately.

Let's generate an erroneous file.  Open up `try/bin/foo.hoon`,
an empty file, and put a `#` at line 8, column 4.  Then type

    ~waclux-tomwyc/try=> :foo
    ! /~waclux-tomwyc/try/~2014.2.9..06.58.40..e352/bin/foo/hoon
    ! {8 4}
    ! 'syntax-error'
    ! exit

That means you got a syntax error at line 8, column 4, when
trying to load `/~waclux-tomwyc/try=/bin/foo/hoon`.  (You may
also see traces for `/~waclux-tomwyc/arvo=/batz/hoon`, which
simply means Arvo was compiled with debugging.)  

This is always exactly right, for certain values of "right."
As always, you have to understand what Hoon is thinking.

The position of the error is the position at which the parser
*stopped being able to parse* - it has no way to interpret the 
byte at this line and column.  Often this is actually where you
screwed up.  It is at least no *later* than you screwed up.

But one of the prices we pay for for a tall form without
terminators is that the parser relies on knowing that after a
`:+`, for instance, it expects to parse exactly three twigs.  If
you accidentally leave one of these three out, the parser at `:+`
will steal whatever twig should come next.

Generally at some point the parser will collide with reality and
reality will win.  At this position, you'll see a syntax error.
But bad luck can move this point some distance from the mistake.

This is never a serious problem once you get used to Hoon, but it
can be a pain in the butt while you're learning.  To attack any
mysterious syntax error (in any language, not just Hoon), work by
binary search reduction - pull out giant chunks of code to see if
the error is there, or elsewhere.

###Type failure###

Okay, you parsed.  But you're still failing.  Plenty of fail.

By far the most common semantic failure from the Hoon compiler is
the cryptic `type-fail`.  What failed exactly?  We have a lot
more information, but we'd rather not give it to you up front.

The second most common error is `missing limb`.  Here we actually
tell you the name of the limb.  But look, if you write `b.a`,
you'd better have a `b` in your `a`.  You probably have the wrong
idea of what type an `a` is.  So it comes back to type again.

Essentially all Hoon compiler errors are in a sense type failure.
Generally, the compiler wants to shield you from the direct
details, because most ways of presenting the direct details
automatically would, at least in certain cases, just belch all
over the screen.

Instead, the most important information about any Hoon error is
the *location stack*.  Where did this happen?  The general
process of troubleshooting disregards the error details
completely, and starts from the *place* your program failed.

Unlike the parser location, the type location trace is *always*
correct.  But you still have to know how to interpret it.  And
first, you need to know how to *generate* it. 

###Generate your trace###

Every twig within a `!:` generates trace information, both at
compile time and runtime.  Normally you will see `!:` at the
start of a file, and when writing simple programs it is a good
habit just to put it in at the start.

Why wouldn't you always use `!:`?  Because runtime tracing isn't
free, and especially because it kills tail-call optimization.
Also, because sometimes code just works.  For all these reasons,
there is no `!:` on `hoon.hoon` or `zuse.hoon`.

To experiment with tracing, copy `try/bin/goodbye.hoon` into
`try/bin/error.hoon`.`:

      + /~waclux-tomwyc/try/4/bin/error/hoon
      ~waclux-tomwyc/try=> :error "world"
      "hasta la vista, world."

The simplest kind of error is on the command line itself:

      ~waclux-tomwyc/try=> :error
      ! type-fail
      ! exit

But this only happens if the file actually compiles.  Let's make
it not compile, by changing it from

    |=  *
    |=  [planet=tape ~]
    ^-  bowl
    :_  ~  :_  ~
    [%$ !>("hasta la vista, {planet}.")]

to

    |=  *
    |=  [planet=tape ~]
    =+  foo=(add 2)
    ^-  bowl
    :_  ~  :_  ~
    [%$ !>("hasta la vista, {planet}.")]

We've introduced a subtle semantic error into our Folger's
coffee.  How might the discerning compiler respond?

    ~waclux-tomwyc/try=> :error "world"
    ! type-fail
    ! exit

It's mischieviously identical to the argument error.  But if we
add `!:` to the start of the file, we get:

    !:
    |=  *
    |=  [planet=tape ~]
    =+  foo=(add 2)
    ^-  bowl
    :_  ~  :_  ~
    [%$ !>("hasta la vista, {planet}.")]

and running it:

    ! /~zod/try/~2014.2.9..22.36.30..2052/bin/error:<[2 1].[7 37]>
    ! /~zod/try/~2014.2.9..22.36.30..2052/bin/error:<[3 1].[7 37]>
    ! /~zod/try/~2014.2.9..22.36.30..2052/bin/error:<[4 1].[7 37]>
    ! /~zod/try/~2014.2.9..22.36.30..2052/bin/error:<[5 1].[7 37]>
    ! /~zod/try/~2014.2.9..22.36.30..2052/bin/error:<[5 5].[5 16]>
    ! /~zod/try/~2014.2.9..22.36.30..2052/bin/error:<[5 9].[5 16]>
    ! type-fail
    ! exit

We see that the problem is on line 5 between columns 9 and 16.
Ie, `(add 2)`.  Well, duh.

But suppose we can't see what's wrong with `(add 2)`.  Then, it's
time for us to print some types, which we do with `~!`:

    !:
    |=  *
    |=  [planet=tape ~]
    ^-  bowl
    ~!  2
    ~!  +<:add
    =+  foo=(add 2)
    :_  ~  :_  ~
    [%$ !>("hasta la vista, {planet}.")]

We see:

    : /~zod/try/10/bin/error/hoon
    ~zod/try=> :error "world"
    ! /~zod/try/~2014.2.9..22.41.38..5b4d/bin/error:<[2 1].[9 37]>
    ! /~zod/try/~2014.2.9..22.41.38..5b4d/bin/error:<[3 1].[9 37]>
    ! /~zod/try/~2014.2.9..22.41.38..5b4d/bin/error:<[4 1].[9 37]>
    ! /~zod/try/~2014.2.9..22.41.38..5b4d/bin/error:<[5 1].[9 37]>
    ! @ud
    ! /~zod/try/~2014.2.9..22.41.38..5b4d/bin/error:<[6 1].[9 37]>
    ! [a=@ b=@]
    ! /~zod/try/~2014.2.9..22.41.38..5b4d/bin/error:<[7 1].[9 37]>
    ! /~zod/try/~2014.2.9..22.41.38..5b4d/bin/error:<[7 5].[7 16]>
    ! /~zod/try/~2014.2.9..22.41.38..5b4d/bin/error:<[7 9].[7 16]>
    ! type-fail
    ! exit

In other words: our sample, `2`, is a `@ud`; and the default
sample of `add`, `+<:add`, is a `[a=@ b=@]`.  So we'd expect some
problems here.

Hoon believes strongly in modifying the program itself, not some
external metadata, to debug it.  While a `~!` has no runtime cost
and negligible compile-time cost, take it out when you're done.

###Printf, %sgpm###

It's well known that real programmers don't use debuggers.  Real
programmers use printf.

`~&`, informally "printf," is a true printf that sends its
operand, printed by its type (a bit of biblical magic), directly
and magically to the console whenever it executes.  It's okay to
have side effects if they are write-only.

Let's try a `~&` in a working program:

    !:
    |=  *
    |=  [planet=tape ~]
    ^-  bowl
    ~&  [%planet planet]
    :_  ~  :_  ~
    [%$ !>("hasta la vista, {planet}.")]

It's as easy as this:

    : /~zod/try/11/bin/error/hoon
    ~zod/try=> :error "world"
    [%planet "world"]
    "hasta la vista, world."

Please note the very important difference between these outputs.
Both result in a line of text on the console - but `"hasta la
vista, world."` is the legitimate product of the application
bowl, whereas `[%planet "world"]` went into the interpreter as a
hint and came out as a Unix printf.

###Trace###

We also can crash, and get a reasonably useful and accurate trace.
With a very misconceived assert:

    !:
    |=  *
    |=  [planet=tape ~]
    ^-  bowl
    ~&  [%planet planet]
    ?>  =(5 (add 2 2))
    :_  ~  :_  ~
    [%$ !>("hasta la vista, {planet}.")]

we get:

    : /~zod/try/12/bin/error/hoon
    ~zod/try=> :error "world"
    [%planet "world"]
    ! /~zod/try/~2014.2.10..00.18.08..16ea/bin/error/:<[4 1].[8 37]>
    ! /~zod/try/~2014.2.10..00.18.08..16ea/bin/error/:<[5 1].[8 37]>
    ! /~zod/try/~2014.2.10..00.18.08..16ea/bin/error/:<[6 1].[8 37]>
    ! exit

Note that the printf is delivered as soon as it executes.  Note
also that we accurately report the location of the failing twig.
And note finally that without `!:`, we get none of this info.

###Stackf, %sgbr###

`~|` has the same form as `~&`, but it computes at all only if
there is actually a runtime crash within the body of the `~|`.
In that case, it prints its data as part of the stack trace.

It's important to note that `~|` does no work except at crash
time - its hint is not a tank, but a trap producing a tank.
Let's try it:

    : /~zod/try/12/bin/error/hoon
    ~zod/try=> :error "world"
    [%planet "world"]
    ! /~zod/try/~2014.2.10..00.34.28..8f89/bin/error/:<[4 1].[9 37]>
    ! /~zod/try/~2014.2.10..00.34.28..8f89/bin/error/:<[5 1].[9 37]>
    ! /~zod/try/~2014.2.10..00.34.28..8f89/bin/error/:<[6 1].[9 37]>
    ! [%asteroid "world"]
    ! /~zod/try/~2014.2.10..00.34.28..8f89/bin/error/:<[7 1].[9 37]>
    ! exit

And if there's no crash, `~|` doesn't run:

    !:
    |=  *
    |=  [planet=tape ~]
    ^-  bowl
    ~|  [%asteroid planet]
    :_  ~  :_  ~
    [%$ !>("hasta la vista, {planet}.")]

just gives us:

    : /~zod/try/15/bin/error/hoon
    ~zod/try=> :error "world"
    "hasta la vista, world."

Probably someone invented this before, but I haven't seen it.

##Too much information##

[* *Prev**: Type Inference](/doc/2013/11/19/ch10)
